#+title: Fundamentos de inteligencia artificial
#+startup: latexpreview

* Aspectos conceptuales de la Inteligencia Artificial y la ingeniería del conocimiento
- Propósito general de la IA es desarrollar
      1. Modelos conceptuales
      2. Procedimientos de escritura formal de esos procedimientos
      3. Estratégias de programación y máquinas físicas para reproducir los mecanismos de inteligencia.
- 4 Objetivos de la IA son modelar, formalizar, programar e implementar máquinas soporte capaces de interactuar con el medio de forma no trivial.
- Aproximaciones dominantes
      - IA simbólica, via descendente y uso de conceptos del lenguaje natural para representar el conocimiento necesario para resolver problemas de decisión.
            - No requiere de un robot.
      - IA conexionismo situado, via ascendente y usos de conceptos de más bajo nivel semántico.
            - IA como forma superior de adaptación al medio (requiere robot).
- Carácter instrumental y objetivos
      - Ayudar a comoprender los procesos neurofisiológicos, cognitivos y sociales.
      - Prolongar los analizadores humanos y complementar sus deficiencias.

** IA como Ciencia y como IC
*** IA como Ciencia
- Tarea de análisis
- Engloba el conjunto de hechos asociados a la neurología y la cognición.
- Funciones globales de percepción, memoria, lenguaje, decisión, emoción y acción (acciones humanas).
      - Emergen de niveles subcelulares, neurológicos, etc.
- Busca una teoría computable del conocimiento humano.

*** IA como Ingeniería (IC)
- Nuevo objetivo de la IC es el conocimiento.
      - Usa la energía como soporte.
- El mensaje está en la estructura relacional y en el consenso entre los distintos observadores.
      - Deben dotar de significado a los símbolos formales y físicos que constituyen el cálculo.
- El conocimiento debe ser
      - Reutilizable
      - Impersonal
      - Transferible
      - Verificable experimentalmente
      - Con capacidad de predicción (como una ley física).
- No puede apoyarse en una sólida teoría del conoccimiento.
- Tareas que aborda la IC
      1. Tareas básicas como ver, oir, interpretar el medio, moverse, aprender, etc.
      2. Tareas cientifico-técnicas en dominios estrechos
             - Diagnosticar en medicina por ejemplo
- Procedimiento en *SBCs*, sistemas basados en el conocimiento
      1. Descripción en lenguaje natural de las interacciones de un humano con el entorno.
      2. Se modela la descripción con metamodelos (*paradigmas*).
             - Simbólico
             - Conexionista (neurona formal)
             - Situado
             - Híbrido
      3. Escritura formal de las inferencias y los "roles" estáticos y dinámicos de acuerdo con el paradigma elegido.
             - Tipos esenciales de conocimiento
                   - Situado, Interacción con el medio, un robot.
                   - No situado, Interfaz entre el sistema IA y el medio es humana.
      4. Programar los operadores para las interfaces físicas (no humanas).

** Paradigmas actuales en IA
- *Paradigma* como aproximación metodológica consensuada.

*** Paradigma Simbólico o representacional
- Se parte de una descripción en lenguaje natural que se intenta describir en reglas.
- Descripciones declarativas de un conjunto de conceptos.
- Otro conjunto de reglas de inferencia entre estos conceptos.
      - Reglas de manipulación.
- 3 tipos de tareas
      - Análisis
      - Síntesis, diseño y construcción con restricciones.
      - Modificación, ajuste de parámetros.
- Procesos básicos del razonamiento humano según Craik
      - Traslación del medio externo a una representación interna.
      - Derivación de los símbolos anteriores mediante procesos de inferencia (inductiva, deductiva y abductiva).
      - Retraslación de los nuevos símbolos derivados en término de acciones que vuelven al medio externo.
- Apropiada para aplicaciones en las que disponemos de conocimiento suficiente para especificar las reglas inferenciales y en aquellos procesos de aprendizaje inductivo en los que también disponemos de conocimiento para especificar las meta-reglas.

*** Paradigma Situado o reactivo
- También llamado basado en conductas.
- Toda acción y toda percepción están estructuralmente acopladas.
      - El sistema a modelar se encuentra en un medio con el que se realimenta.
            - Sensores y efectores específicos.
            - Para el sistema solo existe lo que puede ser representado por un sensor.
- La percepción en el medio de esquemas son las percepciones
      - Se implementa a bajo nivel.
- Cuando el agente decide la acción o secuencia de acciones a realizar basta con que las active.
      - Los patrones espaciotemporales de acción están precalculados.
- La función de decisión del agente es una asociación (tabla) o autómata finito.
- Se usa esencialmente en robótica y sistemas en tiempo real.

*** Paradigma Conexionista (RNAs)
- *RNAs*, redes de neuronas artificiales.
- Líneas numéricas etiquetadas para la entrada y salida de la red.
- La inferencia se resuelve mediante un clasificador numérico de naturaleza paraétrica.
      - El valor de los parámetros se ajusta mediante aprendizaje.
- Arquitectura modular organizada en capas fuertemente interconectado.
      - Procesadores elementales son las neuronas que evaluan una sencilla función de cálculo.
- Características distintivas
      - Clasificador numérico adaptativo que asocia los valores de un conjunto de observables con los valores de otro conjunto más reducido de clases (salidas de las neuronas de la última capa).
      - Una parte importante del conocimiento disponible se corresponde con la fase de análisis de datos.
            - Selección de variables de entrada y salida.
            - Tipo de cálculo local
            - Inicialización de pesos
      - Balance entre datos y conocimiento disponible y naturaleza de esos datos.
            - Datos etiquetados se usan en el aprendizaje supervisado.
            - Datos no etiquetados se usan para un preproceso y el aprendizaje autootganizativo.
- Representación de grafo.
      - Nodos son neuronas.
      - Arcos son pesos ajustables.
- Las salidas numéricas de la última capa se interpretan con etiquetas asociadas a las clases.
- Hay otra vertiente más basada en mecanismos inspirados por la biología
      - Conexionismo bioinspirado
        
*** Paradigma Híbrido
- La mayor parte de los problemas son de naturaleza híbrida.
- Muy usado en *Sistemas borrosos*, inferencias en las que se mezclan componentes neuronales y borrosas.
      - Adquirir conocimiento, conjuntos borrosos más etiquetas.
      - Pueden usarse entradas numéricas y tratarlas con neuronas convencionales.
      - Pueden definirse esquemas de cálculo neuroborroso (operadores borrosos(min, max)).
      - Subyace conocimiento simbólico usado para especificar las variables y sus rangos, definir funciones de pertenencia y para diseñar la topología inicial de la red.
- Criterios generales.
      - Analizar exigencias computacionales del problema y los recursos de los que disponemos.
      - Descomponer en subtareas e inferencias primitivas.
      - Operacionalización efectiva del esquema inferencial, con módulos simbólicos y neuronales.

* Lógica y representación del conocimiento

* Introducción a las técnicas de búsqueda
** Algunos ejemplos
*** Generación de planes de actuación de robots
- Un entorno de actuación y un robot con un repertorio finito de opciones.
- Programar un robot consiste en.
      - Funciones de percepcion del entorno.
      - Funciones de formulación de planes de actuación.
      - Funciones de seguimientos de los planes.
- Según pag 311 es un problema de optimización casi tipo *Ramificación y poda* o *vuelta atrás*.
      - se usa una función /mueve(x,y)/ para ir avanzando en la solución.

*** Problema de rutas óptimas en grafos        
- pag 312, habla del algoritmo de dijkstra y el del viajante de comercio (travelling salesman problem (TSP)) (ram. y poda).

*** Juegos con contrincante
- pag 313
- Juegos como damas o ajedrez.
- La idea es que cada jugador (ambos IA) eligan la jugada más favorable.

** Formulación de problemas de búsqueda
- Componentes principales de un *sistema de búsqueda*.
      - *Los estados*, todas las situaciones por las que el agente puede eventualmente pasar durante la solución del problema.
            - Implica la elección de el modelo de representación.
      - *Reglas u operadores*, modelan las acciones elementales que es capaz de realizar el agente.
            - La interpretación del coste de cada operador debe hacerse a partir de la función objetivo.
      - *La estratégia de control*, Decide el orden en que se van explorando los estados.
            - La *búsqueda a ciegas* implica visitar más estados.
            - *La búsqueda inteligente* debe implicar visitar menos estados.
- *Estados* y *operadores* definen en *espacio de búsqueda*.
      - Algunos *nodos* (representación de grafo) del espacio de búsqueda representan las soluciones.
- Un *algoritmo de búsqueda es completo* si siempre encuentra solución, en el caso que exista alguna.
- Un *algoritmo de búsqueda es admisible* o exacto si siempre encuentra una solución óptima.

** Métodos de búsqueda sin información
- Búsquedas de forma sistemática sin tener en cuenta nungún tipo de información sobre el dominio del problema.
- Se suele considerar un árbol como espacio de búsqueda.
      - El grafo para espacios de búsqueda más generales.

*** Recorrido de árboles
**** Primero en Anchura
- Es un *algoritmo completo*.
- Si todas las reglas tienen un coste de 1 es *admisible*.
- Tiempo de ejecución y el espacio de memoria crecen de forma exponencial.
- El número de nodos total (que pueden visitarse) de un árbol es una *sucesión geométrica*.
      - $\sum_{i=0}^d b^{i} = \frac{b^{d+1} - 1}{b-1}$
            - $b$ es el número de hijos de cada nodo, que puede ser el caso medio.
            - Se supone que el nivel 0 es de 1 solo nodo.

#+begin_src pseudocode
ABIERTA=(inicial)
mientras NoVacia(ABIERTA) hacer
    n <- ExtraePrimero(ABIERTA)
    
    si EsObjetivo(n) entonces
        dev Camino(inicial,n)
    fsi
    
    S = Sucesores(n)
    
    para cada q en S hacer
        pone q en la TABLA_A con         // TABLA_A almacena los datos de un estado de búsqueda
            Anterior(q) = n,
            Coste(inicial,q) <- Coste(inicial,n) + Coste(n,q)
        ABIERTA <- ABIERTA union {q}
    fpara
fmientras
dev "No encontrado"
#+end_src

**** Primero en profundidad
- No es una estratégia admisible ni completa, puede adentrarse en un rama infinita.
      - Suele establecerse una profundidad límite.
- Si la profundidad límite es $d$, el espacio requerido máximo es.
      - $(b-1)(b-2) + b$ para ABIERTA
      - $1+(d-1)b$ para TABLA_A
- Máximo de nodos visitados $\frac{b^{d+1}-1}{b-1}$

#+begin_src pseudocode
ABIERTA=(inicial)                 // Es una pila
mientras NoVacia(ABIERTA) hacer
    n=ExtraePrimero(ABIERTA)
    si EsObjetivo(n) entonces
        devolver Camino(inicial,n)
    fsi
    S={}
    si Profundidad(n) < ProdundidadLimite entonces
        S = Sucesores(n)
    fsi
    si Vacio(S) entonces
        LimpiarTabla_A(n)
    fsi
    para cada q en S hacer
        pone q en la TABLA_A con
            Anterior(q) <- n,
            Coste(inicial,1) <- Coste(inicial,n) + Coste(n,q),
            Profundidad(q) <- Profundidad(n) + 1
        Encola(q, ABIERTA)
    fpara
fmientras

dev "No encontrado"
#+end_src        

**** Coste uniforme
- En vez de usar una pila o una cola pueden insertarse los nodos en una estructura ordenada.
      - Se ordenan por coste desde el nodo inicial.
- Es un *algoritmo admisible*.

****   Búsquedas en profundidad y en anchura iterativas
pag 320

- Búsqueda en profunidad que se va ampliando la produndidad límite si no se encuentra ninguna solución.

#+begin_src pseudocode
ProfundidadLimite <- 1
Solucion <- BusquedaPrimeroenProfundidad
mientras Solucion = "No encontrado" hacer
    Solucion <- BusquedaPrimeroenProfundidad
fmientras
dev Solucion
#+end_src

- Búsqueda en anchura que va ampliando la anchura límite si no se encuentra ninguna solución.

#+begin_src pseudocode
AnchuraLimite <- 0
mientras se pueda aumentar la AnchuraLimite hacer
    AnchuraLimite <- AnchuraLimite + 1
    ABIERTA <- (inicial)
    mientras NoVacia(ABIERTA) hacer
        n <- ExtraePrimero(ABIERTA)
        
        si EsObjetivo(n) entonces
            dev Camino(inicial,n)
        fsi
        
        S <- Sucesores(n,AnchuraLimite)  // AnchuraLimite limita el número
                                         //  de nodos sucesores
        para cada q en S hacer
            poner q en la TABLA_A con
                Anterior(q) <- n,
                Coste(inicial,q) <- Coste(inicial,n) + Coste(n,q)
                
            Encolar(q, ABIERTA)
        fpara
    fmientras
fmientras
dev "No encontrado"
#+end_src

*** Recorrido de grafos
- A veces el ábol no sirve para modelar los estados de una solución.
      - Por ejemplo en el cálculo de actuación de planes de un robot.

**** Algoritmo general de búsqueda en grafos (AGBG)
- Grafo dirigido simple a partir de operadores o reglas de producción.
- Número de reglas con un coste $\leq \varepsilon$, $\varepsilon > 0$, debe ser finito.
- Grafo localmente finito, cada nodo tiene un número finito de sucesores.

#+begin_src pseudocode
// TABLA_A contiene el mejor camino encontrado desde inicial a cada nodo.
ABIERTA <- (inicial)
mientras NoVacia(ABIERTA) hacer
    n <- ExtraePrimero(ABIERTA)
    si EsObjetivo(n) entonces
        dev Camino(inicial, n)
    fsi
    S <- Sucesores(n)
    Añade S a la entrada n en TABLA_A
    para cada q de S hacer
        si q en TABLA_A entonces
            Rectificar(q,n,Coste(n,q))   // Se comprueba si el nuevo camino es mejor
            Ordenar(ABIERTA)             // Ordenación por coste
            // No se incluye en ABIERTA
        sino
            pone q en la TABLA_A con
                Anterior(q) <- n,
                Coste(inicial,q) <- Coste(inicial,n) + Coste(n,q)
            ABIERTA <- Mezclar(q, ABIERTA)  // Inserta q en abierta
                                            //  Según la posición la búsqueda será
                                            //  en profundidad o en anchura
        fsi
    fpara
fmientras
dev "No solución"
#+end_src

#+begin_src pseudocode
fun Rectificar(n,p,costepn)
    si (Coste(inicial,p) + costepn) < Coste(inicial,n) entonces
        modifica la entrada del nodo n en la TABLA_A con
            Coste(inicial,n) <- Coste(inicial,p) + costepn
            Anterior(n) <- p
        RectificarLista(n)
    fsi
ffun

fun RectificarLista(n)
    LISTA <- Sucesores(n)    // Registrados en la TABLA_A
    para cada q de LISTA hacer
        Rectificar(q,n,Coste(n,q))
    fpara
ffun
#+end_src

**** Búsqueda bidireccional
- Buscar simultáneamente en dos direcciones.
      - De inicio a los objetivos.
      - De los objetivos a inicio.
- La búsqueda se detiene cuando las fronteras (listas ABIERTA) tienen algún nodo en común.
- En lugar de exponencial a $d$ podrían ser dos algoritmos a $d/2$.
- Hay que conocer los estados objetivos.
- Almenos una de las búsquedas debe retener en memoria todos los estados visitados.
      - Por tanto búsqueda en anchura.
      - Por tanto el espacio requerido es exponencial en $d/2$.
- Requiere un método eficiente para comprobar intersecciones de las dos listas.
      - tablas Hash puede valer.

* Glosario
- *Inferencia*, Razonamiento, proceso mediante el cual partiendo de unos hechos se deducen otros hechos.
      - *Inferencia deductiva*, A implica B, C implica B, etc.
      - *Inferencia abductiva*, aspiramos a obtener hipótesis.
            - Inferencia de hipótesis que pueden explicar un hecho.
            - Hechos con un cierto grado de certeza asociado.
      - *Inferencia inductiva*, A si y solo si (B o C o D).
            - A partir de la experiencia constatada.
- *Agente racional*, Agente que actúa con la intención de alcanzar el mejor resultado. Cuando hay incertidumbre el mejor resultado esperado.
- *RNN*, Redes neuronales recurrentes
- *CNN*, Redes neuronales convolucionales
- *GAN*, Redes generativas adversarias.
      - Redes neuronales no supervisadas pero basadas en auto-entrenamiento supervisado.
      - Indicadas para IA Generativa.
      - Juego de suma 0 entre.
            - Generador Genera instancias a partir de lo que aprende del dominio
            - Discriminador, trata de valorar si la instancia es del mundo real o generada.
- *VAE*, Autocodificadores variacionales.
- *GPT*, Generative pretained trasformer
- *Interpretabilidad*, propiedad de entender la relación entre los datos procesados y la solución propuesta.
- *Explicabilidad*, Capacidad de entender el razonamiento efectuado por la máquina.
- *Frugalidad*, Propiedad de los algoritmos de aprendizaje de necesitar pocos recursos para mostrar unas prestaciones aceptables.
      - Tanto en el uso como en el entrenamiento.


