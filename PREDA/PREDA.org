#+title: PREDA

* Voraz
* Divide y vencerás
** Planteamiento General
- Descomposición de un problema en subproblemas de su mismo tipo.
- Resolución recursiva de los subproblemas.
- Combinación si procede de las soluciones del problema.

** Esquema General
#+BEGIN_EXAMPLE
fun DyV(problema)
    si trivial(problema) entonces
        dev solución-trivial
    sino hacer
        {p1,p2,...,pk} <- descomponer(problema)
        para i in (1..k) hacer
            si <- DyV(pi)
        fpara
    fsi
    dev combinar(s1,s3,...,sk)
ffun
#+END_EXAMPLE

** Búsqueda Binaria
#+BEGIN_EXAMPLE
fun bbinaria(i,j:entero; v:vector[1..N] de entero; x:entero): booleano
    // Primer índice del vector 1 para simplificar
    var
        m:entero
    fvar
    si i=j entonces                  // los dos índices han convergido al mismo valor
        si v[i]=x entonces
            dev verdadero
        sino
            dev falso
        fsi
    sino
        m <- (i+j) div 2
        si x <= v[m] entonces
            bbinaria(i,m,v,x)
        sino
            bbinaria(m+1,j,v,x)
        fsi
    fsi
ffun
#+END_EXAMPLE

** Ordenación rápida (Quicksort)                                     :ATTACH:
:PROPERTIES:
:ID:       b26bd1bd-be2d-4542-bb20-c2908cedde80
:END:
- pag 124, ordena de menor a mayor.
- Menores que el pivote a la izquierda del pivote, mayores a la derecha.

#+BEGIN_EXAMPLE
fun Pivotar(T:vector[i..j] de entero; pivote:natural)
    var
        p,k,l:entero
    fvar
    p <- T[i]                                  // Primer valor de T
    k <- i                                     // Primer índice de T
    l <- j+1                                   // último índice de T + 1
    repetir k <- k+1 hasta T[k] > p or k >= j  // k+1 hasta que T[k] mayor que
                                               //  el primer  valor de T o k al final de T
    repetir l <- l-1 hasta T[l] <= p           // l-1 hasta que T[l] menor igual 
                                               //  que el primer valor de T
    mientras k < l hacer                       // hasta que k y l se crucen
        intercambiar(T,k,l)                    // Se intercambian los valores
        repetir k <- k + 1 hasta T[k] > p      // subir índice izquierdo hasta que T[k]
                                               //  mayor que el primer valor de T
        repetir l <- l - 1 hasta T[l] <= p     // Bajar índice derecho hasta que T[l]
                                               //  menos o igual que el primer valor de T
    fmientras
    intercambiar(T,i,l)
    pivote <- l
ffun
#+END_EXAMPLE

[[attachment:clipboard-20260129T110042.png]]
  
#+BEGIN_EXAMPLE
fun Quicksort(T[i..j])
    var
        l:natural
    fvar
    l <- i                                     // Se suele elegir el primer elemento
                                               //  Como pivote.
    si trivial(i-j) entonces Insertar(T[i..j]) // Trivial si son tan solo dos elementos
    sino
        Pivotar(T[i..j],l)                     // Pivotar actualiza el valor de l
                                               // Desde el pivote dividimos el vector
                                               //  El pivote no se incluye en el
                                               //  proceso recursivo
        Quicksort(T[i..l-1])
        Quicksort(T[l+1..j])
    fsi
ffun
#+END_EXAMPLE

** Cálculo del elemento mayoritario en un vector
- Buscar si un elemento aparece (n/2) + 1 veces en el vector
- Importante diferenciar que mayoritario no es el que aparece más veces.
  Sino estrictamente el que aparce almenos (n/2) + 1

fun Mayoritario(i,j:natural; v:vector[1..n] de natural): entero
    var
        m: natural
        s1,s2: entero
    fvar
    si i=j entonces                     // Caso trivial
        dev v[i]
    sino
        m <- (i+j) / 2                  // Punto medio, división entera
        s1 <- Mayoritario(i,m,v)        // La mitad menor (caso de n impar)
        s2 <- Mayoritario(m+1,j,v)      // La mitad mayor
        dev Combinar(s1,s2,i,j,v)
     fsi
ffun

fun Combinar(a,b:entero; i,j:natural; v:vector[1..n] de natural): entero
    si a=-1 and b=-1 entonces dev -1 fsi
    si a=-1 and b!=-1 entonces dev ComprobarMayoritario(i,j,b,v) fsi
    si a!=-1 and b!=-1 entonces dev ComprobarMayoritario(i,j,a,v) fsi
        si ComprobarMayoritario(i,j,a,v)=a entonces
            dev a
        sino si ComprobarMayoritario(i,j,b,v)=b entonces
            dev b
        sino
            dev -1
        fsi
    fsi
ffun

fun ComprobarMayoritario(i,j:natural; x:entero; v:vector[1..n] de natural): entenro
    var
        c:natural
    fvar
    v <- 0
    para k <- i hasta j hacer
        si v[k]=x entonces c<-c+1 fsi
    fpara
    si c > (j-i+1)/2 entonces dev x sino dev -1 fsi
ffun

* Vuelta atrás
* Programación dinámica
** Planteamiento general
- Establecimiento de las ecuaciones que representan el problema.
- Identificación de los resultados parciales.
- Construcción de la tabla de resultados parciales:
      - Inicialización de la tabla con los casos base que establece la ecuación del problema.
      - Establecimiento del orden de llenado de la tabla, de forma que se calculen en primer lugar los resultados parciales que requiern pasos posteriores.
      - Sustitución de las llamas recursivas del algoritmo por consultas a la tabla.

** Esquema General
- pag 131, no hay esquema general, hay ejemplos con fibonacci
  

* Ramificación y Poda
** Mochila Entera
#+BEGIN_EXAMPLE
tipo TVectorB = matriz[1..n] de booleano
tipo TVectorR - matriz[1..n] de real
tipo TNodo = registro        // Solución parcial o final
    moch: TVectorB           // Elementos incluidos
    k: entero                // etapa de búsqueda, posición del objeto a considerar
    pesoT: real              // Peso objetos introducidos
    valorT: real             // valor objetos introducidos
    estOpt: real             // estimación Optimista,
                             //   determina posición en montículo
fregistro

/**
 * pesos: TVectorR: pesos de los objetos de mayor a menos valor.
 * valores: TVectorR: valor de los objetos de mayor a menor.
 * P: real: peso máximo soportable.
 * moch: out TVectorB: vector objetod añadidos de inicio con todo en falso de salida?
 * valor: real: valor de la solución óptima.
 * pesos, valores y moch tienen los objetos ordenados de más e menor valor.
 */
fun Mochila(pesos: TVectorR, valores: TVectorR,
            P:real, moch: out TVectorB, valor: out real)
    var
        monticulo: TMonticulo
        nodo, hijo: TNodo
        cota : real   // la cota sirve para podar ramas no óptimas
        estPes: real  // Sirve para actualizar la cota si alguna rama
                      //   en el peor de los casos puede dar una solución mejor
    fvar
    
    monituclo <- CreatMonticuloVacio()
    valor <-0
    
    // Construimos primer nodo
    //   no es solución es solo el inicio (empieza en k=1)
    nodo.moch <- moch
    nodo.k <- 0
    nodo.pesoT <- 0
    nodo.valorT <- 0
    nodo.estOpt <- EstimacionOpt(pesos, valores, P, nodo, pesoT, nodo.valorT)

    Insertar(nodo, monticulo)
    
    cota <- EstimacionPes(
        pesos, valores, P,nodo.k,
        nodo.PesoT, nodo.valorT
        )

    mientras !MonticuloVacio(monticulo) &&
             EstimacionOpt(Primero(monticulo)) >= cota hacer
             
        nodo <- OptenerCima(monticulo)  // la solución con mejor estimación
        
        hijo.k    <- nodo.k + 1      // el siguiente objeto
        hijo.moch <- nodo.moch       // copy?
        
        // cabe el objeto en la mochila?
        si nodo.pesoT + pesos[hijo.k] <= P entonces
            hijo.moch[hijo.k] <- cierto   // añadimos el nuevo objeto
            hijo.pesoT  <- nodo.pesoT + pesos[hijo.k]
            hijo.valorT <- nodo.valorT + valores[hijo.k]
            hijo.estOpt <- nodo.estOpt
            si hijo.k = n entonces
                // el último nodo es el nodo n
                si cota <= hijo.valorT entonces
                    // vemos si mejoramos la cota actual
                    //  Representa una solución óptima encontrada
                    moch  <- hijo.moch
                    valor <- hijo.valorT
                    cota  <- valor  // actualizamos cota
                fsi
            sino
                // la solución no está completa
                // añadimos una copia del hijo al montículo
                // (si la estOpt es alta se posicionará cerca de la cima)
                Insertar(hijo, monticulo) // insertamos copia
            fsi
        fsi

        // Estimación sin el objeto hijo en la mochila
        hijo.estOpt <- EstimacionOpt(
            pesos, valores, P, hijo.k /* se comprueba a partir de k+1 */,
            nodo.pesoT, nodo.valorT
            )

        si hijo.estOpt >= cota entonces
            // solución sin el objeto k que mejora la cota
            hijo.moch[hijo.k] <- falso
            hijo.pesoT  <- nodo.pesoT
            hijo.valorT <- nodo.valorT
            
            si hijo.k = n entonces
                si cota <= hijo.valorT entonces
                    // guardamos la solución final que mejora la cota
                    //   actualizamos la cota porque la mejora
                    moch  <- hijo.moch
                    valor <- hijo.valorT
                    cota  <- valor
                fsi
            sino
                // solución no completa
                //  insertamos una copia de hijo
                Insertar(hijo, monticulo)
                estPes <- EstimacionPes(pesos, valores, P, hijo.k,
                                        hijo.PesoT, hijo.valorT)

                // comprobamos si la estimación pesimista sin el objeto
                //  mejora la cota, si es así actualizamos la cota
                si cota < estPes entonces
                    cota <- estPes
                fsi
            fsi
        fsi
    fmientras
ffun

fun EstimacionOpt(pesos, valores : TVectorT, P: real,
                  k: entero, pesoT: real, valorT: real): real
    var
        capacidad, estimacion : real
        i : entero
    fvar
    
    capacidad <- P - pesoT  // Peso máximo - peso actual
    estimacion <- valorT

    i <- k + 1 // siguiente objeto
    mientras i <= n && capacidad >= 0 hacer
        si pesos[i] <= capacidad entonces
            estimacion <- estimacion + valor[i]  // más valor
            capacidad <- capacidad - pesos[i]    // pero menos capacidad
        sino
            // se pone una parte de este objeto
            // que no es real es la estimación optimista
            estimacion <- estimacion + (capacidad / pesos[i]) * valor[i]
            capacidad <- 0
        fsi
        i <- i + 1
    fmientras
    dev estimacion
ffun

fun EstimacionPes(pesos, valores: TVectorR, P:real,
                  k:entero, pesoT: real, valorT: real) : real
    var
        capacidad, cota: real
        i: entero
    fvar
    
    capacidad <- P - pesoT
    cota <- valorT
    i <- k + 1      // siguiente objeto
    mientras i <= n && capacidad >= 0 hacer
        si pesos[i] <= capacidad entonces
            cota <- cota + valor[i]
            capacidad <- capacidad - pesos[i]
        fsi
        // no se introducen objetos fraccionados
        i <- i+1
    fmientras
    
    dev cota
ffun                  

#+END_EXAMPLE


