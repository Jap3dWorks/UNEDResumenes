#+title: PREDA

* Estructuras de datos
** Montículo
# TODO

* Voraz
** Planteamiento general
- Para problemas de optimización donde la solución se puede construir paso a paso sin necesidad de reconsiderar decisiones.
- Características del esquema.
      - Resolución de un problema de forma óptima
      - *Conjunto inicial de candidatos*, elementos que hay que planificar.
      - *Conjunto de candidatos Seleccionados*, elementos que ya han sido considerados y seleccionados.
      - *Conjunto de candidatos Reachazados*
      - *Función Solución*, determina si el conjunto de candidatos es na solución óptima.
      - *Función factible*, determina si la solución es competable o factible.
      - *Función Selección*, Escoge al candidato más prometedor todavia no seleccionado.

** Esquema general

#+BEGIN_EXAMPLE
fun Voraz(c: ConjuntoCandidatos&): ConjuntoCandidatos
    sol <- {}                                // Conjunto de candidatos seleccionados
    mientras c != {} && !Solución(sol) hacer
        x <- seleccionar(c)                  // Selecciona el mejor candidato
        c <- c \ {x}
        si factible(sol union {x}) entonces  // La union de sol y x es factible
            sol <- sol union {x}
        fsi
    fmientras
    si solucion(sol) entonces                // Comprobamos si es una solución
        dev sol
    sino
        imprimir("No hay solución")
    fsi
ffun
#+END_EXAMPLE

** Árbol de recubrimiento mínimo: algoritmo de Prim

*** Planteamiento general
#+BEGIN_EXAMPLE
/*
 * @param G <N,A>: grafo de N vértices con A aristas
*/
fun Prim(G=<N,A>:Grafo): conjunto de aristas
    AR <- {}                                // árbol de recubrimiento
    NA <- {un nodo cualquiera de N}         // vértices del árbol de recubrimiento
    miemtras NA != N hacer
        Buscar {u,v} de coste mínimo tal que u in NA u v in N \ NA
        AR <- AR union {(u,v)}
        NA <- NA union {u}
    fmientras
    dev AR
ffun
#+END_EXAMPLE

*** Descripción detallada
#+BEGIN_EXAMPLE
tipo VectorNat=matriz[0..n] de natural
tipo VectorEnt=matriz[0..n] de entero
fun Prim(G=<N,A>: grafo): conjunto de aristas
    var
        nodoMinimo: VectorNat
        costeMinimo: VectorEnt
        AR: conjunto de aristas
    fvar
    AR <- {}
    costeMínimo[1] <- -1     // Coste del primer vertice consigo mismo
    para i <- 2 hasta n hacer
        nodoMinimo[i] <- 1
        costeMinimo[i] <- Distancia(1,i)
    fpara
    para i <- 1 hasta n-1 hacer
        min <- infty
        para j <- 2 hasta n hacer
        
ffun
#+END_EXAMPLE

* Divide y vencerás
** Planteamiento General
- Descomposición de un problema en subproblemas de su mismo tipo.
- Resolución recursiva de los subproblemas.
- Combinación si procede de las soluciones del problema.

** Esquema General
#+BEGIN_EXAMPLE
fun DyV(problema)
    si trivial(problema) entonces
        dev solución-trivial
    sino hacer
        {p1,p2,...,pk} <- descomponer(problema)
        para i in (1..k) hacer
            si <- DyV(pi)
        fpara
    fsi
    dev combinar(s1,s3,...,sk)
ffun
#+END_EXAMPLE

** Búsqueda Binaria
#+BEGIN_EXAMPLE
fun bbinaria(i,j:entero; v:vector[1..N] de entero; x:entero): booleano
    // Primer índice del vector 1 para simplificar
    var
        m:entero
    fvar
    si i=j entonces                  // los dos índices han convergido al mismo valor
        si v[i]=x entonces
            dev verdadero
        sino
            dev falso
        fsi
    sino
        m <- (i+j) div 2
        si x <= v[m] entonces
            bbinaria(i,m,v,x)
        sino
            bbinaria(m+1,j,v,x)
        fsi
    fsi
ffun
#+END_EXAMPLE

** Ordenación rápida (Quicksort)                                     :ATTACH:
:PROPERTIES:
:ID:       b26bd1bd-be2d-4542-bb20-c2908cedde80
:END:
- pag 124, ordena de menor a mayor.
- Menores que el pivote a la izquierda del pivote, mayores a la derecha.

#+BEGIN_EXAMPLE
fun Pivotar(T:vector[i..j] de entero; pivote:natural)
    var
        p,k,l:entero
    fvar
    p <- T[i]                                  // Primer valor de T
    k <- i                                     // Primer índice de T
    l <- j+1                                   // último índice de T + 1
    repetir k <- k+1 hasta T[k] > p or k >= j  // k+1 hasta que T[k] mayor que
                                               //  el primer  valor de T o k al final de T
    repetir l <- l-1 hasta T[l] <= p           // l-1 hasta que T[l] menor igual 
                                               //  que el primer valor de T
    mientras k < l hacer                       // hasta que k y l se crucen
        intercambiar(T,k,l)                    // Se intercambian los valores
        repetir k <- k + 1 hasta T[k] > p      // subir índice izquierdo hasta que T[k]
                                               //  mayor que el primer valor de T
        repetir l <- l - 1 hasta T[l] <= p     // Bajar índice derecho hasta que T[l]
                                               //  menos o igual que el primer valor de T
    fmientras
    intercambiar(T,i,l)
    pivote <- l
ffun
#+END_EXAMPLE

[[attachment:clipboard-20260129T110042.png]]
  
#+BEGIN_EXAMPLE
fun Quicksort(T[i..j])
    var
        l:natural
    fvar
    l <- i                                     // Se suele elegir el primer elemento
                                               //  Como pivote.
    si trivial(i-j) entonces Insertar(T[i..j]) // Trivial si son tan solo dos elementos
    sino
        Pivotar(T[i..j],l)                     // Pivotar actualiza el valor de l
                                               // Desde el pivote dividimos el vector
                                               //  El pivote no se incluye en el
                                               //  proceso recursivo
        Quicksort(T[i..l-1])
        Quicksort(T[l+1..j])
    fsi
ffun
#+END_EXAMPLE

** Cálculo del elemento mayoritario en un vector                     :ATTACH:
:PROPERTIES:
:ID:       46f2d130-5688-4af6-8c45-9f8dbd7fe57c
:END:
- Buscar si un elemento aparece (n/2) + 1 veces en el vector
- Importante diferenciar que mayoritario no es el que aparece más veces.
  Sino estrictamente el que aparce almenos (n/2) + 1

#+BEGIN_EXAMPLE  
fun Mayoritario(i,j:natural; v:vector[1..n] de natural): entero
    var
        m: natural
        s1,s2: entero
    fvar
    si i=j entonces                     // Caso trivial
        dev v[i]
    sino
        m <- (i+j) / 2                  // Punto medio, división entera
        s1 <- Mayoritario(i,m,v)        // La mitad menor (caso de n impar)
        s2 <- Mayoritario(m+1,j,v)      // La mitad mayor
        dev Combinar(s1,s2,i,j,v)
     fsi
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
fun Combinar(a,b:entero; i,j:natural; v:vector[1..n] de natural): entero
    si a=-1 and b=-1 entonces dev -1 fsi
    si a=-1 and b!=-1 entonces dev ComprobarMayoritario(i,j,b,v) fsi
    si a!=-1 and b!=-1 entonces dev ComprobarMayoritario(i,j,a,v) fsi
        si ComprobarMayoritario(i,j,a,v)=a entonces
            dev a
        sino si ComprobarMayoritario(i,j,b,v)=b entonces
            dev b
        sino
            dev -1
        fsi
    fsi
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
fun ComprobarMayoritario(i,j:natural; x:entero; v:vector[1..n] de natural): entenro
    var
        c:natural
    fvar
    c <- 0
    para k <- i hasta j hacer
        si v[k]==x entonces c <- c+1 fsi
    fpara
    si c > (j-i+1)/2 entonces
        dev x
    sino
        dev -1
    fsi
ffun
#+END_EXAMPLE

Ejemplo de una traza

[[attachment:clipboard-20260129T132356.png]]

* Vuelta atrás
** Planteamiento general
- búsqueda exaustiva de las posibles soluciones.
- Recorrido en *Profundidad* del grafo inplícito de un problema.
      - Grafo sin ciclos

** Esquema general
- /IniciarExploraciónNivel()/, Opciones posibles para extender la solución k-prometedora.
- /OpcionesPendientes()/, Compruena que quedan opciones por explorar en el nivel.
- /SoluciónCompleta()/, Comprueba si se ha encontrado una solución.
- /ProcesarSolución()/, Hacer las acciones necesarias con la solución.
  Por ejemplo *dev* o imprimir el resultado.
- /Completable()/, comprueba que la solución k-prometedora se puede extender.

#+BEGIN_EXAMPLE
/*
 * @param v: secuencia k-prometedora
 * @param k: nivel
 */
fun VueltaAtras(v: Secuencia; k: entero)
    IniciarExploraciónNivel(k)
    mientras OpcionesPendientes(k) hacer
        extender v con siguiente opción
        si SoluciónCompleta(v) entonces
            ProcesarSolución(v)
        sino
            si Competable(v) entonces
                VueltaAtras(v, k+1)
            fsi
        fsi
    fmientras
ffun
#+END_EXAMPLE

Si solo se busca una solución.

#+BEGIN_EXAMPLE
fun VueltaAtras(v: Secuencia; k: entero; encontrado: booleano)
    IniciarExploraciónNivel(k)
    mientras OpcionesPendientes(k) && !encontrado hacer
        extender v con siguiente opción
        si SoluciónCompleta(v) entonces
            ProcesarSolución(v)
            encontrado <- true
        sino
            si Competable(v) entonces
                VueltaAtras(v, k+1, encontrado)
            fsi
        fsi
    fmientras
ffun
#+END_EXAMPLE

** Problema de la reina
Se quiere situar una reina en cada columna de un tablero de ajedrez de forma que ninguna de ellas pueda eliminar a ninguna otra reina.

La solución mostrada busca todas las soluciones posibles.
#+BEGIN_EXAMPLE
/*
 * @param s: Almacena la solución temporal.
 *  En cada celda (columna) se almacena el número de la fila donde se posiciona la reina.
 * @param n: tamaño del tablero
 */
fun Reinas(s:Vector[1..n] de entero; n,k:entero)
    s[k] <- 0
    mientras s[k] <= n hacer
        s[k] <- s[k] + 1                    // Se va probando desde la primera
                                            //  hasta la última fila.
        si Completable(s,k) entonces
            si k=n entonces
                escribir(s)                 // Muestra la solución o
                                            //  la escribe en un archivo
            sino
                Reinas(s,n,k+1)
            fsi
        fsi
    fmientras
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
/*
 * Comprueba que no hayan reinas en la misma fila ni en la misma diagonal.
 */
fun Completable(s:Vector[1..n] de entero; k: entero):booleano
    var
        i:entero
    fvar
    para i <- 1 hasta k-1 hacer
        // Es interesante ver la forma de comprobar la diagonal
        si s[i]==s[k] || (abs(s[i]-s[k])==abs(i-k)) entonces
            dev falso
        fsi
    fpara
    dev true
ffun
#+END_EXAMPLE

** Coloreado de grafos
Se desea asignar un color a cada vértice de un grado conexo, de forma que no hayan vertices adyacentes con el mismo color.

Se sabe que se necesitan 4 colores como mínimo para cualquier grafo.

#+BEGIN_EXAMPLE
// Grafo[i,j]==1 si i,j están conectados.
tipo Grafo=matriz[i..N,i..N] de entero
tipo Vector=matriz[i..N] de entero

/*
 * @param v: Vector k-prometedor, posición i representa al vector i
 * @param m: Número de colores
 * @param k: Nivel de la solución
*/
fun ColoreaGrafo(g:Grafo; m:entero; k:entero; v:Vector; exito: booleano&)
    v[k] <- 0
    exito <- false
    mientras v[k] < m && !exito hacer
        v[k] <- v[k] + 1
        si Competable(g,v,k) entonces
            si k==N entonces
                Procesar(v)
                exito <- true
            sino
                ColoreaGrafo(g,m,k+1,v,exito)
            fsi
        fsi
    fmientras
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
/*
 * Comprueba si algún vértice conectado a k tiene el mismo color que el vértice k.
*/
fun Completable(g:Grafo, v:Vector, k:entero): booleano
    i:entero
    para i <- 1 hasta k-1 hacer
        si g[k,i]==1 && v[k]==v[i] entonces
            dev false
        fsi
    fpara
    dev true
ffun
#+END_EXAMPLE

* Programación dinámica
** Planteamiento general
- Establecimiento de las ecuaciones que representan el problema.
- Identificación de los *resultados parciales*.
- Construcción de la tabla de resultados parciales:
      - Inicialización de la tabla con los casos base que establece la ecuación del problema.
      - Establecimiento del orden de llenado de la tabla, de forma que se calculen en primer lugar los resultados parciales que requiern pasos posteriores.
      - Sustitución de las llamas recursivas del algoritmo por consultas a la tabla.

** Esquema General
- pag 131, no hay esquema general, hay ejemplos con fibonacci
  
#+BEGIN_EXAMPLE
fun FibDin(n:entero): entero
    var
        i,suma: entero
        t: tabla[0..n] de entero
    fvar
    si n <= 1 entonces
        dev 1
    sino
        t[0] <- 1
        t[1] <- 1
        para i <- 2 hasta n hacer
            t[i] <- t[i-1] + t[i-2]
        fpara
        dev t[n]
    fsi
ffun
#+END_EXAMPLE

Reduciendo la complejidad espacial a $O(1)$.

#+BEGIN_EXAMPLE
fun FibDin2(n: entero): entero
    var
        i,suma,f,g: entero
    fvar
    si n <= 1 entonces
        dev 1
    sino
        f <- 1
        g <- 1
        para i <- 2 hasta n hacer
            suma <- f+g
            g <- f
            f <- suma
        fpara
        dev suma
    fsi
ffun
#+END_EXAMPLE

** Devolución del cambio
- pag 135
- Encontrar el mínimo número de monedas posible para cierta cantidad C.
- N monedas diferentes

#+BEGIN_EXAMPLE
tipo Tabla=matriz[1..N, 0..C] de entero        // N filas por tipos de moneda
                                               // C columnas por cantidades
                                               // El índice de la columna representa
                                               //  La cantidad C
tipo Vector=matriz[0..N] de entero
fun DarCambio(C:entero, moneda:Vector): Tabla
    var
        t: Tabla
        i,j: entero
    fvar
    para i <- 1 hasta N hacer                         // Primera columna a 0's
        t[i,0] <- 0
    fpara
    para j <- 1 hasta C hacer
        para i <- 1 hasta N hacer
            si i=1 and moneda[i] > j entonces         // Si la menor moneda es mayor que
                                                      //  que la cantidad, No es resoluble.
                t[i,j] <- infty
            sino
                si i = 1 entonces
                    t[1,j] <- 1 + t[1, j - moneda[1]] // Si no encaja adquiere el
                                                      //  valor infty
                sino
                    si j < moneda[i] entonces         // La moneda es mayor que la cantidad
                        t[i,j] <- t[i-1,j]            // Valor file superior
                    sino
                        // menor entre un resultado parcial + 1 y la fila superior
                        // Resultado parcial es [IndiceMoneda, Columna - ValorMoneda]
                        t[i,j] <- min(t[i-1,j], t[i, j - moneda[i]] + 1)
                    fsi
                fsi
            fsi
        fpara
    fpara
    dev t
ffun
#+END_EXAMPLE

El resultado está en la última fila de cada columna.
Para la selección de monedas:

#+BEGIN_EXAMPLE
tipo Tabla=matriz[1..N,0..C] de entero
tipo Vector=matriz[0..N] de entero
fun SeleccionarMonedas(C:entero, moneda:Vector, t:Tabla, seleccion:Vector&)
    var
        i,j:entero
    fvar
    para i <- 0 hasta N hacer
        selección[i] <- 0        // Preparamos todo a 0
    fpara
    i <- N                       // De abajo a arriba
    j <- C
    mientras j > 0 hacer
        si i > 1 && t[i,j]=t[i-1,j] entonces
            i <- i-1                         // Subimos una fila
        sino
            seleccion[i] <- seleccion[i]+1   // añadimos una moneda a la combinación.
            j <- j - moneda[i]               // Restamos el valor al resto de la cantidad.
        fsi
    fmientras
ffun
#+END_EXAMPLE

Si el valor C fuera incompatible con nuestras monedas disponibles el resultado sería
una moneda del valor inferior, por eso hay que comprobar el resultado de la selección de monedas.

* Ramificación y Poda
** Planteamiento general

** Esquema general

** Mochila Entera
#+BEGIN_EXAMPLE
tipo TVectorB = matriz[1..n] de booleano
tipo TVectorR - matriz[1..n] de real
tipo TNodo = registro        // Solución parcial o final
    moch: TVectorB           // Elementos incluidos
    k: entero                // etapa de búsqueda, posición del objeto a considerar
    pesoT: real              // Peso objetos introducidos
    valorT: real             // valor objetos introducidos
    estOpt: real             // estimación Optimista,
                             //   determina posición en montículo
fregistro

/**
 * pesos: TVectorR: pesos de los objetos de mayor a menos valor.
 * valores: TVectorR: valor de los objetos de mayor a menor.
 * P: real: peso máximo soportable.
 * moch: out TVectorB: vector objetod añadidos de inicio con todo en falso de salida?
 * valor: real: valor de la solución óptima.
 * pesos, valores y moch tienen los objetos ordenados de más e menor valor.
 */
fun Mochila(pesos: TVectorR, valores: TVectorR,
            P:real, moch: out TVectorB, valor: out real)
    var
        monticulo: TMonticulo
        nodo, hijo: TNodo
        cota : real   // la cota sirve para podar ramas no óptimas
        estPes: real  // Sirve para actualizar la cota si alguna rama
                      //   en el peor de los casos puede dar una solución mejor
    fvar
    
    monituclo <- CreatMonticuloVacio()
    valor <-0
    
    // Construimos primer nodo
    //   no es solución es solo el inicio (empieza en k=1)
    nodo.moch <- moch
    nodo.k <- 0
    nodo.pesoT <- 0
    nodo.valorT <- 0
    nodo.estOpt <- EstimacionOpt(pesos, valores, P, nodo, pesoT, nodo.valorT)

    Insertar(nodo, monticulo)
    
    cota <- EstimacionPes(
        pesos, valores, P,nodo.k,
        nodo.PesoT, nodo.valorT
        )

    mientras !MonticuloVacio(monticulo) &&
             EstimacionOpt(Primero(monticulo)) >= cota hacer
             
        nodo <- OptenerCima(monticulo)  // la solución con mejor estimación
        
        hijo.k    <- nodo.k + 1      // el siguiente objeto
        hijo.moch <- nodo.moch       // copy?
        
        // cabe el objeto en la mochila?
        si nodo.pesoT + pesos[hijo.k] <= P entonces
            hijo.moch[hijo.k] <- cierto   // añadimos el nuevo objeto
            hijo.pesoT  <- nodo.pesoT + pesos[hijo.k]
            hijo.valorT <- nodo.valorT + valores[hijo.k]
            hijo.estOpt <- nodo.estOpt
            si hijo.k = n entonces
                // el último nodo es el nodo n
                si cota <= hijo.valorT entonces
                    // vemos si mejoramos la cota actual
                    //  Representa una solución óptima encontrada
                    moch  <- hijo.moch
                    valor <- hijo.valorT
                    cota  <- valor  // actualizamos cota
                fsi
            sino
                // la solución no está completa
                // añadimos una copia del hijo al montículo
                // (si la estOpt es alta se posicionará cerca de la cima)
                Insertar(hijo, monticulo) // insertamos copia
            fsi
        fsi

        // Estimación sin el objeto hijo en la mochila
        hijo.estOpt <- EstimacionOpt(
            pesos, valores, P, hijo.k /* se comprueba a partir de k+1 */,
            nodo.pesoT, nodo.valorT
            )

        si hijo.estOpt >= cota entonces
            // solución sin el objeto k que mejora la cota
            hijo.moch[hijo.k] <- falso
            hijo.pesoT  <- nodo.pesoT
            hijo.valorT <- nodo.valorT
            
            si hijo.k = n entonces
                si cota <= hijo.valorT entonces
                    // guardamos la solución final que mejora la cota
                    //   actualizamos la cota porque la mejora
                    moch  <- hijo.moch
                    valor <- hijo.valorT
                    cota  <- valor
                fsi
            sino
                // solución no completa
                //  insertamos una copia de hijo
                Insertar(hijo, monticulo)
                estPes <- EstimacionPes(pesos, valores, P, hijo.k,
                                        hijo.PesoT, hijo.valorT)

                // comprobamos si la estimación pesimista sin el objeto
                //  mejora la cota, si es así actualizamos la cota
                si cota < estPes entonces
                    cota <- estPes
                fsi
            fsi
        fsi
    fmientras
ffun

fun EstimacionOpt(pesos, valores : TVectorT, P: real,
                  k: entero, pesoT: real, valorT: real): real
    var
        capacidad, estimacion : real
        i : entero
    fvar
    
    capacidad <- P - pesoT  // Peso máximo - peso actual
    estimacion <- valorT

    i <- k + 1 // siguiente objeto
    mientras i <= n && capacidad >= 0 hacer
        si pesos[i] <= capacidad entonces
            estimacion <- estimacion + valor[i]  // más valor
            capacidad <- capacidad - pesos[i]    // pero menos capacidad
        sino
            // se pone una parte de este objeto
            // que no es real es la estimación optimista
            estimacion <- estimacion + (capacidad / pesos[i]) * valor[i]
            capacidad <- 0
        fsi
        i <- i + 1
    fmientras
    dev estimacion
ffun

fun EstimacionPes(pesos, valores: TVectorR, P:real,
                  k:entero, pesoT: real, valorT: real) : real
    var
        capacidad, cota: real
        i: entero
    fvar
    
    capacidad <- P - pesoT
    cota <- valorT
    i <- k + 1      // siguiente objeto
    mientras i <= n && capacidad >= 0 hacer
        si pesos[i] <= capacidad entonces
            cota <- cota + valor[i]
            capacidad <- capacidad - pesos[i]
        fsi
        // no se introducen objetos fraccionados
        i <- i+1
    fmientras
    
    dev cota
ffun                  

#+END_EXAMPLE


