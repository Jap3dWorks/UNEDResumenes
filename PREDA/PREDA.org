#+title: PREDA

* Estructuras de datos
** Grafos
- $G=<N,A>$ grafo de $N$ vértices y $A$ aristas.
  
# TODO
*** Matriz de adyacencia
|   | 1 | 2 | 3 |
| 1 | - | 1 | - |
| 2 | - | - | 1 |
| 3 | 1 | - | - |

- Si es no dirigido la matriz es simétrica

*** Listas de adyacencia
- Una lista por cada nodo
- Cada lista de cada nodo $i$ tiene una secuencia de nodos adyacientes a $i$.

*** Funciones de manipulación de grafos
- *fun Creargrafo(): grafo*
      - Crea un grafo vacío.
- *fun AñadirArista(u,v:vértice; p:peso; g:grafo): grafo*
      - Añade una arista entre los vértices $u$ $v$ y peso $p$.
- *fun AñadirVertice(v:vértice;  g:grafo): grafo*
      - Añade un vértice al grafo.
- *fun BorrarArista(v1,v2:vértice; g:grafo): grafo*
      - Elimina la arista.
- *fun BorrarVertice(v:vértice, g:grafo): grafo*
      - Borra el vértice v y todas las aristas que partan o lleguen a él.
- *fun Adyacente?(v1,v2:vértice; g:grafo): booleano*
      - true si v1 y v2 son adyacentes.
- *fun Adyacentes(v:vértice; g:grafo): lista*
      - Lista con vértices adyacentes a v.
- *fun Etiqueta(v1,v2:vértice; g:grafo): etiqueta*
      - Peso asociado o etiqueta asociada a la arista.

Costes de manipulación de Grafos

|               | Matriz de adyacencia   | Lista de adyacencia |
| CrearGrafo    | O(1)                   | O(1)                |
| AñadirArista  | O(1)                   | O(1)                |
| AñadirVertice | O(n) (sin relocalizar) | O(1)                |
| BorrarArista  | O(1)                   | O(n)                |
| BorrarVertice | O(n)                   | O(n+a)              |
| Adyacente?    | O(1)                   | O(n)                |
| Adyacentes    | O(n)                   | O(1)                |
| Etiqueta      | O(1)                   | O(n)                |

*** Recorrido en profundidad

#+BEGIN_EXAMPLE
fun RecProfundidadRecursivo(v:nodo; visitado:Vector)
    var
        w: nodo
    fvar
    visitado[v] <- true
    para cada w adyacente a v hacer
        si !visitado[w] entonces
            RecProfundidadRecursivo(w,visitado)
        fsi
    fpara
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
tipo Vector=matriz[0..n] de booleano
fun Recorridorofundidad(G=<N,A>: grafo)
    var
        visitado:Vector
        v:nodo
    fvar
    para cada v in N hacer
        visitado <- falso
    fpara
    para cada v in N hacer
        si !visitado[v] entonces
            RecProfundidadRecursivo(v, visitado)
        fsi
    fpara
ffun
#+END_EXAMPLE

Versión Iterativa del recorrido en profundidad

#+BEGIN_EXAMPLE
fun RecProfundidadIterativo(v:nodo; visitado:Vector)
    var
        u,w: nodo
        P: TPila
    fvar
    P <- PilaVacía()
    visitado[v] <- cierto
    Apilar(v,P)
    mientras not Vacía(P) hacer
        u=Cima(P)
        Desapilar(P)
        para cada w adyacente a u hacer
            si not visitado[w] entonces
                visitado[w] <- true
                Apilar(w,P)
            fsi
        fpara
    fmientras
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
tipo Vector=matriz[0..n] de booleano
fun RecorridoProfundidad(G=<N,A>: grafo)
    var
        visitado: Vector
        v: nodo
    fvar
    para cada v in N hacer
        visitado[v] <- false
    fpara
    para cada v in N hacer
        si not visitado[v] entonces
            RecProfundidadIterativo(v, visitado)
        fsi
    fpara
ffun
#+END_EXAMPLE

*** Recorrido en amplitud

#+BEGIN_EXAMPLE]
fun RecAnchura(v:nodo; visitado:Vector)
    var
        u,w:nodo
        Q:TCola
    fvar
    Q <- ColaVacía()
    visitado[v] <- true
    Encolar(v,Q)
    mientras not Vacía(Q) hacer
        u <- Primero(Q)
        Desencolar(u,Q)
        para cada w adyacente a u hacer
            si !visitado[w] entonces
                visitado[w] <- true
                Encolar(w,Q)
            fsi
        fpara
    fmientras
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
tipo Vector=matriz[0..n] de booleano
fun RecorridoAnchura(G=<N,A>: grafo)
    var
        visitado: Vector
        v: nodo
    fvar
    para cada v in N hacer
        visitado[v] <- false
    fpara
    para cada v in N hacer
        si !visitado[v] entonces
            RecAnchura(v, visitado)
        fsi
    fpara
ffun
#+END_EXAMPLE

*** Árbol de recubrimiento
- Aristas usadas en un recorrido en anchura o profundidad
- $(n-1)$ aristas.

*** Punto de articulación
- $u$ es un punto de articulación si al eliminar $u$ y todas sus aristas el grafo deja de ser conexo.
- *Grafo biconexo*, sin puntos de articulación.
- *Conectividad K*, si eliminar *K* nodos cualesquiera no desconecta el grafo.

  # TODO

*** Ordenación topológica de un grafo dirigido acícliclo (GDA)
- gda, existencia de arco <u,v> indica que el nodo u precede al nodo v en una ordenación lineal.

Algoritmo de Khan para calcular un gda

#+BEGIN_EXAMPLE
tipo Vector=matriz[identNodo_1..identNodo_n] de natural
fun OrdenTopologicoKahn(G=<N,A>: grafo): Vector
    var
        u,v:nodo
        Q:TCola
        orden: Vector
    fvar
    Q <- {u in N : GradoEntrante(A,u)=0}     // Nodos sin conexiones entrantes
    i <-1
    mientras !Vacia(Q) hacer
        u <- Primero(Q)
        Desencolar(u,Q)
        orden[u] <- i
        i <- i+1
        para cada (u,v) in A hacer            // Para cada conexión saliente de u
            A <- A \ {(u,v)}
            si GradoEntrante(A,v)=0 entonces  // Nodos sin conexiónes entrantes
                Encolar(v,Q)
            fsi
        fpara
    fmientras
    dev orden
ffun
#+END_EXAMPLE

*** Camino más corto desde la raiz a cualquier otro nodo
- Coincide con el árbol de recubrimiento en anchura (ARA) desde la raiz.

** Montículo
- Caso especial de árbol binario implementado sobre vectores
- Es un árbol balanceado y completo
- Cada nodo contiene un valor mayor o igual que el de sus hijos (mónticulo máximos)
      - O tambien montículo de mínimos.
- En la cima está el nodo raiz $T[1]$
- Nodo $T[i]$
      - Hijo izquierdo $T[2i]$
      - Hijo derecho $T[2i+1]$
      - Padre $T[i\ div\ 2]$ (división entera)

*** Implementación y operaciones
#+BEGIN_EXAMPLE
registro monticulo
T: vector[1..n] de entero;
c: natural;                  // Elementos en el montículo
MAX: natural;                // Máximo número de elementos
fregistro
#+END_EXAMPLE

#+BEGIN_EXAMPLE
fun CreaMonticuloVacio(m: monticulo)
    m.T <- null
    m.c <- 0
    m.MAX <- n
ffun    
#+END_EXAMPLE

#+BEGIN_EXAMPLE
fun MonticuloVacio?(m: monticulo): boleano
    si (m.c=0) entonces dev true sino dev false fsi
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
fun flotar(T:vector, i:natural)
    mientras (i>1) && (T[i div 2] < T[i]) hacer  // padre menor que el nodo i
        intercambiar(T[i], T[i div 2])
        i <- i div 2
    fmientras
ffun
#+END_EXAMPLE

#+begin_example
fun Hundir(m:monticulo, i:natural)
    var
        hi,hd,p:natural
    fvar
    repetir
        hi <- 2*i
        hd <- 2*i + 1
        p <- i
        si (hd <= m.c) && (m.T[hd] > m.T[i]) entonces
            i <- hd
        fsi
        si (hi <= m.c) && (m.T[hi] > m.T[i]) entonces
            i <- hi
        fsi
        intercambiar(m.T[p],m.T[i])      // Se intercambia con el mayor de los dos hijos
    hasta p=i
ffun
#+end_example

#+begin_example
fun Insertar(e:elemento; m:monticulo): monticulo
    si m.c = m.MAX entonces
        error(MonticuloLleno)
    sino
        m.c <- m.c + 1
        m.T[m.c] <- e          // Se inserta al final del montículo
        Flotar(m.T, m.c)
    fsi
ffun
#+end_example

#+begin_example
fun Primero(m: monticulo): elemento
    si m.c=0 entonces dev error
    sino
        dev m.T[1]
    fsi
ffun
#+end_example

#+begin_example
fun ObtenerCima(m:monticulo): elemento
    var
        e:elemento
    fvar
    si m.c != 0 entonces
        e <- m.T[1]
        m.T[1]<-m.T[m.c]
        m.c <- m.c - 1
        Hundir(m.T,1)
        dev e
    fsi
ffun
#+end_example

#+begin_example
/**
 * Convierte el montículo el vector T
*/
fun CreaMonticuloLineal(T:vector[1..n]): monticulo
    var
        m: monticulo
    fvar
    m <- CreaMonticuloVacio()
    m.T <- T
    m.c <- n    
    para i <- n/2 hasta 1 paso -1 hacer
        hundir(T,i);
    fpara

    dev m
ffun
#+end_example

*** Algoritmo Heapsort

#+begin_example
fun Heapsort(T:vector[1..n]): vector[1..n]
    var
        e:entero
        m:monticulo
        S:vector[1..n]
    fvar
    M <- CreaMonticuloLineal(T);
    para i <- 1 hasta n hacer
        e <- ObtenerCima(M)
        S[i] <- e
    fpara
    dev S
ffun
#+end_example

** Tablas de dispersión (Hash)
# TODO




* Voraz
** Planteamiento general
- Para problemas de optimización donde la solución se puede construir paso a paso sin necesidad de reconsiderar decisiones.
- Características del esquema.
      - Resolución de un problema de forma óptima
      - *Conjunto inicial de candidatos*, elementos que hay que planificar.
      - *Conjunto de candidatos Seleccionados*, elementos que ya han sido considerados y seleccionados.
      - *Conjunto de candidatos Reachazados*
      - *Función Solución*, determina si el conjunto de candidatos es na solución óptima.
      - *Función factible*, determina si la solución es competable o factible.
      - *Función Selección*, Escoge al candidato más prometedor todavia no seleccionado.

** Esquema general
#+BEGIN_EXAMPLE
fun Voraz(c: ConjuntoCandidatos&): ConjuntoCandidatos
    sol <- {}                                // Conjunto de candidatos seleccionados
    mientras c != {} && !Solución(sol) hacer
        x <- seleccionar(c)                  // Selecciona el mejor candidato
        c <- c \ {x}
        si factible(sol union {x}) entonces  // La union de sol y x es factible
            sol <- sol union {x}
        fsi
    fmientras
    si solucion(sol) entonces                // Comprobamos si es una solución
        dev sol
    sino
        imprimir("No hay solución")
    fsi
ffun
#+END_EXAMPLE

** Árbol de recubrimiento mínimo: algoritmo de Prim
*** Planteamiento general
#+BEGIN_EXAMPLE
/*
 * @param G <N,A>: grafo de N vértices con A aristas
*/
fun Prim(G=<N,A>:Grafo): conjunto de aristas
    AR <- {}                                // árbol de recubrimiento
    NA <- {un nodo cualquiera de N}         // vértices del árbol de recubrimiento
    miemtras NA != N hacer
        Buscar {u,v} de coste mínimo tal que u in NA u v in N \ NA
        AR <- AR union {(u,v)}
        NA <- NA union {u}
    fmientras
    dev AR
ffun
#+END_EXAMPLE

*** Descripción detallada
#+BEGIN_EXAMPLE
tipo VectorNat=matriz[0..n] de natural
tipo VectorEnt=matriz[0..n] de entero
fun Prim(G=<N,A>: grafo): conjunto de aristas
    var
        nodoMinimo: VectorNat
        costeMinimo: VectorEnt
        AR: conjunto de aristas
    fvar
    AR <- {}
    costeMínimo[1] <- -1                        // Coste del primer vertice consigo mismo
    para i <- 2 hasta n hacer
        nodoMinimo[i] <- 1                      // Iniciamos con el primer nodo
        costeMinimo[i] <- Distancia(1,i)        // Distancia con el primer nodo
    fpara
    para i <- 1 hasta n-1 hacer
        min <- infty
        para j <- 2 hasta n hacer
            // Nodos con coste -1 ya están dentro del AR
            //  cogemos el nodo de menor coste con cualquiera de los
            //  nodos que ya están en el AR
            si 0 <= costeMinimo[j] && costeMinimo[j] < min entonces
                min <- costeMinimo[j]
                nodo <- j
            fsi
        fpara
        AR <- AR union {(nodoMinimo[nodo], nodo)}    // añadimos el nodo de menor coste
        costeMinimo[nodo] <- -1
        para j <- 2 hasta n hacer
            // Actualizamos la lista de costeMinimo y nodoMinimo con las distancias
            //  De los nodos externos al AR con el nuevo nodo
            si Distancia(j,nodo) < costeMinimo[j] && costeMinimo[j] != -1 entonces
                costeMinimo[j] <- Distancia(j,nodo)
                nodoMinimo[j] <- nodo
            fsi
        fpara
    fpara
    dev AR
ffun
#+END_EXAMPLE

** Árbol recubrimiento mínimo: Kruskal
#+BEGIN_EXAMPLE
fun Kruskal(G=<N,A>:grafo): conjunto de aristas
    var
        AR: conjunto de aristas
    fvar
    Ordenar(A)                               // Ordenar las aristas en peso crecientes.
                                             //  un montículo es ideal.
    n <- número nodos de N
    AR <- {}
    Iniciar n conjuntos uno con cada nodo de N  // [{a}, {b}, ..., {u}, {v}]
    mientras AR no tenga n-1 aristas hacer   // Con n-1 aristas todos los nodos pueden
                                             //  estar conectados
        pop(A,u,v)                           // Arista (u,v) aún no añadida ni descartada
        comU <- buscarComponenteConvexa(u)   // Buscamos el conjunto que contiene a u
                                             //  Originalmente es el conjunto {u}
        comV <- buscarComponenteConvexa(v)   // Buscamos el conjunto que contiene a v
                                             //  originalmente es el conjunto {v}
        si comU != comV entonces             // Si son componentes convexas diferentes
                                             //  aún no hemos añadido esta arista a AR
            fusionar(comU, comV)             // Fusionamos las dos componentes convexas
                                             //  Así sabemos que estos dos nodos ya
                                             //  están conectados en el AR
            AR <- AR union {(u,v)}
        fsi
    fmientras
    dev AR
ffun
#+END_EXAMPLE

* Divide y vencerás
** Planteamiento General
- Descomposición de un problema en subproblemas de su mismo tipo.
- Resolución recursiva de los subproblemas.
- Combinación si procede de las soluciones del problema.

** Esquema General
#+BEGIN_EXAMPLE
fun DyV(problema)
    si trivial(problema) entonces
        dev solución-trivial
    sino hacer
        {p1,p2,...,pk} <- descomponer(problema)
        para i in (1..k) hacer
            si <- DyV(pi)
        fpara
    fsi
    dev combinar(s1,s3,...,sk)
ffun
#+END_EXAMPLE

** Búsqueda Binaria
#+BEGIN_EXAMPLE
fun bbinaria(i,j:entero; v:vector[1..N] de entero; x:entero): booleano
    // Primer índice del vector 1 para simplificar
    var
        m:entero
    fvar
    si i=j entonces                  // los dos índices han convergido al mismo valor
        si v[i]=x entonces
            dev verdadero
        sino
            dev falso
        fsi
    sino
        m <- (i+j) div 2
        si x <= v[m] entonces
            bbinaria(i,m,v,x)
        sino
            bbinaria(m+1,j,v,x)
        fsi
    fsi
ffun
#+END_EXAMPLE

** Ordenación rápida (Quicksort)                                     :ATTACH:
:PROPERTIES:
:ID:       b26bd1bd-be2d-4542-bb20-c2908cedde80
:END:
- pag 124, ordena de menor a mayor.
- Menores que el pivote a la izquierda del pivote, mayores a la derecha.

#+BEGIN_EXAMPLE
fun Pivotar(T:vector[i..j] de entero; pivote:natural)
    var
        p,k,l:entero
    fvar
    p <- T[i]                                  // Primer valor de T
    k <- i                                     // Primer índice de T
    l <- j+1                                   // último índice de T + 1
    repetir k <- k+1 hasta T[k] > p or k >= j  // k+1 hasta que T[k] mayor que
                                               //  el primer  valor de T o k al final de T
    repetir l <- l-1 hasta T[l] <= p           // l-1 hasta que T[l] menor igual 
                                               //  que el primer valor de T
    mientras k < l hacer                       // hasta que k y l se crucen
        intercambiar(T,k,l)                    // Se intercambian los valores
        repetir k <- k + 1 hasta T[k] > p      // subir índice izquierdo hasta que T[k]
                                               //  mayor que el primer valor de T
        repetir l <- l - 1 hasta T[l] <= p     // Bajar índice derecho hasta que T[l]
                                               //  menos o igual que el primer valor de T
    fmientras
    intercambiar(T,i,l)
    pivote <- l
ffun
#+END_EXAMPLE

[[attachment:clipboard-20260129T110042.png]]
  
#+BEGIN_EXAMPLE
fun Quicksort(T[i..j])
    var
        l:natural
    fvar
    l <- i                                     // Se suele elegir el primer elemento
                                               //  Como pivote.
    si trivial(i-j) entonces Insertar(T[i..j]) // Trivial si son tan solo dos elementos
    sino
        Pivotar(T[i..j],l)                     // Pivotar actualiza el valor de l
                                               // Desde el pivote dividimos el vector
                                               //  El pivote no se incluye en el
                                               //  proceso recursivo
        Quicksort(T[i..l-1])
        Quicksort(T[l+1..j])
    fsi
ffun
#+END_EXAMPLE

** Merge Sort
# TODO


** Cálculo del elemento mayoritario en un vector                     :ATTACH:
:PROPERTIES:
:ID:       46f2d130-5688-4af6-8c45-9f8dbd7fe57c
:END:
- Buscar si un elemento aparece (n/2) + 1 veces en el vector
- Importante diferenciar que mayoritario no es el que aparece más veces.
  Sino estrictamente el que aparce almenos (n/2) + 1

#+BEGIN_EXAMPLE  
fun Mayoritario(i,j:natural; v:vector[1..n] de natural): entero
    var
        m: natural
        s1,s2: entero
    fvar
    si i=j entonces                     // Caso trivial
        dev v[i]
    sino
        m <- (i+j) / 2                  // Punto medio, división entera
        s1 <- Mayoritario(i,m,v)        // La mitad menor (caso de n impar)
        s2 <- Mayoritario(m+1,j,v)      // La mitad mayor
        dev Combinar(s1,s2,i,j,v)
     fsi
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
fun Combinar(a,b:entero; i,j:natural; v:vector[1..n] de natural): entero
    si a=-1 and b=-1 entonces dev -1 fsi
    si a=-1 and b!=-1 entonces dev ComprobarMayoritario(i,j,b,v) fsi
    si a!=-1 and b!=-1 entonces dev ComprobarMayoritario(i,j,a,v) fsi
        si ComprobarMayoritario(i,j,a,v)=a entonces
            dev a
        sino si ComprobarMayoritario(i,j,b,v)=b entonces
            dev b
        sino
            dev -1
        fsi
    fsi
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
fun ComprobarMayoritario(i,j:natural; x:entero; v:vector[1..n] de natural): entenro
    var
        c:natural
    fvar
    c <- 0
    para k <- i hasta j hacer
        si v[k]==x entonces c <- c+1 fsi
    fpara
    si c > (j-i+1)/2 entonces
        dev x
    sino
        dev -1
    fsi
ffun
#+END_EXAMPLE

Ejemplo de una traza

[[attachment:clipboard-20260129T132356.png]]

* Vuelta atrás
** Planteamiento general
- búsqueda exaustiva de las posibles soluciones.
- Recorrido en *Profundidad* del grafo inplícito de un problema.
      - Grafo sin ciclos

** Esquema general
- /IniciarExploraciónNivel()/, Opciones posibles para extender la solución k-prometedora.
- /OpcionesPendientes()/, Compruena que quedan opciones por explorar en el nivel.
- /SoluciónCompleta()/, Comprueba si se ha encontrado una solución.
- /ProcesarSolución()/, Hacer las acciones necesarias con la solución.
  Por ejemplo *dev* o imprimir el resultado.
- /Completable()/, comprueba que la solución k-prometedora se puede extender.

#+BEGIN_EXAMPLE
/*
 * @param v: secuencia k-prometedora
 * @param k: nivel
 */
fun VueltaAtras(v: Secuencia; k: entero)
    IniciarExploraciónNivel(k)
    mientras OpcionesPendientes(k) hacer
        extender v con siguiente opción
        si SoluciónCompleta(v) entonces
            ProcesarSolución(v)
        sino
            si Competable(v) entonces
                VueltaAtras(v, k+1)
            fsi
        fsi
    fmientras
ffun
#+END_EXAMPLE

Si solo se busca una solución.

#+BEGIN_EXAMPLE
fun VueltaAtras(v: Secuencia; k: entero; encontrado: booleano)
    IniciarExploraciónNivel(k)
    mientras OpcionesPendientes(k) && !encontrado hacer
        extender v con siguiente opción
        si SoluciónCompleta(v) entonces
            ProcesarSolución(v)
            encontrado <- true
        sino
            si Competable(v) entonces
                VueltaAtras(v, k+1, encontrado)
            fsi
        fsi
    fmientras
ffun
#+END_EXAMPLE

** Problema de la reina
Se quiere situar una reina en cada columna de un tablero de ajedrez de forma que ninguna de ellas pueda eliminar a ninguna otra reina.

La solución mostrada busca todas las soluciones posibles.
#+BEGIN_EXAMPLE
/*
 * @param s: Almacena la solución temporal.
 *  En cada celda (columna) se almacena el número de la fila donde se posiciona la reina.
 * @param n: tamaño del tablero
 */
fun Reinas(s:Vector[1..n] de entero; n,k:entero)
    s[k] <- 0
    mientras s[k] <= n hacer
        s[k] <- s[k] + 1                    // Se va probando desde la primera
                                            //  hasta la última fila.
        si Completable(s,k) entonces
            si k=n entonces
                escribir(s)                 // Muestra la solución o
                                            //  la escribe en un archivo
            sino
                Reinas(s,n,k+1)
            fsi
        fsi
    fmientras
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
/*
 * Comprueba que no hayan reinas en la misma fila ni en la misma diagonal.
 */
fun Completable(s:Vector[1..n] de entero; k: entero):booleano
    var
        i:entero
    fvar
    para i <- 1 hasta k-1 hacer
        // Es interesante ver la forma de comprobar la diagonal
        si s[i]==s[k] || (abs(s[i]-s[k])==abs(i-k)) entonces
            dev falso
        fsi
    fpara
    dev true
ffun
#+END_EXAMPLE

** Coloreado de grafos
Se desea asignar un color a cada vértice de un grado conexo, de forma que no hayan vertices adyacentes con el mismo color.

Se sabe que se necesitan 4 colores como mínimo para cualquier grafo.

#+BEGIN_EXAMPLE
// Grafo[i,j]==1 si i,j están conectados.
tipo Grafo=matriz[i..N,i..N] de entero
tipo Vector=matriz[i..N] de entero

/*
 * @param v: Vector k-prometedor, posición i representa al vector i
 * @param m: Número de colores
 * @param k: Nivel de la solución
*/
fun ColoreaGrafo(g:Grafo; m:entero; k:entero; v:Vector; exito: booleano&)
    v[k] <- 0
    exito <- false
    mientras v[k] < m && !exito hacer
        v[k] <- v[k] + 1
        si Competable(g,v,k) entonces
            si k==N entonces
                Procesar(v)
                exito <- true
            sino
                ColoreaGrafo(g,m,k+1,v,exito)
            fsi
        fsi
    fmientras
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
/*
 * Comprueba si algún vértice conectado a k tiene el mismo color que el vértice k.
*/
fun Completable(g:Grafo, v:Vector, k:entero): booleano
    i:entero
    para i <- 1 hasta k-1 hacer
        si g[k,i]==1 && v[k]==v[i] entonces
            dev false
        fsi
    fpara
    dev true
ffun
#+END_EXAMPLE

* Programación dinámica
** Planteamiento general
- Establecimiento de las ecuaciones que representan el problema.
- Identificación de los *resultados parciales*.
- Construcción de la tabla de resultados parciales:
      - Inicialización de la tabla con los casos base que establece la ecuación del problema.
      - Establecimiento del orden de llenado de la tabla, de forma que se calculen en primer lugar los resultados parciales que requiern pasos posteriores.
      - Sustitución de las llamas recursivas del algoritmo por consultas a la tabla.

** Esquema General
- pag 131, no hay esquema general, hay ejemplos con fibonacci
  
#+BEGIN_EXAMPLE
fun FibDin(n:entero): entero
    var
        i,suma: entero
        t: tabla[0..n] de entero
    fvar
    si n <= 1 entonces
        dev 1
    sino
        t[0] <- 1
        t[1] <- 1
        para i <- 2 hasta n hacer
            t[i] <- t[i-1] + t[i-2]
        fpara
        dev t[n]
    fsi
ffun
#+END_EXAMPLE

Reduciendo la complejidad espacial a $O(1)$.

#+BEGIN_EXAMPLE
fun FibDin2(n: entero): entero
    var
        i,suma,f,g: entero
    fvar
    si n <= 1 entonces
        dev 1
    sino
        f <- 1
        g <- 1
        para i <- 2 hasta n hacer
            suma <- f+g
            g <- f
            f <- suma
        fpara
        dev suma
    fsi
ffun
#+END_EXAMPLE

** Devolución del cambio
- pag 135
- Encontrar el mínimo número de monedas posible para cierta cantidad C.
- N monedas diferentes

#+BEGIN_EXAMPLE
tipo Tabla=matriz[1..N, 0..C] de entero        // N filas por tipos de moneda
                                               // C columnas por cantidades
                                               // El índice de la columna representa
                                               //  La cantidad C
tipo Vector=matriz[0..N] de entero
fun DarCambio(C:entero, moneda:Vector): Tabla
    var
        t: Tabla
        i,j: entero
    fvar
    para i <- 1 hasta N hacer                         // Primera columna a 0's
        t[i,0] <- 0
    fpara
    para j <- 1 hasta C hacer
        para i <- 1 hasta N hacer
            si i=1 and moneda[i] > j entonces         // Si la menor moneda es mayor que
                                                      //  que la cantidad, No es resoluble.
                t[i,j] <- infty
            sino
                si i = 1 entonces
                    t[1,j] <- 1 + t[1, j - moneda[1]] // Si no encaja adquiere el
                                                      //  valor infty
                sino
                    si j < moneda[i] entonces         // La moneda es mayor que la cantidad
                        t[i,j] <- t[i-1,j]            // Valor file superior
                    sino
                        // menor entre un resultado parcial + 1 y la fila superior
                        // Resultado parcial es [IndiceMoneda, Columna - ValorMoneda]
                        t[i,j] <- min(t[i-1,j], t[i, j - moneda[i]] + 1)
                    fsi
                fsi
            fsi
        fpara
    fpara
    dev t
ffun
#+END_EXAMPLE

El resultado está en la última fila de cada columna.
Para la selección de monedas:

#+BEGIN_EXAMPLE
tipo Tabla=matriz[1..N,0..C] de entero
tipo Vector=matriz[0..N] de entero
fun SeleccionarMonedas(C:entero, moneda:Vector, t:Tabla, seleccion:Vector&)
    var
        i,j:entero
    fvar
    para i <- 0 hasta N hacer
        selección[i] <- 0        // Preparamos todo a 0
    fpara
    i <- N                       // De abajo a arriba
    j <- C
    mientras j > 0 hacer
        si i > 1 && t[i,j]=t[i-1,j] entonces
            i <- i-1                         // Subimos una fila
        sino
            seleccion[i] <- seleccion[i]+1   // añadimos una moneda a la combinación.
            j <- j - moneda[i]               // Restamos el valor al resto de la cantidad.
        fsi
    fmientras
ffun
#+END_EXAMPLE

Si el valor C fuera incompatible con nuestras monedas disponibles el resultado sería
una moneda del valor inferior, por eso hay que comprobar el resultado de la selección de monedas.

* Ramificación y Poda
** Planteamiento general
# TODO

** Esquema general
Problema de minimización

#+begin_example
fun RamificacionYPoda(nodoRaiz, mejorSolución:TNodo; cora:real)
    monticulo = CrearMonticuloVacio()
    cota = EstimacionPes(nodoRaiz)
    Insertar(nodoRaiz, monticulo)
    mientras !MonticuloVacio?(monticulo) && EstimaciónOpt(Primero(monticulo)) <= cota hacer
        nodo <- ObtenerCima(monticulo)
        para cada hijo extensión válida de nodo hacer
            si solución(hijo) entonces
                si coste(hijo) <= cota entonces
                    cota <- coste(hijo)
                    mejorSolucion <- hijo
                fsi
            sino
                si EstimacionOpt(hijo) <= cota entonces
                    Insertar(hijo, monticulo)
                    si EstimacionPes(hijo) < cota entonces
                        cota <- EstimacionPes(hijo)
                    fsi
                fsi
            fsi
        fpara
    fmientras
ffun
#+end_example

** Mochila Entera
#+BEGIN_EXAMPLE
tipo TVectorB = matriz[1..n] de booleano
tipo TVectorR = matriz[1..n] de real
tipo TNodo = registro        // Solución parcial o final
    moch: TVectorB           // Elementos incluidos
    k: entero                // etapa de búsqueda, posición del objeto a considerar
    pesoT: real              // Peso objetos introducidos
    valorT: real             // valor objetos introducidos
    estOpt: real             // estimación Optimista,
                             //   determina posición en montículo
fregistro

/**
 * pesos: TVectorR: pesos de los objetos de mayor a menos valor.
 * valores: TVectorR: valor de los objetos de mayor a menor.
 * P: real: peso máximo soportable.
 * moch: out TVectorB: vector objetod añadidos de inicio con todo en falso de salida?
 * valor: real: valor de la solución óptima.
 * pesos, valores y moch tienen los objetos ordenados de más e menor valor.
 */
fun Mochila(pesos: TVectorR, valores: TVectorR,
            P:real, moch: out TVectorB, valor: out real)
    var
        monticulo: TMonticulo
        nodo, hijo: TNodo
        cota : real   // la cota sirve para podar ramas no óptimas
        estPes: real  // Sirve para actualizar la cota si alguna rama
                      //   en el peor de los casos puede dar una solución mejor
    fvar
    
    monituclo <- CreatMonticuloVacio()
    valor <-0
    
    // Construimos primer nodo
    //   no es solución es solo el inicio (empieza en k=1)
    nodo.moch <- moch
    nodo.k <- 0
    nodo.pesoT <- 0
    nodo.valorT <- 0
    nodo.estOpt <- EstimacionOpt(pesos, valores, P, nodo, pesoT, nodo.valorT)

    Insertar(nodo, monticulo)
    
    cota <- EstimacionPes(
        pesos, valores, P,nodo.k,
        nodo.PesoT, nodo.valorT
        )

    mientras !MonticuloVacio(monticulo) &&
             EstimacionOpt(Primero(monticulo)) >= cota hacer
             
        nodo <- OptenerCima(monticulo)  // la solución con mejor estimación
        
        hijo.k    <- nodo.k + 1      // el siguiente objeto
        hijo.moch <- nodo.moch       // copy?
        
        // cabe el objeto en la mochila?
        si nodo.pesoT + pesos[hijo.k] <= P entonces
            hijo.moch[hijo.k] <- cierto   // añadimos el nuevo objeto
            hijo.pesoT  <- nodo.pesoT + pesos[hijo.k]
            hijo.valorT <- nodo.valorT + valores[hijo.k]
            hijo.estOpt <- nodo.estOpt
            si hijo.k = n entonces
                // el último nodo es el nodo n
                si cota <= hijo.valorT entonces
                    // vemos si mejoramos la cota actual
                    //  Representa una solución óptima encontrada
                    moch  <- hijo.moch
                    valor <- hijo.valorT
                    cota  <- valor  // actualizamos cota
                fsi
            sino
                // la solución no está completa
                // añadimos una copia del hijo al montículo
                // (si la estOpt es alta se posicionará cerca de la cima)
                Insertar(hijo, monticulo) // insertamos copia
            fsi
        fsi

        // Estimación sin el objeto hijo en la mochila
        hijo.estOpt <- EstimacionOpt(
            pesos, valores, P, hijo.k /* se comprueba a partir de k+1 */,
            nodo.pesoT, nodo.valorT
            )

        si hijo.estOpt >= cota entonces
            // solución sin el objeto k que mejora la cota
            hijo.moch[hijo.k] <- falso
            hijo.pesoT  <- nodo.pesoT
            hijo.valorT <- nodo.valorT
            
            si hijo.k = n entonces
                si cota <= hijo.valorT entonces
                    // guardamos la solución final que mejora la cota
                    //   actualizamos la cota porque la mejora
                    moch  <- hijo.moch
                    valor <- hijo.valorT
                    cota  <- valor
                fsi
            sino
                // solución no completa
                //  insertamos una copia de hijo
                Insertar(hijo, monticulo)
                estPes <- EstimacionPes(pesos, valores, P, hijo.k,
                                        hijo.PesoT, hijo.valorT)

                // comprobamos si la estimación pesimista sin el objeto
                //  mejora la cota, si es así actualizamos la cota
                si cota < estPes entonces
                    cota <- estPes
                fsi
            fsi
        fsi
    fmientras
ffun

fun EstimacionOpt(pesos, valores : TVectorT, P: real,
                  k: entero, pesoT: real, valorT: real): real
    var
        capacidad, estimacion : real
        i : entero
    fvar
    
    capacidad <- P - pesoT  // Peso máximo - peso actual
    estimacion <- valorT

    i <- k + 1 // siguiente objeto
    mientras i <= n && capacidad >= 0 hacer
        si pesos[i] <= capacidad entonces
            estimacion <- estimacion + valor[i]  // más valor
            capacidad <- capacidad - pesos[i]    // pero menos capacidad
        sino
            // se pone una parte de este objeto
            // que no es real es la estimación optimista
            estimacion <- estimacion + (capacidad / pesos[i]) * valor[i]
            capacidad <- 0
        fsi
        i <- i + 1
    fmientras
    dev estimacion
ffun

fun EstimacionPes(pesos, valores: TVectorR, P:real,
                  k:entero, pesoT: real, valorT: real) : real
    var
        capacidad, cota: real
        i: entero
    fvar
    
    capacidad <- P - pesoT
    cota <- valorT
    i <- k + 1      // siguiente objeto
    mientras i <= n && capacidad >= 0 hacer
        si pesos[i] <= capacidad entonces
            cota <- cota + valor[i]
            capacidad <- capacidad - pesos[i]
        fsi
        // no se introducen objetos fraccionados
        i <- i+1
    fmientras
    
    dev cota
ffun                  

#+END_EXAMPLE


* Glosario
- *Recorrido postorden*, se recorre en profundidad [izquierdo, derecho, raiz]
- *Recorrido preorden*, Se recorre en profundidad [raiz, izquierdo, derecho]
- *Recorrido inorden*, Se recorre en profundidad [izquierdo, raiz, derecho]
