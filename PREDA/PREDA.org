#+title: PREDA
#+startup: latexpreview overview

* Estructuras de datos
** Grafos
- $G=<N,A>$ grafo de $N$ vértices y $A$ aristas.
  
*** Matriz de adyacencia
|   | 1 | 2 | 3 |
| 1 | - | 1 | - |
| 2 | - | - | 1 |
| 3 | 1 | - | - |

- Si es no dirigido la matriz es simétrica

*** Listas de adyacencia
- Una lista por cada nodo
- Cada lista de cada nodo $i$ tiene una secuencia de nodos adyacientes a $i$.

*** Funciones de manipulación de grafos
- *fun CrearGrafo(): grafo*
      - Crea un grafo vacío.
- *fun AñadirArista(u,v:vértice; p:peso; g:grafo): grafo*
      - Añade una arista entre los vértices $u$ $v$ y peso $p$.
- *fun AñadirVertice(v:vértice;  g:grafo): grafo*
      - Añade un vértice al grafo.
- *fun BorrarArista(v1,v2:vértice; g:grafo): grafo*
      - Elimina la arista.
- *fun BorrarVertice(v:vértice, g:grafo): grafo*
      - Borra el vértice v y todas las aristas que partan o lleguen a él.
- *fun Adyacente?(v1,v2:vértice; g:grafo): booleano*
      - true si v1 y v2 son adyacentes.
- *fun Adyacentes(v:vértice; g:grafo): lista*
      - Lista con vértices adyacentes a v.
- *fun Etiqueta(v1,v2:vértice; g:grafo): etiqueta*
      - Peso asociado o etiqueta asociada a la arista.

Costes de manipulación de Grafos

|               | Matriz de adyacencia   | Lista de adyacencia |
| CrearGrafo    | O(1)                   | O(1)                |
| AñadirArista  | O(1)                   | O(1)                |
| AñadirVertice | O(n) (sin relocalizar) | O(1)                |
| BorrarArista  | O(1)                   | O(n)                |
| BorrarVertice | O(n)                   | O(n+a)              |
| Adyacente?    | O(1)                   | O(n)                |
| Adyacentes    | O(n)                   | O(1)                |
| Etiqueta      | O(1)                   | O(n)                |

*** Recorrido en profundidad

#+BEGIN_EXAMPLE
fun RecProfundidadRecursivo(v:nodo; visitado:Vector)
    var
        w: nodo
    fvar
    visitado[v] <- true
    para cada w adyacente a v hacer
        si !visitado[w] entonces
            RecProfundidadRecursivo(w,visitado)
        fsi
    fpara
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
tipo Vector=matriz[0..n] de booleano
fun Recorridorofundidad(G=<N,A>: grafo)
    var
        visitado:Vector
        v:nodo
    fvar
    para cada v in N hacer
        visitado <- falso
    fpara
    para cada v in N hacer
        si !visitado[v] entonces
            RecProfundidadRecursivo(v, visitado)
        fsi
    fpara
ffun
#+END_EXAMPLE

Versión Iterativa del recorrido en profundidad

#+BEGIN_EXAMPLE
fun RecProfundidadIterativo(v:nodo; visitado:Vector)
    var
        u,w: nodo
        P: TPila
    fvar
    P <- PilaVacía()
    visitado[v] <- cierto
    Apilar(v,P)
    mientras not Vacía(P) hacer
        u=Cima(P)
        Desapilar(P)
        para cada w adyacente a u hacer
            si not visitado[w] entonces
                visitado[w] <- true
                Apilar(w,P)
            fsi
        fpara
    fmientras
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
tipo Vector=matriz[0..n] de booleano
fun RecorridoProfundidad(G=<N,A>: grafo)
    var
        visitado: Vector
        v: nodo
    fvar
    para cada v in N hacer
        visitado[v] <- false
    fpara
    para cada v in N hacer
        si not visitado[v] entonces
            RecProfundidadIterativo(v, visitado)
        fsi
    fpara
ffun
#+END_EXAMPLE

*** Recorrido en amplitud

#+BEGIN_EXAMPLE]
fun RecAnchura(v:nodo; visitado:Vector)
    var
        u,w:nodo
        Q:TCola
    fvar
    Q <- ColaVacía()
    visitado[v] <- true
    Encolar(v,Q)
    mientras not Vacía(Q) hacer
        u <- Primero(Q)
        Desencolar(u,Q)
        para cada w adyacente a u hacer
            si !visitado[w] entonces
                visitado[w] <- true
                Encolar(w,Q)
            fsi
        fpara
    fmientras
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
tipo Vector=matriz[0..n] de booleano
fun RecorridoAnchura(G=<N,A>: grafo)
    var
        visitado: Vector
        v: nodo
    fvar
    para cada v in N hacer
        visitado[v] <- false
    fpara
    para cada v in N hacer
        si !visitado[v] entonces
            RecAnchura(v, visitado)
        fsi
    fpara
ffun
#+END_EXAMPLE

*** Árbol de recubrimiento
- Aristas usadas en un recorrido en anchura o profundidad
- $(n-1)$ aristas.

*** Punto de articulación
- $u$ es un punto de articulación si al eliminar $u$ y todas sus aristas el grafo deja de ser conexo.
- *Grafo biconexo*, sin puntos de articulación.
- *Conectividad K*, si eliminar *K* nodos cualesquiera no desconecta el grafo.

*** Ordenación topológica de un grafo dirigido acícliclo (GDA)
- En un *GDA* la existencia de un arco <u,v> indica que el nodo u precede al nodo v en una ordenación lineal.

Algoritmo de Khan para calcular un gda.

#+BEGIN_EXAMPLE
tipo Vector=matriz[identNodo_1..identNodo_n] de natural
fun OrdenTopologicoKahn(G=<N,A>: grafo): Vector
    var
        u,v:nodo
        Q:TCola
        orden: Vector
    fvar
    Q <- {u in N : GradoEntrante(A,u)=0}     // Nodos sin conexiones entrantes
    i <-1
    mientras !Vacia(Q) hacer
        u <- Primero(Q)
        Desencolar(u,Q)
        orden[u] <- i
        i <- i+1
        para cada (u,v) in A hacer            // Para cada conexión saliente de u
            A <- A \ {(u,v)}
            si GradoEntrante(A,v)=0 entonces  // Nodos sin conexiónes entrantes
                Encolar(v,Q)
            fsi
        fpara
    fmientras
    dev orden
ffun
#+END_EXAMPLE

*** Camino más corto desde la raiz a cualquier otro nodo
- Coincide con el árbol de recubrimiento en anchura (ARA) desde la raiz.

** Montículo
- Caso especial de árbol binario implementado sobre vectores
- Es un árbol balanceado y completo
- Cada nodo contiene un valor mayor o igual que el de sus hijos (mónticulo máximos)
      - O tambien montículo de mínimos.
- En la cima está el nodo raiz $T[1]$
- Nodo $T[i]$
      - Hijo izquierdo $T[2i]$
      - Hijo derecho $T[2i+1]$
      - Padre $T[i\ div\ 2]$ (división entera)

*** Implementación y operaciones
#+BEGIN_EXAMPLE
registro monticulo
T: vector[1..n] de entero;
c: natural;                  // Elementos en el montículo
MAX: natural;                // Máximo número de elementos
fregistro
#+END_EXAMPLE

#+BEGIN_EXAMPLE
fun CreaMonticuloVacio(m: monticulo)
    m.T <- null
    m.c <- 0
    m.MAX <- n
ffun    
#+END_EXAMPLE

#+BEGIN_EXAMPLE
fun MonticuloVacio?(m: monticulo): boleano
    si (m.c=0) entonces dev true sino dev false fsi
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
fun flotar(T:vector, i:natural)
    mientras (i>1) && (T[i div 2] < T[i]) hacer  // padre menor que el nodo i
        intercambiar(T[i], T[i div 2])
        i <- i div 2
    fmientras
ffun
#+END_EXAMPLE

#+begin_example
fun Hundir(m:monticulo, i:natural)
    var
        hi,hd,p:natural
    fvar
    repetir
        hi <- 2*i
        hd <- 2*i + 1
        p <- i
        si (hd <= m.c) && (m.T[hd] > m.T[i]) entonces
            i <- hd
        fsi
        si (hi <= m.c) && (m.T[hi] > m.T[i]) entonces
            i <- hi
        fsi
        intercambiar(m.T[p],m.T[i])      // Se intercambia con el mayor de los dos hijos
    hasta p=i
ffun
#+end_example

#+begin_example
fun Insertar(e:elemento; m:monticulo): monticulo
    si m.c = m.MAX entonces
        error(MonticuloLleno)
    sino
        m.c <- m.c + 1
        m.T[m.c] <- e          // Se inserta al final del montículo
        Flotar(m.T, m.c)
    fsi
ffun
#+end_example

#+begin_example
fun Primero(m: monticulo): elemento
    si m.c=0 entonces dev error
    sino
        dev m.T[1]
    fsi
ffun
#+end_example

#+begin_example
fun ObtenerCima(m:monticulo): elemento
    var
        e:elemento
    fvar
    si m.c != 0 entonces
        e <- m.T[1]
        m.T[1]<-m.T[m.c]
        m.c <- m.c - 1
        Hundir(m.T,1)
        dev e
    fsi
ffun
#+end_example

#+begin_example
/**
 * Convierte el montículo el vector T
*/
fun CreaMonticuloLineal(T:vector[1..n]): monticulo
    var
        m: monticulo
    fvar
    m <- CreaMonticuloVacio()
    m.T <- T
    m.c <- n    
    para i <- n/2 hasta 1 paso -1 hacer
        hundir(T,i);
    fpara

    dev m
ffun
#+end_example

*** Algoritmo Heapsort

#+begin_example
fun Heapsort(T:vector[1..n]): vector[1..n]
    var
        e:entero
        m:monticulo
        S:vector[1..n]
    fvar
    M <- CreaMonticuloLineal(T);
    para i <- 1 hasta n hacer
        e <- ObtenerCima(M)
        S[i] <- e
    fpara
    dev S
ffun
#+end_example

** Tablas de dispersión (Hash)
*** Funciones Hash
- Funciones no inyectivas
- Deben ser eficientes y deterministas
- Suele interesar una distribución de datos lo más dispersa posible.

*** Tipos de función Hash
- *Función Módulo*, $h(k) \to (k\ mod\ (M+1))$
      - $M$ es el número de indices existentes en la tabla.
- *Función Cuadrado*, $h(k) \to (c\ bits\ cenrales\ de\ k^2)$.
      - Si $c=2$ los índices son el rango [0, 99].
- *Función Plegado*, Partes de la clave y se opera sobre ellas.
      - Útil por ejemplo para strings.
      - $h(GITS)=G \oplus I \oplus T \oplus S$
- *Función multiplicación*, $h(k)=floor(M((k \alpha)\ mod\ 1))$
      - $h(3)=floor(1000((0.618 \times 3) mod 1)) = 854$
      - $\alpha=(\sqrt{5}-1) / 2$ es bastante común.

*** Colisiones
- *Factor de carga*, $\delta = n/m$
      - tabla tamaño $m$ con $n$ elementos.
- *Hashing abierto*
      - *Niveles (buckets)*, Dimensiones adicionales para valores que colisionen.
      - *Encadenamiento directo*, cuando hay una colisión se asigna una estructura lineal para esa entrada de la tabla.
- *Hashing cerrado*, $m$ es el tamaño de la tabla, $h'(k)$ una función hash, $i$ el índice de la colisión.
      - *Recorrido lineal*
            - $h(k,i)=(h'(k) + i)\ mod\ m$
            - Tiende a la creación de clusters
      - *Recorrido cuadrático*
            - $h(k,i)=(h'(k) + c_1i + c_2i^2)\ mod\ m$
            - Mejor dispersión.
      - *Recorrido mediante doble hashing*
            - Se usa una segunda función hash $h_2(k)$ llamada funcón de paso.
            - $h(k,i)=(h_1(k) + ih_2(k))\ mod\ m$
                  - $h_2(x) \neq 0$
                  - Los valores de $h_2(x)$ deben ser primos relativos de $m$.

* Voraz
** Planteamiento general
- Para problemas de optimización donde la solución se puede construir paso a paso sin necesidad de reconsiderar decisiones.
- Características del esquema.
      - Resolución de un problema de forma óptima
      - *Conjunto inicial de candidatos*, elementos que hay que planificar.
      - *Conjunto de candidatos Seleccionados*, elementos que ya han sido considerados y seleccionados.
      - *Conjunto de candidatos Reachazados*
      - *Función Solución*, determina si el conjunto de candidatos es na solución óptima.
      - *Función factible*, determina si la solución es competable o factible.
      - *Función Selección*, Escoge al candidato más prometedor todavia no seleccionado.

** Esquema general
#+BEGIN_EXAMPLE
fun Voraz(c: ConjuntoCandidatos&): ConjuntoCandidatos
    sol <- {}                                // Conjunto de candidatos seleccionados
    mientras c != {} && !Solución(sol) hacer
        x <- seleccionar(c)                  // Selecciona el mejor candidato
        c <- c \ {x}
        si factible(sol union {x}) entonces  // La union de sol y x es factible
            sol <- sol union {x}
        fsi
    fmientras
    si solucion(sol) entonces                // Comprobamos si es una solución
        dev sol
    sino
        imprimir("No hay solución")
    fsi
ffun
#+END_EXAMPLE

** Devolución del cambio Voraz
- pag 62
- Consultar [[id:16c6495c-9fc5-41e0-be73-deee5a797ee2][Devolución del cambio PD]].
- devolución del cambio por una máquina expendedora usando el mínimo número de monedas.
- Nota: Al menos disponemos de monedas de 1 de valor.

#+begin_example
tipo VectorNat=matriz[1..n] de natural
/*
 * @param T:VectorNat, valor de las monedas ordenadas de menor a mayor (ascendente)
*/ 
fun MonedasCambio(T:VectorNat; C:natural): VectorNat
    var
        solucion:VectorNat
    fvar

    // cantidad de cada moneda i
    para i <- 1 hasta n hacer
        solucion[i] <- 0
    fpara

    camRestante <- C           // Iniciamos con el valor total del cambio
    i <- n                     // bucles máximo es el número de monedas diferentes
                               //  que tenemos

    mientras camRestante != 0 && i >= 1 hacer
        solucion[i] <- camRestante div T[i]    // división de entero
                                               //  número de monedas de valor T[i]
        camRestante <- camRestante mod T[i]    // El resto de la división entera
                                               //  es el cambio que nos falta por asignar.
        i <- i-1                               // Pasamos a comprobar la siguiente moneda.
    fmientras
    
    dev solucion
ffun
#+end_example

** Árbol de recubrimiento mínimo: algoritmo de Prim
*** Planteamiento general
- NA son los nodos seleccionados.
- AR el árbol de recubrimiento
  
#+BEGIN_EXAMPLE
/*
 * @param G <N,A>: grafo de N vértices con A aristas
*/
fun Prim(G=<N,A>:Grafo): conjunto de aristas
    AR <- {}                                // árbol de recubrimiento
    NA <- {un nodo cualquiera de N}         // vértices del árbol de recubrimiento
    miemtras NA != N hacer
        Buscar {u,v} de coste mínimo tal que u in NA u v in N \ NA
        AR <- AR union {(u,v)}
        NA <- NA union {u}
    fmientras
    dev AR
ffun
#+END_EXAMPLE

*** Descripción detallada
#+BEGIN_EXAMPLE
tipo VectorNat=matriz[0..n] de natural
tipo VectorEnt=matriz[0..n] de entero

fun Prim(G=<N,A>: grafo): conjunto de aristas
    var
        nodoMinimo: VectorNat
        costeMinimo: VectorEnt
        AR: conjunto de aristas
    fvar
    
    AR <- {}
    costeMínimo[1] <- -1                        // Coste del primer vertice consigo mismo
    para i <- 2 hasta n hacer
        nodoMinimo[i] <- 1                      // Iniciamos con el primer nodo
        costeMinimo[i] <- Distancia(1,i)        // Distancia con el primer nodo
                                                //  infty si no hay conexión
    fpara
    
    para i <- 1 hasta n-1 hacer                 // Necesitamos n-1 aristas
        min <- infty
        para j <- 2 hasta n hacer
            // Nodos con coste -1 ya están dentro del AR.
            // Cogemos el nodo con arista de menor coste
            // con cualquiera de los nodos que ya están en el AR.
            si 0 <= costeMinimo[j] && costeMinimo[j] < min entonces
                min <- costeMinimo[j]
                nodo <- j
            fsi
        fpara
        
        AR <- AR union {(nodoMinimo[nodo], nodo)}    // añadimos el nodo de menor coste
        costeMinimo[nodo] <- -1                      // Se marca como añadido
        
        para j <- 2 hasta n hacer
            // Actualizamos la lista de costeMinimo y nodoMinimo con las distancias
            //  De los nodos externos al AR con el nuevo nodo
            si Distancia(j,nodo) < costeMinimo[j] && costeMinimo[j] != -1 entonces
                costeMinimo[j] <- Distancia(j,nodo)
                nodoMinimo[j] <- nodo
            fsi
        fpara
    fpara
    dev AR
ffun
#+END_EXAMPLE

** Árbol recubrimiento mínimo: Kruskal
#+BEGIN_EXAMPLE
fun Kruskal(G=<N,A>:grafo): conjunto de aristas
    var
        AR: conjunto de aristas
    fvar
    
    Ordenar(A)                                  // Ordenar las aristas en peso crecientes.
                                                //  un montículo es ideal.
    n <- número nodos de N
    AR <- {}
    Iniciar n conjuntos uno con cada nodo de N  // [{a}, {b}, ..., {u}, {v}]
    mientras AR no tenga n-1 aristas hacer      // Con n-1 aristas todos los nodos pueden
                                                //  estar conectados
        pop(A,u,v)                              // Arista (u,v) con peso menor aún no visitada
        comU <- buscarComponenteConvexa(u)      // Buscamos el conjunto que contiene a u
                                                //  Originalmente es el conjunto {u}
        comV <- buscarComponenteConvexa(v)      // Buscamos el conjunto que contiene a v
                                                //  originalmente es el conjunto {v}
        si comU != comV entonces                // Si son componentes convexas diferentes
                                                //  aún no hemos añadido esta arista a AR
            fusionar(comU, comV)                // Fusionamos las dos componentes convexas
                                                //  Así sabemos que estos dos nodos ya
                                                //  están conectados en el AR
            AR <- AR union {(u,v)}
        fsi
    fmientras
    dev AR
ffun
#+END_EXAMPLE

** Camino de coste mínimo: algoritmo de Dijkstra

- $G$ es un grafo dirigido con pesos mayor o igual a 0.
- *Camino especial*, se conoce el camino mínimo desde el origen a cada nodo del camino especial.

#+begin_example
tipo VectorNat=matriz[0..n] de natural
fun Dijkstra(G=<N,A>:grafo): VectorNat, VectorNat
    var
        especial,predecesor:VectorNat    // longitudes mínimas y el nodo predecesor.
        C:conjunto de nodos              // Nodos aún no seleccionados.
    fvar
    C={2,3,..,n}
    
    para i <- 2 hasta n hacer
        especial[i] <- Distancia(1,i)   // Si dos nodos no están conectados la
                                        //  distancia es infty
        predecesor[i] <- 1
    fpara
    
    mientras C contenga más de 1 nodo hacer
        v <- nodo in C que minimiza especial[]  // El nodo en C con menor valor en especial[]
        C <- C \ {v}
        para cada w in C hacer                  // Por cada nodo aún no seleccionado
                                                //  Se compara su distancia con
                                                //  la distancia que puede existir
                                                //  partiendo de v
            
            si especial[w] > especial[v] + Distancia(v,w) entonces
                especial[w] <- espacial[v] + Distancia(v,w)  // Distancia v,w es menor
                                                             //  que la distancia que tenía
                                                             //  w anteriormente
                predecesor[w] <- v                           // Se actualiza el predecesor
                                                             //  para poder reconstuir el
                                                             //  camino.
            fsi
        fpara
    fmientras
    dev especial[],predecesor[]
ffun
#+end_example

** Planificación con plazos
:PROPERTIES:
:ID:       ad3eb2c8-5ccf-44d3-bc53-c006098e81ae
:END:
- Se trata de seleccionar, planificar y realizar tareas antes de su fecha límite con el máximo beneficio.
      - $f_i$, fecha límite de la tarea $i$.
      - $b_i$, benificio de la tarea $i$.
- Solo se puede realizar una tarea a la vez.
- Realizar una tarea consume siempre una unidad de tiempo.
- Para comprobar si un conjunto es *factible* se comprueba que las tareas
  ordenadas en orden *no descendente* (ascendente o igual) son factibles.
      - Ser *factible* es que ninguna tarea finalize fuera de plazo.
- Suponemos que las tareas están ordenadas tal que $b_i \geq b_2 \geq \dots \geq \ b_n$.

#+begin_example
tipo VectorNat=matriz[0..n] de natural
/**
 * @param f:VectorNat, f[i] contiene la fecha límite del trabajo i
*/
fun PlanificacionPlazosDetallado(f:VectorNat, n:natural): VectorNat,natural
    var
        S:VectorNat  // Almacena los trabajos en orden de ejecución,
                     //  S[i] es el i-ésimo trabajo en la solución óptima.
    fvar
    
    S[0] <- 0  // Elemento centinela
    S[1] <- 1  // Trabajo 1 es el de mayor beneficio
    k <- 1     // número de elementos en S
    
    para i <- 2 hasta n hacer
        r <- k                // se busca posición válida para i
                              //  r inicia en la posición del último trabajo
                              //  seleccionado.

        mientras f[S[r]] > f[i] && f[S[r]] != r hacer
        
        // Mientras la finalización del trabajo en posición r sea mayor que el trabajo i
        //  (recuerda los trabajos se ejecutan de menor a mayor fecha de finalización)
        //  y la finalización del trabajo en posición r sea diferente a la ronda r
        //  bajamos a una ronda anterior.
        // Si F[S[r]] es igual a r es la última ronda que tenemos para ejecutar S[r]
        //  y hay que recordar que los trabajos se han incluido en orden de mayor valor
        //  Por tanto esta es la última oportunidad de ejecutar S[r]
        
            r <- r-1
        fmientras

        // Comprobamos si la finalización de la tarea en posición r es menor o igual
        //  que la tarea que estamos comprobando i, queremos las tareas ordenadas
        //  en orden no descendente de tiempo. En otro caso la tarea no es interesante.
        //  Y que la tarea i finaliza después de la ronda r, sino está fuera de tiempo.
        
        si f[S[r]] <= f[i] && f[i]>r entonces
            para q <- k mientras q >= r+1 incr <- -1 hacer
                // hacemos sitio para insertar la tarea
                // desde k hasta r+1 se desplazan una casilla hacia el final
                S[q+1] <- S[q]
            fpara
            
            S[r+1] <- i       // Asignamos la tarea en la posición r+1
                              //  La posición r la queremos conservar.
            k <- k+1          // Guardamos que se ha incluido una tarea.
        fsi
    fpara
    dev S,k
ffun
#+end_example

* Divide y vencerás
** Planteamiento General
- Descomposición de un problema en subproblemas de su mismo tipo.
- Resolución recursiva de los subproblemas.
- Combinación si procede de las soluciones del problema.

** Esquema General
#+BEGIN_EXAMPLE
fun DyV(problema)
    si trivial(problema) entonces
        dev solución-trivial
    sino
        {p1,p2,...,pk} <- descomponer(problema)
        para i in (1..k) hacer
            si <- DyV(pi)
        fpara
        dev combinar(s1,s3,...,sk)
    fsi
ffun
#+END_EXAMPLE

** Búsqueda Binaria
#+BEGIN_EXAMPLE
fun bbinaria(i,j:entero; v:vector[1..N] de entero; x:entero): booleano
    // Primer índice del vector 1 para simplificar
    var
        m:entero
    fvar
    si i=j entonces                  // los dos índices han convergido al mismo valor
        si v[i]=x entonces
            dev verdadero
        sino
            dev falso
        fsi
    sino
        m <- (i+j) div 2
        si x <= v[m] entonces
            bbinaria(i,m,v,x)
        sino
            bbinaria(m+1,j,v,x)
        fsi
    fsi
ffun
#+END_EXAMPLE

** Ordenación rápida (Quicksort)                                     :ATTACH:
:PROPERTIES:
:ID:       b26bd1bd-be2d-4542-bb20-c2908cedde80
:END:
- pag 124, ordena de menor a mayor.
- Menores que el pivote a la izquierda del pivote, mayores a la derecha.

#+BEGIN_EXAMPLE
fun Pivotar(T:vector[i..j] de entero; pivote:natural&)
    var
        p,k,l:entero
    fvar
    p <- T[i]                                  // Primer valor de T
    k <- i                                     // Primer índice de T
    l <- j+1                                   // último índice de T + 1
    repetir k <- k+1 hasta T[k] > p or k >= j  // k+1 hasta que T[k] mayor que
                                               //  el primer  valor de T o k al final de T
    repetir l <- l-1 hasta T[l] <= p           // l-1 hasta que T[l] menor igual 
                                               //  que el primer valor de T
    mientras k < l hacer                       // hasta que k y l se crucen
        intercambiar(T,k,l)                    // Se intercambian los valores
        repetir k <- k + 1 hasta T[k] > p      // subir índice izquierdo hasta que T[k]
                                               //  mayor que el primer valor de T
        repetir l <- l - 1 hasta T[l] <= p     // Bajar índice derecho hasta que T[l]
                                               //  menos o igual que el primer valor de T
    fmientras
    intercambiar(T,i,l)
    pivote <- l
ffun
#+END_EXAMPLE

[[attachment:clipboard-20260129T110042.png]]
  
#+BEGIN_EXAMPLE
fun Quicksort(T[i..j])
    var
        l:natural
    fvar
    l <- i                                     // Se suele elegir el primer elemento
                                               //  Como pivote.
    si trivial(i-j) entonces Insertar(T[i..j]) // Trivial si son tan solo dos elementos
    sino
        Pivotar(T[i..j],l)                     // Pivotar actualiza el valor de l
                                               // Desde el pivote dividimos el vector
                                               //  El pivote no se incluye en el
                                               //  proceso recursivo
        Quicksort(T[i..l-1])
        Quicksort(T[l+1..j])
    fsi
ffun
#+END_EXAMPLE

** Merge Sort
# TODO

** Cálculo del elemento mayoritario en un vector                     :ATTACH:
:PROPERTIES:
:ID:       46f2d130-5688-4af6-8c45-9f8dbd7fe57c
:END:
- Buscar si un elemento aparece (n/2) + 1 veces en el vector
- Importante diferenciar que mayoritario no es el que aparece más veces.
  Sino estrictamente el que aparce almenos (n/2) + 1

#+BEGIN_EXAMPLE  
fun Mayoritario(i,j:natural; v:vector[1..n] de natural): entero
    var
        m: natural
        s1,s2: entero
    fvar
    
    si i=j entonces                     // Caso trivial
        dev v[i]
    sino
        m <- (i+j) / 2                  // Punto medio, división entera
        s1 <- Mayoritario(i,m,v)        // La mitad menor (caso de n impar)
        s2 <- Mayoritario(m+1,j,v)      // La mitad mayor
        dev Combinar(s1,s2,i,j,v)
     fsi
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
fun Combinar(a,b:entero; i,j:natural; v:vector[1..n] de natural): entero
    si a=-1 and b=-1 entonces dev -1 fsi
    si a=-1 and b!=-1 entonces dev ComprobarMayoritario(i,j,b,v) fsi
    si a!=-1 and b=-1 entonces dev ComprobarMayoritario(i,j,a,v) fsi    
    si a!=-1 and b!=-1 entonces
        si ComprobarMayoritario(i,j,a,v)=a entonces
            dev a
        sino si ComprobarMayoritario(i,j,b,v)=b entonces
            dev b
        sino
            dev -1
        fsi
    fsi
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
fun ComprobarMayoritario(i,j:natural; x:entero; v:vector[1..n] de natural): entenro
    var
        c:natural
    fvar
    c <- 0
    para k <- i hasta j hacer
        si v[k]==x entonces c <- c+1 fsi
    fpara
    si c > (j-i+1)/2 entonces
        dev x
    sino
        dev -1
    fsi
ffun
#+END_EXAMPLE

Ejemplo de una traza

[[attachment:clipboard-20260129T132356.png]]

** Distancia más cercana entre dos puntos
- Tenemos una lista de puntos ordenados de manera ascendente en la coordenada x.
- $O(n\ log(n))$

#+begin_example
typo Punto=registro
    x:float
    y:float
fregistro

typo Puntos=matriz[p1..pn] de puntos

/**
 * @param puntos:Puntos, vector de puntos ordenados de forma ascendente respecto a la coordenada x
*/
fun DistMásCercana(puntos:Puntos, l:entero, r:entero): float
    var
        dl:float
        dr:float
        dc:float
    fvar
    
    si r-l = 1 entonces
        dev Dist(puntos[l], puntos[r])         // Caso trivial
    sino si r-l < 1 entonces
        dev infty                              // Caso trivial de un grupo con un solo vértice
    sino
        dl <- DistMásCercana(l, r/2)
        dr <- DistMásCercana(r/2 + 1, r)
        dc <- DistMásCercana(r/2, r/2 + 1)     // Distancia entre los puntos más cercanos a la línea de corte.

        dev min(dl,dr,dc)
    fsi
ffun
#+end_example

* Programación dinámica
** Planteamiento general
- Establecimiento de las ecuaciones que representan el problema.
- Identificación de los *resultados parciales*.
- Construcción de la tabla de resultados parciales:
      - Inicialización de la tabla con los casos base que establece la ecuación del problema.
      - Establecimiento del orden de llenado de la tabla, de forma que se calculen en primer lugar los resultados parciales que requiern pasos posteriores.
      - Sustitución de las llamas recursivas del algoritmo por consultas a la tabla.

** Esquema General
- pag 131, no hay esquema general, hay ejemplos con fibonacci
  
#+BEGIN_EXAMPLE
fun FibDin(n:entero): entero
    var
        i,suma: entero
        t: tabla[0..n] de entero
    fvar
    si n <= 1 entonces
        dev 1
    sino
        t[0] <- 1
        t[1] <- 1
        para i <- 2 hasta n hacer
            t[i] <- t[i-1] + t[i-2]
        fpara
        dev t[n]
    fsi
ffun
#+END_EXAMPLE

Reduciendo la complejidad espacial a $O(1)$.

#+BEGIN_EXAMPLE
fun FibDin2(n: entero): entero
    var
        i,suma,f,g: entero
    fvar
    si n <= 1 entonces
        dev 1
    sino
        f <- 1
        g <- 1
        para i <- 2 hasta n hacer
            suma <- f+g
            g <- f
            f <- suma
        fpara
        dev suma
    fsi
ffun
#+END_EXAMPLE

** Coeficientes binomiales
# TODO

** Devolución del cambio
:PROPERTIES:
:ID:       16c6495c-9fc5-41e0-be73-deee5a797ee2
:END:
- pag 135
- Encontrar el mínimo número de monedas posible para cierta cantidad C.
- N monedas diferentes

#+BEGIN_EXAMPLE
tipo Tabla=matriz[1..N, 0..C] de entero        // N filas por tipos de moneda
                                               // C columnas por cantidades
                                               // El índice de la columna representa
                                               //  La cantidad C
tipo Vector=matriz[0..N] de entero
fun DarCambio(C:entero, moneda:Vector): Tabla
    var
        t: Tabla
        i,j: entero
    fvar
    para i <- 1 hasta N hacer                         // Primera columna a 0's
        t[i,0] <- 0
    fpara
    para j <- 1 hasta C hacer
        para i <- 1 hasta N hacer
            si i=1 && moneda[i] > j entonces         // Si la menor moneda es mayor que
                                                      //  que la cantidad, No es resoluble.
                t[i,j] <- infty
            sino
                si i = 1 entonces
                    t[1,j] <- 1 + t[1, j - moneda[1]] // Si no encaja adquiere el
                                                      //  valor infty
                sino
                    si j < moneda[i] entonces         // La moneda es mayor que la cantidad
                        t[i,j] <- t[i-1,j]            // Valor de la fila superior
                    sino
                        // menor entre un resultado parcial + 1 y la fila superior
                        // Resultado parcial es [IndiceMoneda, Columna - ValorMoneda]
                        t[i,j] <- min(t[i-1,j], t[i, j - moneda[i]] + 1)
                    fsi
                fsi
            fsi
        fpara
    fpara
    dev t
ffun
#+END_EXAMPLE

El resultado está en la última fila de cada columna.
Para la selección de monedas:

#+BEGIN_EXAMPLE
tipo Tabla=matriz[1..N,0..C] de entero
tipo Vector=matriz[0..N] de entero
fun SeleccionarMonedas(C:entero, moneda:Vector, t:Tabla, seleccion:Vector&)
    var
        i,j:entero
    fvar
    para i <- 0 hasta N hacer
        selección[i] <- 0        // Preparamos todo a 0
    fpara
    i <- N                       // De abajo a arriba
    j <- C
    mientras j > 0 hacer
        si i > 1 && t[i,j]=t[i-1,j] entonces
            i <- i-1                         // Subimos una fila
        sino
            seleccion[i] <- seleccion[i]+1   // añadimos una moneda a la combinación.
            j <- j - moneda[i]               // Restamos el valor al resto de la cantidad.
        fsi
    fmientras
ffun
#+END_EXAMPLE

Si el valor C fuera incompatible con nuestras monedas disponibles el resultado sería
una moneda del valor inferior, por eso hay que comprobar el resultado de la selección de monedas.


** Mochila Entera
#+begin_example
tipo Tabla = matriz[0..n,0..V] de entero
tipo Vector = matriz[0..n] de entero
fun MochilaEntera(vol:Vector, ben:Vector, n:entero, V:entero, V:Tabla)
    var
        i,j: entero
    fvar
    para i<-1 hasta n hacer
        M[i,0] <- 0
    fpara
    para j <- i hasta V hacer
        M[0,j] <- 0
    fpara
    para i <- hasta n hacer
        para j <- hasta V hacer
            si vol[i] > j entonces
                M[i,j] <- M[i-1,j]
            sino
                // aquí se evita poner dos veces el mismo objeto
                //  usando el índice i-1
                M[i,j] <- max(M[i-1,j], M[i-1, j - vol[i]] + ben[i])
            fsi
        fpara
    fpara
ffun
#+end_example

#+begin_example
fun ObjetosMochila(vol:vector, M:Tabla, n:entero, V:entero, objetos:Vector)
    var
        i,W:entero
    fvar
    W <- V

    // Se recorre de atrás hacia delante.

    para i <- n hasta 1 incremento -1 hacer
        si M[i,W] = M[i-1, W] entonces
            objetos[i] <- 0
        sino
        
            // seleccionamos la fila donde hay un cambio
            //  respecto a la fila superior
            
            objetos[i] <- 1
            W <- W - vol[i]
        fsi
    fpara
ffun
#+end_example

** Multiplicación Asociativa de matrizes
- La intención es minimizar el número de operaciones entre matrices apoyándose sobre la propiedad asociativa.
- Coste temporal $O(N^3)$ espacial $O(N^2)$

#+begin_example
tipo Tabla=matriz[1..N,1..N] de entero
tipo Vector=matriz[0..N] de entero
fun MultMatrices2(d:Vector, N:entero; mult:Tabla; pos:Tabla)
    var
        i,diag: entero
    fvar
    para i<- 1 hasta N hacer
        para i<-1 hasta N-diag hacer
            MinMultiple(mult,d,i+diag, minimo,posicion)
            mult[i,i+diag] <- minimo
            pos[i,i+diag] <- posicion
        fpara
    fpara
    EscribeParentizado(pos,1,N)
ffun
#+end_example

#+begin_example
fun MinMultiple2(mult:Tabla; d:Vector; i:entero; j:entero; minimo:entero; pos:entero&)
    var
        k,tmp:entero
    fvar
    minimo <- infty
    pos <- i
    para k <- i hasta j-1 hacer
        tmp <- mult[i,k] + mult[k+1,j] + d[i-1]*d[k]*d[j]
        si tmp < minimo entonces
            minimo <- tmp
            pos <- k
        fsi
    fpara
ffun
#+end_example

#+begin_example
fun EscribeParentizado(pos:Tabla; i:entero; j:entero)
    var
        k:entero
    fvar
    si i=j entonces
        Imprimir "M", imprimir i
    sino
        k <- pos[i,j]
        Imprimir "("
        EscribeParentizado(pos,i,k)
        EscribeParentizado(pos,k+1,j)
        imprimir ")"
    fsi
ffun
#+end_example

* Vuelta atrás
** Planteamiento general
- búsqueda exaustiva de las posibles soluciones.
- Recorrido en *Profundidad* del grafo inplícito de un problema.
      - Grafo sin ciclos

** Esquema general
- /IniciarExploraciónNivel()/, Opciones posibles para extender la solución k-prometedora.
- /OpcionesPendientes()/, Compruena que quedan opciones por explorar en el nivel.
- /SoluciónCompleta()/, Comprueba si se ha encontrado una solución.
- /ProcesarSolución()/, Hacer las acciones necesarias con la solución.
  Por ejemplo *dev* o imprimir el resultado.
- /Completable()/, comprueba que la solución k-prometedora se puede extender.

#+BEGIN_EXAMPLE
/*
 * @param v: secuencia k-prometedora
 * @param k: nivel
 */
fun VueltaAtras(v: Secuencia; k: entero)
    IniciarExploraciónNivel(k)
    mientras OpcionesPendientes(k) hacer
        extender v con siguiente opción
        si SoluciónCompleta(v) entonces
            ProcesarSolución(v)
        sino
            si Completable(v) entonces
                VueltaAtras(v, k+1)
            fsi
        fsi
    fmientras
ffun
#+END_EXAMPLE

Si solo se busca una solución.

#+BEGIN_EXAMPLE
fun VueltaAtras(v: Secuencia; k: entero; encontrado: booleano)
    IniciarExploraciónNivel(k)
    mientras OpcionesPendientes(k) && !encontrado hacer
        extender v con siguiente opción
        si SoluciónCompleta(v) entonces
            ProcesarSolución(v)
            encontrado <- true
        sino
            si Competable(v) entonces
                VueltaAtras(v, k+1, encontrado)
            fsi
        fsi
    fmientras
ffun
#+END_EXAMPLE

** Problema de la reina
Se quiere situar una reina en cada columna de un tablero de ajedrez de forma que ninguna de ellas pueda eliminar a ninguna otra reina.

La solución mostrada busca todas las soluciones posibles.
#+BEGIN_EXAMPLE
/*
 * @param s: Almacena la solución temporal.
 *  En cada celda (columna) se almacena el número de la fila donde se posiciona la reina.
 * @param n: tamaño del tablero
 */
fun Reinas(s:Vector[1..n] de entero; n,k:entero)
    s[k] <- 0
    mientras s[k] <= n hacer
        s[k] <- s[k] + 1                    // Se va probando desde la primera
                                            //  hasta la última fila.
        si Completable(s,k) entonces
            si k=n entonces
                escribir(s)                 // Muestra la solución o
                                            //  la escribe en un archivo
            sino
                Reinas(s,n,k+1)
            fsi
        fsi
    fmientras
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
/*
 * Comprueba que no hayan reinas en la misma fila ni en la misma diagonal.
 */
fun Completable(s:Vector[1..n] de entero; k: entero):booleano
    var
        i:entero
    fvar
    para i <- 1 hasta k-1 hacer
        // Es interesante ver la forma de comprobar la diagonal
        si s[i]==s[k] || (abs(s[i]-s[k])==abs(i-k)) entonces
            dev falso
        fsi
    fpara
    dev true
ffun
#+END_EXAMPLE

** Coloreado de grafos
Se desea asignar un color a cada vértice de un grado conexo, de forma que no hayan vertices adyacentes con el mismo color.

Se sabe que se necesitan 4 colores como mínimo para cualquier grafo.

#+BEGIN_EXAMPLE
// Grafo[i,j]==1 si i,j están conectados.
tipo Grafo=matriz[i..N,i..N] de entero
tipo Vector=matriz[i..N] de entero

/*
 * @param v: Vector k-prometedor, posición i representa al vector i
 * @param m: Número de colores
 * @param k: Nivel de la solución
*/
fun ColoreaGrafo(g:Grafo; m:entero; k:entero; v:Vector; exito: booleano&)
    v[k] <- 0
    exito <- false
    mientras v[k] < m && !exito hacer
        v[k] <- v[k] + 1
        si Competable(g,v,k) entonces
            si k==N entonces
                Procesar(v)
                exito <- true
            sino
                ColoreaGrafo(g,m,k+1,v,exito)
            fsi
        fsi
    fmientras
ffun
#+END_EXAMPLE

#+BEGIN_EXAMPLE
/*
 * Comprueba si algún vértice conectado a k tiene el mismo color que el vértice k.
*/
fun Completable(g:Grafo, v:Vector, k:entero): booleano
    i:entero
    para i <- 1 hasta k-1 hacer
        si g[k,i]==1 && v[k]==v[i] entonces
            dev false
        fsi
    fpara
    dev true
ffun
#+END_EXAMPLE

** Asignación de cursos en una escuela
- Se trata de asignar $n$ profesores y $n$ aulas a $n$ cursos de una escuela.
- *válida(aula,k): booleano*, devuelve true si el *aula* puede usarse en el curso *k*.
- *especialidad(prof,k): booleano*, devuelve true si el profesor está capacitado para impartir el curso k.

#+begin_example
tipo TCurso = registro
    aula:entero
    profesor:entero
fregistro

tipo TEscuela=matriz[1..n] de TCurso
tipo TVectorB=matriz[1..n] de booleano

fun CursosEscuela(escuela:TEscuela, k:enteros, asigAula:TVectorB, asigProf:TVectorB, exito:booleano)
    var
        es_solucion:booleano
        aula:entero
        prof:entero
    fvar
    
    aula <- 1
    mientras aula <= n && !exito hacer
        si !asigAula[aula] && válida(aula,k) entonces
            prof <- 1
            mientras prof <= n && !exito hacer
                si !asigProf[prof] && especialidad(prof,k) entonces

                    // Si es compatible asignamos el profesor y el aula para el curso
                    escuela[k].aula <- aula
                    escuela[k].prof <- prof

                    // Se marca al profesor y al aula como asignados
                    //  para explorar las soluciones que parten de este nodo.
                    asigAula[aula] <- true
                    asigProf[prof] <- true
                    
                    si k = n entonces
                        PresentarSolucion(escuela)
                        exito <- true
                    sino
                        // Búsqueda en profundidad de las soluciones
                        //  que parten de esta solución
                        CursosEscuela(escuela, k+1, asigAula, asigProf, exito)
                    fsi

                    // Para explorar la siguiente solución de este nivel k
                    //  se deshacen las asignaciones actuales.
                    asigAula[aula]<-falso
                    asigAula[prof]<-falso
                fsi
                prof <- prof + 1
            fmientras
        fsi
        aula <- aula + 1
    fmientras
ffun
#+end_example

Podemos llamar la función anterior desde otra función simplificada.

#+begin_example
fun HorarioValido(escuela:TEscuela&; n:entero; asigAula:TVectorB&; asigProf:TVectorB&)
    var
        exito:booleano
    fvar
    
    para i=1 hasta n hacer
        asigAula[i] <- false
        asigProf[i] <- false
    fpara

    exito <- false

    CursosEscuela(escuela,1,asigAula,asigProf,exito)

ffun
#+end_example

** Ciclos Hamiltonianos

#+begin_example
tipo Grafo=matriz[1..N,1..N] de entero
tipo Vector=matriz[1..N] de entero
tipo VectorB=matriz[i..N] de entero

/**
 * @param v:Vector, secuencia de nodos del camino
 * @param incluidos:VectorB, nodos incluidos
*/
fun CiclosHamiltoniano(g:Grafo; k:entero; v:Vector; incluidos:VectorB)
    var
        i:entero
    fvar
    para i <- 2 hasta n hacer
        si g[v[k-1],i] && !incluidos[i] entonces   // si hay conexión con el anterior nodo
                                                   //  y este nodo no está incluido
            v[k] <- i                              // Se incluye como siguiente nodo
            incluidos[i] <- true                   // Se marca como incluido
            
            si k=n entonces
                si g[v[n],1] entonces              // Si se conecta con el primero
                                                   //  hemos encontrado una solución
                    PresentarSolucion(v)
                fsi
            sino
                CiclosHamiltonianos(g, k+1, v, incluidos)
            fsi
            incluidos[i] <- falso                  // Deshacer cambios para la siguiente
                                                   //  exploración
        fsi
    fpara
ffun
#+end_example

#+begin_example
fun PresentarHamiltonianos(g)
    var
        v:Vector
        incluidos:VectorB
        i:entero
    fvar
    v[1] <- 1
    incluidos[1]<-true
    para i<-2 hasta n hacer
        incluidos[i] <- falso
    fpara
    CiclosHamiltoniano(g,2,v,incluidos)
ffun
#+end_example

* Ramificación y Poda
** Planteamiento general
- Cota de resultado mínimo general
- Si la cota máxima de un nodo no supera la cota mínima general ese camino
  se poda directamente.
- Recorridos por el camino más probable de cada hijo.
  - Construcción de un *montículo* de soluciones.

** Esquema general
Esquema general de un problema de minimización.

#+begin_example
fun RamificacionYPoda(nodoRaiz: TNodo; mejorSolución: TNodo&; cota: real)
    monticulo <- CrearMonticuloVacio()
    cota <- EstimacionPes(nodoRaiz)
    Insertar(nodoRaiz, monticulo)
    mientras !MonticuloVacio?(monticulo) && EstimaciónOpt(Primero(monticulo)) <= cota hacer
        nodo <- ObtenerCima(monticulo)
        para cada hijo extensión válida de nodo hacer
            si solución(hijo) entonces
                si coste(hijo) <= cota entonces
                    cota <- coste(hijo)
                    mejorSolucion <- hijo
                fsi
            sino
                si EstimacionOpt(hijo) <= cota entonces
                    Insertar(hijo, monticulo)
                    si EstimacionPes(hijo) < cota entonces
                        cota <- EstimacionPes(hijo)
                    fsi
                fsi
            fsi
        fpara
    fmientras
ffun
#+end_example

** Mochila Entera
#+BEGIN_EXAMPLE
tipo TVectorB = matriz[1..n] de booleano
tipo TVectorR = matriz[1..n] de real
tipo TNodo = registro        // Solución parcial o final
    moch: TVectorB           // Elementos incluidos
    k: entero                // etapa de búsqueda, posición del objeto a considerar
    pesoT: real              // Peso objetos introducidos
    valorT: real             // valor objetos introducidos
    estOpt: real             // estimación Optimista,
                             //   determina posición en montículo
fregistro

/**
 * pesos: TVectorR: pesos de los objetos de mayor a menos valor.
 * valores: TVectorR: valor de los objetos de mayor a menor.
 * P: real: peso máximo soportable.
 * moch: out TVectorB: vector objetod añadidos de inicio con todo en falso de salida?
 * valor: real: valor de la solución óptima.
 * pesos, valores y moch tienen los objetos ordenados de más e menor valor.
 */
fun Mochila(pesos: TVectorR, valores: TVectorR,
            P:real, moch: out TVectorB, valor: out real)
    var
        monticulo: TMonticulo
        nodo, hijo: TNodo
        cota : real   // la cota sirve para podar ramas no óptimas
        estPes: real  // Sirve para actualizar la cota si alguna rama
                      //   en el peor de los casos puede dar una solución mejor
    fvar
    
    monituclo <- CreatMonticuloVacio()
    valor <-0
    
    // Construimos primer nodo
    //   no es solución es solo el inicio (empieza en k=1)
    nodo.moch <- moch
    nodo.k <- 0
    nodo.pesoT <- 0
    nodo.valorT <- 0
    nodo.estOpt <- EstimacionOpt(pesos, valores, P, nodo, pesoT, nodo.valorT)

    Insertar(nodo, monticulo)
    
    cota <- EstimacionPes(
        pesos, valores, P,nodo.k,
        nodo.PesoT, nodo.valorT
        )

    mientras !MonticuloVacio(monticulo) &&
             EstimacionOpt(Primero(monticulo)) >= cota hacer
             
        nodo <- OptenerCima(monticulo)  // la solución con mejor estimación
        
        hijo.k    <- nodo.k + 1      // el siguiente objeto
        hijo.moch <- nodo.moch       // copy?
        
        // cabe el objeto en la mochila?
        si nodo.pesoT + pesos[hijo.k] <= P entonces
            hijo.moch[hijo.k] <- cierto   // añadimos el nuevo objeto
            hijo.pesoT  <- nodo.pesoT + pesos[hijo.k]
            hijo.valorT <- nodo.valorT + valores[hijo.k]
            hijo.estOpt <- nodo.estOpt
            si hijo.k = n entonces
                // el último nodo es el nodo n
                si cota <= hijo.valorT entonces
                    // vemos si mejoramos la cota actual
                    //  Representa una solución óptima encontrada
                    moch  <- hijo.moch
                    valor <- hijo.valorT
                    cota  <- valor  // actualizamos cota
                fsi
            sino
                // la solución no está completa
                // añadimos una copia del hijo al montículo
                // (si la estOpt es alta se posicionará cerca de la cima)
                Insertar(hijo, monticulo) // insertamos copia
            fsi
        fsi

        // Estimación sin el objeto hijo en la mochila
        hijo.estOpt <- EstimacionOpt(
            pesos, valores, P, hijo.k /* se comprueba a partir de k+1 */,
            nodo.pesoT, nodo.valorT
            )

        si hijo.estOpt >= cota entonces
            // solución sin el objeto k que mejora la cota
            hijo.moch[hijo.k] <- falso
            hijo.pesoT  <- nodo.pesoT
            hijo.valorT <- nodo.valorT
            
            si hijo.k = n entonces
                si cota <= hijo.valorT entonces
                    // guardamos la solución final que mejora la cota
                    //   actualizamos la cota porque la mejora
                    moch  <- hijo.moch
                    valor <- hijo.valorT
                    cota  <- valor
                fsi
            sino
                // solución no completa
                //  insertamos una copia de hijo
                Insertar(hijo, monticulo)
                estPes <- EstimacionPes(pesos, valores, P, hijo.k,
                                        hijo.PesoT, hijo.valorT)

                // comprobamos si la estimación pesimista sin el objeto
                //  mejora la cota, si es así actualizamos la cota
                si cota < estPes entonces
                    cota <- estPes
                fsi
            fsi
        fsi
    fmientras
ffun
#+end_example

#+begin_example
fun EstimacionOpt(pesos, valores : TVectorT, P: real,
                  k: entero, pesoT: real, valorT: real): real
    var
        capacidad, estimacion : real
        i : entero
    fvar
    
    capacidad <- P - pesoT  // Peso máximo - peso actual
    estimacion <- valorT

    i <- k + 1 // siguiente objeto
    mientras i <= n && capacidad >= 0 hacer
        si pesos[i] <= capacidad entonces
            estimacion <- estimacion + valor[i]  // más valor
            capacidad <- capacidad - pesos[i]    // pero menos capacidad
        sino
            // se pone una parte de este objeto
            // que no es real es la estimación optimista
            estimacion <- estimacion + (capacidad / pesos[i]) * valor[i]
            capacidad <- 0
        fsi
        i <- i + 1
    fmientras
    dev estimacion
ffun
#+end_example

#+begin_example
fun EstimacionPes(pesos, valores: TVectorR, P:real,
                  k:entero, pesoT: real, valorT: real) : real
    var
        capacidad, cota: real
        i: entero
    fvar
    
    capacidad <- P - pesoT
    cota <- valorT
    i <- k + 1      // siguiente objeto
    mientras i <= n && capacidad >= 0 hacer
        si pesos[i] <= capacidad entonces
            cota <- cota + valor[i]
            capacidad <- capacidad - pesos[i]
        fsi
        // no se introducen objetos fraccionados
        i <- i+1
    fmientras
    
    dev cota
ffun                  
#+end_example

** Asignación de tareas: Pastelería
- $n$ pasteleros con distintos tipos de destreza.
  Ejemplo de tabla de tiempos de hacer cada pastel.
  | pastelero | t.pastel 1 | t.pastel 2 | t.pastel 3 |
  |         1 |          2 |          5 |          3 |
  |         2 |          5 |          3 |          2 |
  |         3 |          6 |          4 |          9 |
  |         4 |          6 |          3 |          8 |
  |         5 |          7 |          5 |          8 |

- Hay que asignar los pastelero  un pedido minimizando el tiempo.
- Los pedidos se presentan como una lista, [11321]
- Cada pastelero solo se puede asignar una vez.

#+begin_example
tipo TVectorB=matriz[1..n] de booleano
tipo TVector=matriz[1..n] de entero

// TNodo es la representación de una solución
tipo TNodo=registro
    pasteleros: TVector  // pastelero asignado al pedido en posición i
    asignados: TVectorB  // qué pastelero i ha sido asignado
    k: entero            // último pedido asignado, para saber si hemos acabado
    costeT: real         // Coste de las asignaciones
    estOpt: real         // estimacion optimista a la baja del coste que se puede alcanzar
                         //  Marca el orden dentro del montículo.
fregistro

tipo TTabla=matriz[1..n,1..n] de entero

fun AsignaPasteleros(costes:TTabla; pedido:TVector; pasteleros:TVector&; costeT:entero&)
    var
        monticulo: TMonticulo
        nodo, hijo: TNodo
        cota, estPes: real
    fvar

    monticulo <- CrearMonticuloVacio()
    costeT <- 0
    
    // Construimos el primer nodo
    nodo.pasteleros <- pasteleros
    para i <- 1 hasta n hacer
        nodo.asignados[i] <- false
    fpara

    nodo.k <- 0
    nodo.costeT <- 0

    // Est. optimista es asignando siempre el pastelero más eficiente
    //  permitiendo que se repitan
    
    nodo.estOpt <- EstimacionOpt(costes, pedido, nodo.k, nodo.costeT)
    Insertar(nodo, monticulo)    // estOpt marca el orden dentro del montículo

    // Est. pesimista o cota es asignando siempre el pastelero menos eficiente
    //  aunque este se repita.
    
    cota <- EstimacionPes(costes, pedido, nodo.k, nodo.costeT)

    mientras !MonticuloVacio?(monticulo) && EstimacionOpt(Primero(monticulo)) <= cota hacer
        nodo <- ObtenerCima(monticulo)          // Nodo con mejor estOpt
        
        hijo.k <- nodo.k + 1  // Se prepara el valor k para emperzar a explorar el
                              //  nuevo pedido.

        hijo.pasteleros <- nodo.pasteleros      // Se parte del estado del padre
        hijo.asignados <- nodo.asignados

        // Se recorren los hijos y si procede se añaden al montículo

        para i <- 1 hasta n hacer
            si !hijo.asignados[i] entonces      // Se comprueba si el pastelero i
                                                //  ha sido asignado.
                hijo.pasteleros[hijo.k] <- i    // Se asigna al pedido k el pastelero i
                hijo.asignados[i] <- true       // Se marca como asignado
                
                // Se actualiza el coste total con la asignación
                //  del nuevo pastelero.
                
                hijo.costeT <- nodo.costeT + coste[i, pedido[hijo,k]]

                // Se comprueba si hemos encontrado una solución final
                
                si hijo.k = n entonces
                    si cota >= hijo.costeT entonces  // Se comprueba que la solución
                                                     //  presenta alguna mejora
                                                     
                        // Se actualizan los valores de salida, la solución
                        
                        pasteleros <- hijo.pasteleros
                        costeT <- hijo.costeT
                        cota <- costeT    // la mejor solución encontrada
                                          //  pasa a ser la nueva cota
                    fsi
                sino si EstimacionOpt(costes, pedido, hijo.k, hijo.costeT) <= cota entonces
                    // Solución no completa pero con posibilidades
                    
                    hijo.estOpt <- EstimacionOpt(costes, pedido, hijo.k, hijo.costeT)

                    Insertar(hijo, monticulo)  // Insertamos una copia del nodo hijo

                    // Si la estimación pesimista es mejor que la cota actual
                    //  podemos actualizar el valor de la cota
                    
                    estPes <- EstimacionPes(costes, perido, hijo.k, hijo.costeT)
                    si cota > estPes entonces
                        cota <- estPes
                    fsi
                fsi
                
                hijo.asignados[i] <- false  // Se desmarca para explorar el siguiente hijo
                
            fsi
        fpara
    fmientras
ffun
#+end_example

#+begin_example
fun EstimacionOpt(costes: TTabla; pedido: TVector; k: entro; costeT: real): real
    var
        estimacion, menorC: real
        i,j: entero
    fvar
    
    estimacion <- costeT
    para i <- k+1 hasta n hacer
        
        // Se asigna a cada pedido el pastelero más eficiente
        //  para ese tipo de pastel
        
        menorC <- costes[1, pedido[i]]
        para j <- 2 hasta n hacer
            si menorC > costes[j,pedido[i]] entonces
                menorC <- costes[j,pedido[i]]
            fsi
        fpara
        
        estimacion <- estimacion + menorC  // Al coste total se le suma el coste
                                           //  estimado de cada pedido restante.
    fpara
    
    dev estimacion
ffun
#+end_example

#+begin_example
fun EstimacionPes(costes:TTabla; pedido:TVector; k:entero; costeT:real): real
    var
        estimacion,mayorC: real
        i,j: entero
    fvar
    
    estimacion <- costeT
    para i <- k+1 hasta n hacer
        
        // Se asigna a cada pedido restante el pastelero
        //  menos eficiente
        
        mayorC <- costes[1,pedido[i]]
        para j <- 2 hasta n hacer
            si mayorC < costes[j,pedido[i]] entonces
                mayorC <- costes[j,pedido[i]]
            fsi
        fpara
        
        estimacion <- estimacion + mayorC  // Al coste total se le suma
                                           //  la estimación pesimista.
        
    fpara
    dev estimacion
ffun
#+end_example

Coste $O(n!)$.

** El viajante de comercio
- Búsqueda de un ciclo hamiltoniano con un grafo pesado.
- Se busca obtener el ciclo hamiltoniano de menor peso.
- A la hora de podar soluciones tenemos la difcultad que no sabemos si la
  solución será completable hasta haber cerrado el ciclo. Por eso se evita la poda en esta versión.

#+begin_example
tipo TVectorB = matriz[1..n] de booleano
tipo TVector = matriz[1..n] de entero

tipo TNodo = registro
    ruta: TVector
    asignados: TVectorB
    k: entero
    costeT: real
    estOpt: real
fregistro

tipo TGrafo = matriz[1..n,1..n] de entero
tipo TVector = matriz[1..n] de entero

/**
 * @param grafo:TGrafo, matriz de conectividad del grafo.
 * @param ruta:TVector&, Secuencia de nodos que definen la mejor ruta.
*/
fun viajante(grafo:TGrafo; ruta:TVector&; costeTotal:entero)
    var
        monticulo:TMonticulo
        nodo,hijo:TNodo
        cota,estPes,verticeAnt,minArista:entero
    fvar

    monticulo <- CrearMonticuloVacio()
    minArista <- menorArista(grafo)
    costeTotal <- infty
    
    // Construimos el primer nodo
    nodo.ruta <- ruta
    nodo.asignados[1] <- cierto          // Primer nodo asignado a la ruta
    
    para i <- 2 hasta n hacer
        nodo.asignados[i] <- falso
    fpara

    nodo.k <- 1
    nodo.costeTotal <- 0
    nodo.estOpt <- EstimacionOpt(grafo, minArista, nodo.k, nodo.costeTotal)
    Insertar(nodo, monticulo)
    cota <- infty
    
    mientras !MonticuloVacio?(monticulo) && EstimacionOpt(Primero(monticulo)) < cota hacer
        nodo <- ObtenerCima(monticulo)
        
        // extensiones válidas de nodo
        
        verticeAnt <- nodo.ruta[nodo.k]
        hijo.k <- nodo.k + 1                    // siguiente paso
        hijo.ruta <- nodo.ruta                  // copia de parámetros
        hijo.asignados <- nodo.asignados
        
        para i <- 2 hasta n hacer
            si !hijo.asignados[i] && grafo[verticeAnt,i] != infty entonces

                // Si i no se ha asignado a la ruta y tiene conexión con el
                //  vértice anterior (k) entonces incluimos a i en la ruta.
            
                hijo.ruta[hijo.k] <- i
                hijo.asignados[i] <- true
                hijo.costeTotal <- nodo.costeTotal + grafo[verticeAnt,i]
                
                si hijo.k=n entonces

                    // Revisamos si i es una solución válida.

                    si grafo[i,1] != infty entonces

                        // Se comprueba si el último nodo tiene conexión con el primero.

                        hijo.costeTotal <- hijo.costeTotal + grafo[i,1]
                        si cota > hijo.costeTotal entonces
                            ruta <- hijo.ruta
                            costeTotal <- hijo.costeTotal
                            cota <- costeTotal
                        fsi
                    fsi
                sino
                    hijo.estOpt <- EstimacionOpt(grafo,
                                                 minArista,
                                                 hijo.k,
                                                 hijo,
                                                 costeTotal)
                    si hijo.estOpt < cota entonces
                        Insertar(hijo, monticulo)        // Insertamos una copia
                                                         // Notese que no hay estimación pesimista
                    fsi
                fsi
                hijo.asignados[i] <- falso   // Se desmarca la solución
            fsi
        fpara
    fmientras
ffun
#+end_example

#+begin_example
fun EstimacionOpt(grafo:Tgrafo; minArista:entero; k:entero; costeT:real): real
    estimacion:real
    estimacion <- costeT + (n-k+1) * minArista
    
    dev estimacion
ffun
#+end_example

** Selección de tareas: Cursos de formación

#+begin_example
tipo TVectorB=matriz[i..n] de booleano
tipo TVectorR=matriz[i..n] de real
tipo TVector=matriz[i..n] de entero
tipo TNodo = registro
    cursos: TVectorB
    k: entero
    beneficioT: real
    tiempoT: real
    estOpt: real
fregistro
#+end_example

#+begin_example
/**
 * @param beneficios: TVectorR, Beneficio del curso a impartir en cada empresa i.
 * @param tiempos:TVector, Duración del curso de cada empresa i.
 * @param limites:TVector, Tiempo límite de cada empresa i.
 * @param cursos: TVectorB, cursos seleccionados.
*/
fun Cursos(beneficios:TVectorR; tiempos,limites:TVector; cursos:TVectorB; beneficioT:real)
    var
        monticulo:TMonticulo
        nodo, hijo: TNodo
        cota, estPes: real
    fvar
    monticulo <- CrearMonticuloVacio()
    beneficioT <- 0

    // Primer nodo

    nodo.cursos <- cursos
    nodo.k <- 0
    nodo.tiempoT <- 0
    nodo.beneficioT <- 0
    nodo.extOpt <- EstimacionOpt(beneficios,
                                 tiempos,
                                 limites,
                                 nodo.k,
                                 nodo.tiempoT,
                                 nodo.beneficioT)
    Insertar(nodo, monticulo)
    cota <- EstimacionPes(beneficios,
                          tiempos,
                          limites,
                          nodo.k,
                          nodo.tiempoT,
                          nodo.beneficioT)
                          
    mientras !MonticuloVacio?(monticulo) && EstimacionOpt(Primero(monticulo)) >= cota hacer
        nodo <- ObtenerCima(monticulo)
        
        // Extensiones válidas del nodo

        hijo.k <- nodo.k + 1
        hijo.cursos <- nodo.cursos

        si nodo.tiempoT + tiempos[hijo.k] <= limites[hijo.k] entonces
            
            // El curso entra dentro de plazo y se actualiza la solución
            
            hijo.cursos[hijo.k] <- true
            hijo.beneficioT <- nodo.beneficioT + beneficios[hijo.k]
            hijo.tiempoT <- nodo.tiempoT + tiempos[hijo.k]
            hijo.estOpt <- nodo.estOpt      // En la estimación optimista ya se tiene
                                            //  en cuenta que todos los cursos que pueden
                                            //  incluirse se han incluido.
                                            // En el caso que la estimación optimista
                                            //  incluya un nodo que no se puede incluir
                                            //  por fechas, en ese caso no se entraría
                                            //  en esta sección de código.
            
            si hijo.k = n entonces

                // Una posible solución final

                si cota <= hijo.beneficio entonces
                    cursos <- hijo.cursos
                    beneficioT <- hijo.beneficioT
                    cota <- beneficioT
                fsi
            sino
            
                // Las estimaciones optimistas y pesimistas siguen siendo
                //  vigentes en este caso
                
                Insertar(hijo, monticulo)
            fsi
        fsi

        // Caso en el que no se imparte el curso
        // Hay que recalcular la estimación optimista, porque el nodo origen
        //  puede haber tenido en cuenta que este nodo entraba en la selección.

        hijo.estOpt <- ExtimacionOpt(beneficios,
                                     tiempos,
                                     limites,
                                     hijo.k,
                                     nodo.tiempoT,
                                     nodo.beneficioT)
                                     
        si hijo.estOpt >= cota entonces
            hijo.cursos[hijo.k] <- false
            hijo.beneficioT <- nodo.beneficioT
            hijo.tiempoT <- nodo.tiempoT
            
            si hijo.k = n entonces
                si cota <= hijo.beneficioT entonces
                    cursos <- hijo.cursos
                    beneficioT <- hijo.beneficioT
                    cota <- beneficioT
                fsi
            sino
                Insertar(hijo, monticulo)
                estPes <- EstimacionPes(beneficios,
                                        tiempos,
                                        limites,
                                        hijo.k,
                                        hijo.tiempoT,
                                        hijo.beneficioT)

                si cota < estPes entonces
                    cota <- estPes
                fsi
            fsi
        fsi
    fmientras
ffun
#+end_example

#+begin_example
fun EstimacionOpt(beneficios, tiempos:TVectorR, limites:TVector, k:entero, tiempoT:real, beneficioT:real): real
    var
        estimacion: real
        i: entero
    fvar
    estimacion <- beneficioT
    para i <- k+1 hasta n hacer
        si tiempoT + tiempos[i] <= limites[i] entonces
            estimacion <- estimacion + beneficios[i]
        fsi
    fpara
    dev estimacion
ffun
#+end_example

#+begin_example
fun EstimacionPes(beneficios, tiempos:TVectorR,
                  limites:TVector,
                  k:entero,
                  tiempoT:real,
                  beneficioT:real): real
    var
        estimacion,tiempo:real
        i:entero
    fvar
    estimacion <- beneficioT
    tiempo <- tiempoT
    para i <- k+1 hasta n hacer
        si tiempo + tiempos[i] <= limites[i] entonces
            estimacion <- estimacion + beneficios[i]
            tiempo <- tiempos + tiempos[i]
        fsi
    fpara
    dev estimacion
ffun
#+end_example

** Distancia de edición de una cadena de texto
#+begin_example
tipo TVectorCar = matriz[1..m+n] de TCadena
tipo TNodo = registro
    cadena:TCadena
    long:entero
    k:entero
    transf:TVectorCad
    costeT:entero
    estOpt:entero
fregistro
#+end_example

#+begin_example
fun DistanciaEdición(cadenaX, cadenaY:TCadena, n,m:enteros, transf:TVectorCad, costeT:entero)
    var
        monticulo:TMonticulo
        nodo,hijo:TNodo
        cota,estPes:entero
        listaN:Lista de Tnodo
    fvar

    monticulo <- CrearMonticuloVacio()
    costeT <- 0
    // Primer nodo
    nodo.cadena <- cadenaX
    nodo.long <- 0
    nodo.k <- 0
    nodo.costeT <- 0
    nodo.estOpt <- EstimacionOpt(n,m,nodo.k,nodo.costeT)
    Insertar(nodo, monticulo)
    cota <- EstimacionPes(n,m,nodo.k,nodo.costeT)

    mientras !MonticuloVacio?(monticulo) && EstimaciónOpt(Primero(monticulo)) <= cota hacer
        nodo <- ObtenerCima(monticulo)

        listaN <- Compleciones(cadenaY, n, m, nodo)
        mientras !ListaVacia(ListaN) hacer
            hijo <- Primero(ListaN)
            si hijo.k = m entonces
                si cota >= hijo.costeT entonces
                    transf <- hijo.transf
                    costeT <- hijo.costeT
                    cota <- costeT
                fsi
            sino
                hijo.estOpt <- EstimaciónOpt(hijo.long, m, hijo.k, hijo.costeT)
                Insertar(hijo, monticulo)
                estPes <- EstimacionPes(hijo.long, m, hijo.k, hijo.costeT)
                si cota > estPes entonces
                    cota <- estPes
                fsi
            fsi
        fmientras
    fmientras
ffun
#+end_example

#+begin_example
fun Compleciones(cadenaY:TCadena, n,m:enteros, nodo:TNodo): lista de TNodo
    var
        hijo:TNodo
        listaN:Lista de TNodo
    fvar
    listaN <- CrearLista()
    hijo.k <- nodo.k + 1

    hijo.cadena <- nodo.cadena
    hijo.transf <- nodo.transf

    si nodo.cadena[hijo.k] = cadenaY[hijo.k] entonces
        hijo.costeT <- nodo.costeT
        hijo.estOpt <- nodo.estOpt
        hijo.long <- nodo.long
        listaN <- Añadir(listaN, hijo)
    sino
        // Borrado
        si nodo.cadena[hijo.k+1]=cadenaY[hijo.k] entonces
            para i<-hijo.k hasta hijo.long-1 hacer
                hijo.cadena[i] <- hijo.cadena[i+1]
            fpara
            hijo.costeT <- nodo.costeT + costeBorrado
            hijo.transf[hijo.k] <- "borrado posición" + hijo.k
            hijo.long <- nodo.long - 1
            listaN <- Añadir(listaN, hijo)
        fsi
        
        // sustitución
        hijo.cadena <- nodo.cadena
        hijo.cadena[hijo.k] <- cadenaY[hijo.k]
        hijo.costeT <- nodo.costeT + costeSustitución
        hijo.transf[hijo.k] <- "sustituido posic" + hijo.k + "carácter" + cadenaY[hijo.k]
        hijo.long <- nodo.long
        
        // Inserción
        si nodo.long < m entonces
            hijo.cadena <- nodo.cadena
            para i <- hijo.long hasta hijo.k incremento -1 hacer
                hijo.cadena[i+1] <- hijo.cadena[i]
            fpara
            hijo.cadena[hijo.k] <- cadenaY[hijo.k]
            hijo.costeT <- nodo.costeT + costeInserción
            hijo.transf[hijo.k] <- "inserción posic" + hijo.k + "carácter" + cadenaY[hijo.k]
            hijo.long <- nodo.long + 1
            listaN <- Añadir(listaN, hijo)
        fsi
    fsi
    dev listaN
ffun
#+end_example

# TODO here

* Glosario
- *Recorrido postorden*, se recorre en profundidad [izquierdo, derecho, raiz]
- *Recorrido preorden*, Se recorre en profundidad [raiz, izquierdo, derecho]
- *Recorrido inorden*, Se recorre en profundidad [izquierdo, raiz, derecho]
- *Ciclo Hamiltoniano*, Camino que recorre todos los vértices de un grafo sin repetir ningún vértice y volviendo al vértice de salida.
