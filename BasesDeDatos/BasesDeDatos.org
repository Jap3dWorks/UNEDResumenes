#+title: Bases De Datos
#+author: Jordi Amposta Pérez

* Introducción
- *SGBD*, Sistema gestor de bases de datos, colección de datos interrelacionados y un conjunto de programas par acceder a dichos datos.
      - *Base de datos*, colección de datos que contienen información relevante.
        
** Aplicaciones de los sistemas de bases de datos
- Aplicaciones representativas
      - Información empresarial
            - ventas
            - Recursos humanos
            - Fabricación
            - Comercio en línea
      - Banca finanzas
            - Banca
            - Transacciones de tarjetas de crédito
            - Finanzas
      - Universidades
      - Líneas aéreas
      - Telecomunicaciones

** Propósitos de los sistemas de bases de datos
- Problemas de guardar la información en archivos convencionales.
      - *Redundancia e inconsistencia de los datos*
      - *Dificultad en el acceso a los datos*
      - *Aislamiento de los datos*, Se refiere a que los datos estén dispersos o incluso en diferentes formatos.
      - *Problemas de integridad*
      - *Problemas de atomicidad*, la operación ocurre o no ocurre.
      - *Anomalías en el acceso concurrente*, race conditions.
      - *Problemas de seguridad*, evitar usuarios con acceso a la totalidad de los datos.

** Visión de los datos
- El sistema oculta ciertos detalles del modo en que se almacenan y mantienen los datos.

*** Abstracción de datos
- *Nivel físico*, nivel más bajo de abstracción.
      - Describe en detalle las estructuras de datos complejas a bajo nivel.
- *Nivel lógico*, Describe qué datos se almacenan en la base de datos y que relaciones existen entre ellos.
      - *Independencia de los datos físicos*, no es necesario conocer la implementación física.
- *Nivel vistas*, Usuarios con acceso a una parte de los datos.
      - Simplifica la interacción con el sistema.
      - El sistema puede proporcionar muchas vistas de los datos.

*** Ejemplares y esquemas
- *Ejemplar*, colección de información alamcenada en la base de datos en un momento dado.
- *Esquema*, diseño general de la base de datos.
      - *Esquema físico*, describe el diseño a nivel físico.
      - *Esquema lógico*, describe el diseño a nivel lógico.
            - Usado en tareas de programación.
      - *Subesquemas*, esquemas de nivel vista.
- *Independencia física respecto de los datos*, Pueden efectuarse cambios en el nivel físico sin comprometer los datos.

*** Modelos de datos
- Bajo la estructura de las bases de datos se encuentra el *modelo de datos*, se trata de una colección de herramientas conceptuales para describir los datos, sus relaciones, su semántica y las restricciones de consistencia.
- *Modelo relacional*
      - Uso de tablas para representar datos y relaciones.
      - Más ampliamente utilizado.
- *El modelo entidad-relación* (E-R)
      - Se basa en los objetos básicos *entidades* y la relaciones entre ellos.
      - Se usa mucho en el diseño de base de datos.
- *Modelo de datos basado en objetos*
      - Extensión de E-R con encapsulación.
      - Influenciado por la programación orientada a objetos.
- *Modelo de datos semiestructurados*
      - Permite definir tipos en los que elementos individuales del tipo tengan diferentes atributos.
      - tipo XML.
- *Modelo de datos de red* y *modelo de datos jerárquico* casi no se usan.

** Lenguajes de bases de datos
*** Lenguaje de manipulación de datos (LDM)
- Permite acceder y manipular los datos.
- Tipos de acceso
      - Recuperación de información almacenada.
      - Inserción de información nueva.
      - Borrado de información de la base de datos.
      - Modificación de la información almacenada.
- Tipos de LDM
      - *LDM procedimentales*, Necesita que el usuario especifique qué datos y como obtener los datos.
      - *LDM declarativos*, El usuario especifica qué datos sin definir como obtenerlos.
- *Consulta*, instrucción que solicita recuperar información.
      - *Lenguaje de consultas*, parte del LDM para realizar consultas.

*** Lenguaje de definición de datos (LDD)
- Define los esquemas de la base de datos.
- *Lenguaje de almacenamiento y definición de datos*, subconjunto del LDD.
      - Estas instrucciones define los detalles de implementación de los esquemas.
- *Restricciones de consistencia*, Los valores almacenados deben satisfacer ciertas restricciones.
      - *Restricciones de dominio*, dominio de valores posibles a cada atributo.
      - *Integridad referencial*, valor de un atributo exista en un atributo de una entidad relacionada (creo que como el id).
      - *Asertos*, condiciones que la base de datos debe satisfacer siempre.
      - *Autorización*, diferenciación de acceso entre los ususarios.
            - Autorización de lectura.
            - Autorización de inserción.
            - Autorización de actualización.
            - Autorización de eliminación.
- El output del LDD suele almacenarse como metadatos en el *Diccionario de datos*.
      - Normamelte colo accesible por el propio sistema.

** Base de datos relacionales
- Representan los datos y la relaciones usando tablas.
- Incluyen un *LMD* y un *LDD*.
- Uso de *SQL*
- Modelo basado en registros.

*** Tablas
- Columnas son atributos y las filas los registros (las entradas).

*** Ejemplos SQL

Una consulta usando el LDM de SQL

#+begin_src sql
select profesor.nombre from profesor where profesor.nombre_depth="Historia"
#+end_src

Definir una tabla usando el LDD de SQL

#+begin_src sql
create table departamento (
  nombre_depth  char(20),
  edificio      char(15),
  presupuesto   numeric(12.2));
#+end_src

*** Acceso a las bases de datos desde programas de aplicación
- Operaciones complejas las efectuan los programas anfitrión (C/C++).
- Los programas de aplicación facilitan a los usuarios la interacción con la base de datos.
  
** Diseño de base de datos
*** Proceso de diseño
- Caracterizar completamente los requisitos de datos de los hipotéticos usuarios de la base de datos.
- Diseño conceptual, definir los datos y sus relaciones.
- Fase de diseño lógico, serelaciona el esquema conceptual con el modelo de implementación de datos.
- Fase de diseño físico, se especifican las características físicas de la base de datos.

*** El modelo entidad-relacion
- las entidades son un esquema de el conjunto de atributos que tendrá la entidad
      - Conjunto de entidades, conjunto entidades del mismo tipo
- La relación es un objeto que asocia varias entidades.
      - Conjunto de relaciones del mismo tipo
- Se usa notación UML ampliamente para describir el E-R

*** Normalización
- El objetivo es generar un conjunto de esquemas de relaciones que permita almacenar información sin redundancias innecesarias.
      - También debe permitir recuperar la información con facilidad.
- Se usa el enfoque de *Dependencias funcionales*.

** Almacenamiento de datos y consultas

*** Gestor de almacenamiento        
- Importante la estructura de los datos para que las consultas sean rápidas incluso en bases de datos muy grandes (terabytes).
- Traduce instrucciones LMD a comandos de bajo nivel del sistema de archivos del OS.
- Componentes
      - *Gestor de autorizaciones e integridad*
      - *Gestor de transacciones*
            - Garantiza que la base de datos queda en un estado consistente.
      - *Gestor de archivos*, gestiona la asignación de espacio de almacenamiento de disco.
            - También las estructuras de datos usadas.
      - *Gestor de memoria intermedia*, responsable de traer datos desde el memoria secundaria a memoria principal.
- Implementa varias estructuras de datos.
      - *Archivos de datos*, La base de datos en si misma.
      - *Diccionario de datos*, metadatos acerca de la estructura de la base de datos.
      - *Índices*, que pueden proporcionar acceso rápido a los datos.

*** Procesador de consultas
- Contiene
      - *Intérprete de LDD*.
      - *Compilador LMD*, para que lo entienda el motor de evaluación de consultas.
            - Se aplican optimizaciones, elige el plan de evaluación de menor coste.
      - *Motor de evaluación de consultas*, Ejecuta las instrucciones de bajo nivel generadas por el compilador LMD.

** Gestión de transacciones
- *Transacción*, Varias operaciones forman una unidad lógica de forma atómica.
- *Atomicidad*, ocurre o no ocurre, sin punto medio.
- *Recuperación de fallos*, detectar inconsistencias y restaurar el sistema a antes de los fallos.
- *El gestor de control de concurrencia* debe gestionar la interacción entre transacciones concurrentes.

** Arquitectura de bases de datos
- Pueden ser tipo cliente-servidor.
      - Servidores ejecutan los sistemas de bases de datos.
- Las bases de datos distribuidas se extienden por varias máquinas geográficament separadas.
- *Arquitectura dos capas*, el cliente invoca la funcionalidad del sistema que está en un servidor.
      - Usa instrucciones del lenguaje de consultas.
- *Arquitectura de tres capas*, El cliente no alberga llamadas a la base de datos
      - El cliente se comunica con un servidor de aplicaciones.
            - Aquí reside la lógica de negocio de la aplicación.
      - El servidor de aplicaciones se comunica con el sistema de base de datos.
      - Más adecuado par aplicaciones de gran tamaño.

** Minería y análisis de datos
- Análisis semiautomático de grandes bases de datos para descubrir patrones útiles.
- El conocimiento descubierto se represetna mediante un conjunto de reglas.
- Suele haber un preprocesado de los datos, preparación para los algoritmos.
- Suele haber un postprocesado de los patrones descubiertos.
- *Almacenes de datos*, Datos de distintas fuentes bajo un esquema unificado en un punto.
- *Recuperación de la información*, consulta de datos textuales no estructurados. 

** Bases de datos específicas
*** Modelos de datos basados en objetos
- E-R con nociones de encapsulación, métodos e identidad de objetos.

*** Modelos de datos semiestructurados
- Cada elemento de datos del mismo tipo puede tener atributos diferentes.
- XML, puede representar datos con estructura anidada.

** Usuarios y administradores de bases de datos
*** Usuarios de bases de datos e interfaces
- *Usuarios normales*, Interactuan con el sistema invocando algunos de los programas de aplicación.
- *Programas de aplicaciones*, Profesionales informáticos que escriben programas de aplicación.
- *Usuarios sofisticados*, Formulan consultas con un lenguaje de consultas o con herramientas software de análisis de datos.
- *Usuarios especializados*, Son usuarios sofisticados que escriben aplicaciones de bases de datos especializadas que no encajan en el marco tradicional del procesamiento de datos.

*** Administrador de bases de datos
- *ABD*, administrados de bases de datos, tiene el control central del sistema.
- Funciones del ABD
      - *Definición del esquema*, Crea el esquema central mediante instrucciones LDD.
      - *Definición de la estructura y del método de acceso*.
      - *Concesión de autorización para el acceso a los datos*.
      - *Mantenimiento rutinario*, Importante que el rendimiento no se degrade.
            - Copia de seguridad periodica.
            - Asegurarse de que se dispone de suficiente espacio en disco.
            - Supervisar los trabajos que se ejecutan en la base de datos y asegurarse de que el rendimiento no se degrade a causa de tareas muy costosas.

* Introducción al modelo relacional
** Estructura de las bases de datos relacionales
- Consiste en un conjunto de tablas.
- *Relación* es una tabla.
      - Corresponde al concepto *variable* en lenguajes de programación (pag 20 - 2.2).
- *Tupla* es una fila.
- *Atributo* es una columna.
      - *Dominio*, Conjunto de valores permitidos en un atributo.
      - Un *Dominio* es atómico si los elementos del dominio se consideran indivisibles.
            - por ejemplo 1 número de teléfono y no una lista de teléfonos.
      - Valor *null (nulo)* es especial. Significa valor desconocido o no existe.
- *Ejemplar de relación*, instancia específica de una relación.

** Esquema de la base de datos
- *Esquema de la base de datos*, es el diseño lógico.
      - *Esquema de la relación*, corresponde al concepto de definición de tipo.
- *Ejemplar de la base de datos*, instantánea de los datos de la base de datos en un momento dado.

** Claves
- No se permite que dos tuplas de una misma relación tengan exactamente los mismos valores en todos los atributos.
- *Superclave*, conjunto de uno o varios atributos que permiten identificar de manera unívoca una tupla de la relación.
      - Por ejemplo un atributo *ID*.
      - Si *K* es una superclave también lo es cualquier superconjunto que contenga a *K*.
      - *Claves candidatas*, superclaves mínimas.
      - *Clave primaria*, *clave candidata* elegida por el diseñador como media principal para identificar las tuplas de una relación.
            - Sus valores no deberían cambiarse nunca.
            - En un esquema de relación aparecen los primeros y subrallados.
- *Clave externa*, una *relación* puede incluir la *clave primaria* de otra *relación*.
      - *relación referenciante*, que incluye la clave primaria de otra relación.
      - *relación referenciada*, su clave primaria ha sido usada como *clave externa*
- *Restricción de integridad referencial*, requiere que los valores que aparecen en una *relacion referenciante* también aparezcan en almenos una tupla de la *relación referenciada*.

** Diagramas de esquema
- Representación gráfica del esquema de una base de datos.
      - Esquema de la base de datos junto con las dependencias de clave primaria y externa.
      - Solo se muestran las restricciones de clave externa.

** Lenguajes de consulta relacional
- *lenguaje de consulta*, lenguaje con el que los usuarios solicitan información de la base de datos.
      - *Lenguajes procedimentales*, el usuario indica al sistema una seria de operaciones para calcular el resultado deseado.
            - Algebra relacional
      - *Lenguajes no procedimentales*, el usuario describe la información deseada sin detallas el procedimiento para obtener información.
            - Cálcula relacional de tuplas
            - Cálculo relacional de dominios

** Operaciones relacionales
- Propio de los *lenguajes procedimentales*.
- Operaciones sobre una o dos relaciones que dan como resultado una nueva relación.
      - Así se pueden volver aplicar operaciones sobre la nueva relación.
      - Una operación común es la selección de tuplas concretas de una relación.
      - Otra es seleccionar algunos atributos de una relación.
      - La relación resultante podría contener tuplas duplicadas.
            - Caso común despues de una selección.
            - Algunos lenguajes de consultas eliminan las duplicidades.
      - *join* es una operación para combinar pares de tuplas de dos relaciones distintas.
            - *reunión natural*, La relación resultante contiene los pares de tuplas que coinciden el valor de uno de sus atributos, eligiendo qué atributo claro.
            - *producto cartesiano*, La relación resultante contiene todos los pares de tuplas posibles entre dos relaciones.
            - Las relaciones son conjuntos, por eso se puede aplicar *union*, *intersección* y *diferencia*.

* Introducción a SQL
** Componentes de SQL
- *LDD*, lenguaje de definición de datos.
- *LMD*, lenguaje interactivo de manipulación de datos.
- *Integridad*, el LDD puede especificar las restricciones de integridad. Las actualizaciones que violan la integridad se rechazan.
- *Definición de vistas*
- *Control de transacciones*, Se puede especificar el inicio y final de una transacción.
      - Creo que es que la transacción sea atómica.
- *SQL incorporado* y *SQL dinámico*, definen cómo se pueden incorporar instrucciones SQL en lenguajes de programación.
- *Autorización*
- Pueden haber diferencias entre distintas implementaciones del lenguaje SQL (MySql, PostgrSQL).

** Definición de datos de SQL
*** Tipos básicos (dominios)
- Tipos
      - *char(n)*, cadena de carácteres de longitud fija n.
            - Puede incluir espacios en blancos para completar la longitud de la cadena n.
      - *varchar(n)*, cadena de carácteres de longitud variable como máximo hasta n.
            - Se recomienda este tipo sobre *char*.
            - Las comparaciones char = varchar no tiene un comportamiento asegurado.
      - *int*
      - *smallint*
      - *numeric(p,d)*, Número de coma fija, cuya precisión la especifica el usuario.
            - *P* dígitos (con signo) de ellos *d* son decimales.
      - *real, double precision*, la precisión depende de la máquina.
      - *float(n)*, Número de coma flotante con precisión de almenos n dígitos.
- Todos los tipo incluten *null*.

*** Definición básica de esquemas
- *create table* Creación de relaciones.
  
#+begin_example
create table r
  (A1 D1,                         // A: atributo, D: dominio(tipo)
   A2 D2,
   ...
   An Dn,
   <restricción integridad 1>,
   ...
   <restricción integridad k>
   );
#+end_example

- Algunas restricciones de integridad
      - *primary key (Aj1, Aj2, ..., Ajm)*, Determina la clave primaria de la relación.
      - *foreign key (Ak1,..,Akn) references s*, (Ak1,...,Akn) debe coincidir con los atributos clave primarios de la relación *s*.
      - *not null*, no se permite el valor nulo para este parámetro.

- Manipulaciones de relaciones
      - *delete from r*; : Elimina todas las tuplas de r.
      - *drop table r*; : Elimina una relación de la base de datos.
      - *alter table r add A D;* : Añade atributos a una relación que ya existe.
      - *alter table r drop A;* : Elimina atributos de una relación que ya existe.
            - Algunas implementaciones no permiten esta operación.

#+caption: Ejemplo definición de datos
#+begin_src sql
create table departamento
(
nombre_dept varchar(20),
edificio    varchar(15),
presupuesto numeric(12,2),
primary key (nombre_depth)
);

create table asignatura
(
asignatura_id varchar(7),
nombre        varchar(50),
nombre_depth  varchar(20),
creditos      numeric(2,0),
primary key (asignatura_id),
foreign key (nombre_depth) references departamento
);
#+end_src              

** Estructura básica de consultas
*** Consultas sobre una relación única
#+begin_example
select [distinct | all] A1,...,An from r [where <predicados>];
#+end_example

- *distinct*, fuerza que no hayan valores duplicados en la consulta.

#+begin_src sql
select distinct nombre_dept from profesor;
#+end_src

- *all*, indica explícitamente que los duplicados no se eliminen.

#+begin_src sql
select all nombre_depth from profesor;
#+end_src  

- Puede contener expresiones aritméticas

#+begin_src sql
select ID, nombre, sueldo*1.1 from profesor;  -- Los valores de sueldo aparecerán
                                              --  multiplicados por 1.1
#+end_src  

- *where* permite seleccionar aquellas tuplas que cumplan cierto predicado.

#+begin_src sql
select nombre from profesor where nombre_depht='Informática' and sueldo > 70000;
#+end_src  

*** Consultas sobre varias relaciones
#+begin_example
select A1,...,An from r1,..,rm where P
#+end_example

#+begin_src sql
select nombre, profesor.nombre_depth, edificio  -- profesor.nombre_depth identifica
                                                --  el atributo nombre_depth de forma unívoca.
from profesor, departamento
where profesor.nombre_depth = departamento.nombre_depth;
#+end_src

- *from* se defina a si misma como el producto cartesiano de las relaciones indicadas (pag31).
- Pasos generales de una Consulta
      1) Genere el producto cartesiano de la cáusula *from*.
      2) Aplique los predicados indicados en la cláusula *where*.
      3) Para cada tupla del paso 2 estraiga los atributos indicados en la cláusula *select*.
- Las implementaciones reales optimizan los pasos teóricos anteriores.

*** La union natural
#+begin_example
select A1,..,An from r1 natural join r2 ... natural join rm where P;
#+end_example

- *La unión natural* opera sobre dos relaciones y genera como resultado una relación.
      - Concatena tuplas en función si comparten mismos valores en atributos comunes.
            - No se realiza el producto cartesiano.

#+begin_src sql
select nombre, asignatura_id from profesor natural join enseña;
#+end_src

- *join r using (A1,...,An)*, permite comparar los valores de solo algunos atributos en común.

#+begin_src sql
select nombre,nombre_asig
from (profesor natural join enseña)
join asignatura using (asignatura_id); -- solo se tendrá en cuenta los valores
                                       --  del atributo en común asignatura_id
                                       --  enseña.asignatura_id = asignatura.asignatura_id
#+end_src  

** Operaciones básicas adicionales
*** Operación de renombrado
- pag 34

#+begin_src sql
select T.nombre as nombre_profesor, asignatura_id
from profesor as T, enseña as S
where T.ID = S.ID
#+end_src  

- Para hacer el producto cartesiano sobre la misma relación.

#+begin_src sql
-- Profesores con el sueldo mayor que el sueldo
--  de almenos un profesor de biología.
select distinct T.nombre
from profesor as T, profesor as S
where T.sueldo > S.sueldo and s.nombre_depth = 'Biología';
#+end_src

*** Operaciones con cadenas de carácteres
- La norma SQL es case sensitive, 'a' = 'A' se evalua falso.
      - Algunas implementaciones no siguen esta norma por defecto, es el caso de MySql.
- Operaciones obre cadenas
      - upper
      - lower
      - trim
      - || : concatenación
      - *like* : comparaciones usando patrones
            - % : coincide con cualquier subcadena.
            - _ : coincide con cualquier carácter.
            - \ : para escapar carácteres especiales.
      - *not like* : comparaciones usando patrones pero negadas.
      - *similar to* : comparaciones pero con expresiones regulares.

#+begin_src sql
select nombre_depth
from departamento
where edificio like '%Watson%'
#+end_src

*** Especificación de atributos en la cláusula Select

- *** : se puede usar en la cláusula *select* para indicar todos los atibutos.

#+begin_src sql
select profesor.*
from profesor,enseña
where profesor.ID = enseña.ID;
#+end_src

*** Orden en la presentación de las tuplas
- *order by* : hace que las tuplas se presenten con un criterio de orden.
  
#+begin_src sql
select nombre
from profesor
where nombre_depth = 'Fisica'
order by nombre;                -- alfabetico
#+end_src

- Se puede especificar *asc* o *desc*.
  
#+begin_src sql
slect *
from profesor
order by sueldo desc, nombre asc;  -- primero por sueldo descendente y ante las colisiones
                                   --  por nombre ascendente
#+end_src

*** Predicados de la cláusula where
- *between* : dentro de un rango.
#+begin_src sql
select nombre
from profesor
where sueldo between 90000 and 100000;
#+end_src

- *not between* : between negado.

- Comparación con listas de forma lexicográfica
  
#+begin_src sql
select nombre,asignatura_id
from profesor,enseña
where (profesor.ID, nombre_depth) = (enseña.ID, 'Biología');
-- equivale a profesor.ID = enseña.ID and nombre_depth = 'Biología'
#+end_src

** Operaciones sobre conjuntos
- *union* $\cup$, *intersect* $\cap$ y *except* -.

*** Operación union  
- *union* : unión entre dos relaciones.
      - Elimina duplicados automáticamente.
      - *union all* mantiene duplicados.
  
#+begin_src sql
(select asignatura_id
from sección
where semestre = 'Otoño' and año=2009)
union
(select asignatura_id
from sección
where semestre = 'Primavera' and año=2010);
#+end_src

*** Operación Intersección
- *intersect* : intersección entre dos relaciones.
      - Elimina duplicados.
      - *intersect all* para mantener duplicados.

#+begin_src sql
(select asignatura_id
from sección
where semestre='Otoño' and año=2009)
intersect
(select asignatura_id
from sección
where semestre='Primavera' and año=2010);
#+end_src

*** Operación except
- *except* : la substracción.
      - Elimina duplicados.
      - *except all* mantiene duplicados.

#+begin_src sql
(select asignatura_id
from sección
where semestre = 'Otoño' and año=2009)
except
(select asignatura_id
from sección
where semestre = 'Primavera' and año=2010)
#+end_src

** Valores nulos
- El resultado de las operaciones aritméticas es nulo si cualquiera de los valores de entrada es nulo.
- *unknown* : tercer valor lógico (junto a true false) para comparaciones con null.
      - 1 < null  -->  unknown.
      - true and unknown  --> unknown
      - false and unknown --> false
      - unknown and unknown --> unknown
      - true or unknown  -->  true
      - false or unknown  -->  unknown
      - unknown or unknown  -->  unknown
      - not unknown  -->  unknown        
- *is null* y *is not null* : Operacion booleana para identificar valores null.

#+begin_src sql
select nombre
from profesor
where sueldo is null;
#+end_src

- En *select distinct* ('A',null)=('A',null) (solo se mantiene una copia) aunque null=null --> unknown.

** Funciones de agregación
- *avg* : Media (numérico)
- *min* : minimo
- *max* : máximo
- *sum* : total suma (numérico)
- *count* : recuento
  
*** Agregación básica

- Resultados con una única tupla

#+begin_src sql
select avg (sueldo) as med_sueldo
from profesor
where nombre_dept = 'Informática';
#+end_src

#+begin_src sql
select count(distinct ID)
from enseña
where semestre='Primavera' and año=2010;
#+end_src

*** Agregación con agrupamiento
- pag 39
- *group by*

#+caption: El sueldo medio de cada departamento  
#+begin_src sql
select nombre_dept, avg(sueldo) as med_sueldo
from profesor
group by nombre_depth;
#+end_src  

#+caption: Número de Profesores de cada departamento que enseño algo
#+begin_src sql
select nombre_dept, count(distinct ID) as prof_cuenta
from profesor natural join enseña
where semestre='Primavera' and año=2010
group by nombre_depth;  -- Deben estar presentes los atributos
                        --  que aparecen fuera de la agregación
#+end_src

*** Cláusula having
- pag 39
- *having* : Predicados que se aplican a grupos.

#+begin_src sql
select nombre_dep, avg(sueldo) as med_sueldo
from profesor
group by nombre_dept
having avg(sueldo) > 42000;
#+end_src  

- Combinado con *where*.

#+begin_src sql
select asignatura_id, semestre, año, secc_id, avg(tot_créditos)
from matricula natural join student
where año=2009
group by asignatura_id, semestre, año, secc_id
having count(ID) >= 2;
#+end_src

*** Agregación con valores nulos y valores booleanos
- todas excepto *count* ignoran los null.

** Subconsultas anidadas
*** Pertenencia a conjuntos
- *in* : pertenencia a un conjunto.
      - También existe *not in*.
  
#+begin_src sql
select distinct asignatura_id
from sección
where semestre='Otoño' and año=1009 and
  asignatura_id in (select asignatura_id
                    from sección
                    where semestre='Primavera' and año=2010);
#+end_src



* Tools
** Create podman container
#+begin_src sh
podman pull docker.io/library/mysql:8.0
#+end_src
