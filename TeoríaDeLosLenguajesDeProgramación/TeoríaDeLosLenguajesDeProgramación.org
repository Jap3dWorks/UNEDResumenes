#+title: Teoría de los lenguajes de Programación
#+author: Jordi Amposta Pérez

#+startup: latexpreview

* Paradigmas de computación
- Generaciones Lenguajes Programación
      - Primera generación lenguajes máquina.
      - Segunda generación ensambladores (mnemotécnico del lenguaje máquina).
      - Tercera generación lenguajes de alto nivel como C
            - Lenguajes de propósito general.
            - Requieren compiladores o intérpretes.
      - Cuarta generación lenguajes de propósito específico como SQL.
      - Quinta generación, muy relacionada con el área de la Inteligencia Artificial.
            - Se especifica el problema y como se resuelve con una secuencia de acciones.
            - Prolog y Haskel.

** Abstracción en los lenguajes de rogramación
- Abstracción de datos y de control

| *Abstracción*  | *De Datos*                    | *De Control*                        |
|--------------+-----------------------------+-----------------------------------|
| *Básica*       | Tipos atómicos de variables | goto                              |
| *Estructurada* | tipos estructurados         | bucles condicionales subprogramas |
| *Unitaria*     | módulos paquetes            | módulos paquetes                  |

*** Abstracción de Datos
- Abstracciones de datos básicas
      - *Tipos atómicos*, tipos que no pueden dividirse en tipos más sencillos.
      - Nombres de variables son una abstracción.
- Abstracciones de datos estructuradas
      - Arrays
      - En C el typedef int MyTable[7]; Crea un tipo de dato estructurado.
- Abstracciones de datos unitarias
      - Agrupación de datos y operaciones sobre ellos.
      - Encapsulado de datos
      - Clases, Tipos abstractos, interfaces.

*** Abstracción de Control
- Abstracciones de Control básicas
      - Sentencias para modificar el flujo de ejecución.
      - goto
- Abstracciones de control estructuradas.
      - Bucles o sentencias condicionales (if)
      - Permiten anidamiento
      - Subprogramas (funciones, métodos, procedimientos)
- Abstracciones de control tipo unitario
      - Colección de subprogramas en una unidad en si misma independiente del programa.
        
** Introducción a los paradigmas de computación
- Inicialmente los lenguajes se basaron en el *modelo de computación Von Neumann*.
      1. Ejecución secuencial de instrucciones.
      2. Variables representan posiciones de memoria.
      3. Asignación para cambiar el valor de las variables.
- También se conocen como *Lenguajes Impertarivos*, paradigma imperativo.
- paradigmas
      - Imperativo
            - Programación oritendata a objetos.
      - Declarativo
            - Funcional, abstracción de funciones matemáticas.
            - Lógico

*** Programación orientada a objetos
- *Objeto*, conjunto de posiciones en memoria más las operaciones sobre los valores que almacenan dichas posiciones.

*** Programación funcional
- Evaluación de funciones.
      - Transferencia de valores como parámetros de las funciones que se evaluan.
      - Generación de resultados en forma de valores devueltos por las funciones.
- No involucra la asignación de una variable a una posición de memoria.
- Operaciones repetitivas mediante funciones recursivas.
      - Operaciones repetitivas NO se representan mediante ciclos.

#+caption: Ejemplo en Haskell        
#+begin_src haskell
gcd u v
    v == 0 -> u
    otherwise -> gcd v (mod u v)

gcd 18 8
#+end_src

*** Programación lógica
- Conjunto de sentencias que describen lo que es verdad o conocido.
- El control lo aporta el modelo de inferencia lógica.

#+begin_src prolog
gcd(U, 0 , U).
gcd(U, V, X) :- not (V=0),
                Y is U mod V,
                gcd(V, Y, X).
#+end_src

Busca el valor de X que hace cierta la siguiente pregunta.

#+begin_src prolog
?- gcd(18,8,X).
#+end_src

** Descripción de los lenguajes de programación
- Elementos fundamentales
      - *Léxico* o tokens (if, else)
      - *Sintáxis*, Estructura de los diferentes componentes del lenguaje y sus combinaciones.
            - Se pueden describir con el uso de gramaticas libres de contexto.
            - 
              #+caption: Sentencia if de C
              #+begin_example
              <sentencia if> ::= if (<expresion>) <sentencia> [else <sentencia>]
              #+end_example

      - *Semántica*, expresa los efectos de la ejecución en un contexto determinado.
            - Sistemas de notación de la semántica (no hay una forma aceptada).
                  - *Semántica operacional*
                  - *Denotacional*
                  - *Axiomática*

*** Traducción de los programas para su ejecución
- *Intérprete*, Un programa que acepta entradas del lenguaje y los ejecuta.
- *Compilador*, Programa que traduce el languaje a código máquina.
- El traductos (intérprete o compilador) debe seguír fielmente la definición del lenguaje.
- Pasos de un intérprete o compilador.
      - *Analizador léxico*
      - *Analizador sintáctico*
      - *Analizador semántico*
- Tipos de errores
      - *Errores léxicos*, Suele estar kimitado al uso de carácteres ilegibles.
      - *Errores sintácticos*, Tokens que faltan o expresiones malformadas.
      - *Errores semánticos*, Estáticos (uso de tipos incompatibles) o dinámicos (división por 0).
      - *Errores lógicos*, Comportamiento no deseado.

** Diseño de los lenguajes de programación
- Control de la complejidad.
- Legibilidad a la par que facil traducción a lenguaje máquina.

*** La eficiencia
- El diseño debe permitir al traductor la generación de código ejecutable eficiente.
- *Eficiencia de traducción*, El lenguaje debe permitir el desarrollo de un traductor eficiente y de tamaño razonable.
- *Eficiencia de implementación*, Eficiencia con la que puede escribirse un traductor.
- *Eficiencia de la programación*, Rapidez y facilidad para escribir programas.
      - Capacidad expresiva.
      - *Sintactic sugar*, estructuras que facilitan la escritura de un programa.
            - Por ejemplo las diferentes versiones de bucles.

*** La regularidad
- Comportamiento de las características del lenguaje.
- *La Generalidad*, uso y disponibilidad de constructores no están sujetas a casos especiales.
- *La Ortogonalidad*, Los constructores del lenguaje pueden admitir combinaciones significativas, sin restricciones ni comportamientos inesperados.
- *La uniformidad*, Consistencia entre la apariencia y el comportamiento de los constructores.

*** Principios Adicionales
**** Simplicidad
- Que cada concepto del lenguaje se presente de forma única y legible.
- Estructuras con reglas de combinación sencillas.

**** Expresividad
- Facilidad con la que un lenguaje de programación permite expresas procesos y estructuras complejas.

**** Extensibilidad
- Ampliar el lenguaje con nuevas funcionalidades (nuevos tipos, etc).
- *Modularidad*, disponer de bibliotecas.

**** Capacidad de restricción
- El uso suficiente de un subconjunto del lenguaje.

**** Consistencia entre la notación y las convenciones
- Notaciones y características que ya se hayan convertido en estándares.

**** Precisión
- Definición precisa del lenguaje, de forma que los programas sean predecibles.
      - El programa se comporta igual en cualquier máquina.

****  Portabilidad
- La definición del lenguaje de programación es independiente de una máquina en particular.
- Normalmente los lenguajes interpretados son portables.

**** Seguridad
- Este principio pretende evitar los errores de programación y permitir su descubrimiento.
- A veces compromete la expresividad.

**** Interoperabilidad
- La posibilidad de que un código escrito en un lenguaje interactue con el código escrito en otro lenguaje.

* Programación Funcional
- Diferente a la programación imperativa.
      - No tan cercano al hardware.
- *Currificación*, devolver una función desde otra función, aprovechando para reducir el número de parámetros.

**  Programas como funciones
- Un programa funcional contiene funciones definidas por el programador.
      - El programador no se preocupa cómo se realiza el cálculo.
- Las variables no hacen referencia a posiciones en memoria.
- No existe la asignación.
- Sentencias del tipo $x=x+2$ no son válidas.
- Una constante puede ser considerada una función sin parámetro.
- Desaparecen los bucles, en su lugar se hace uso de la *recursión*.
- No existe *estado del cómputo*.
- En programación funcional un programa consiste en la definición matemática de una seria de funciones que toman unos argumentos de entrada y realizan un cómputo sobre ellos.

Ejemplo función factorial en C y en Haskell  

#+begin_src c
int factorial(int n) {
    int f = 1;
    for (int x=1; x <=n; x++) {
        f = f*x;
    }
    return f;
}
#+end_src  

#+begin_src haskell
factorial n
  n <= 0 = 1                       -- definición si n <= 0
  otherwise = n * factorial(n-1)   -- definicinón en otro caso
#+end_src

- Las funciones son ciudadanos de primera clase.
      - Pueden devolverse desde otra función.
      - Pueden pasarse como parámetro.

#+begin_src haskell
suma3 x = x  3
funCuadrado f x = f x * f x

funCuadrado suma3 5
#+end_src

#+RESULTS:

** Evaluación Perezosa
- Se evalua el valor de un parámetro solo cuando se usa.
- función *no estricta*, no necesita conocer el valor de todos sus parámetros para devolver un resultado.
- *memoización*, permite guardar el valor de un parámetro la primera vez que se evaluó.

Ejemplo con listas de haskell.

#+begin_example
[1..]      -- Define una lista de todos los números Naturales desde el 1
1:[2..]    -- Se evalua el primer elemento (lista tipo cabeza cola)
1:2:[3..]
#+end_example

- Permite programar funciones *productoras* y funciones *consumidoras*.

#+begin_src haskell
-- los valores se irán calculando a medida que se acceden
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
#+end_src  

** Introducción a Haskell
- Case sensitive
  
*** Tipos de datos
- Los tipos se escriben en PascalCase
- *Tipos atómicos*
      - *Int*, enteros ligados a la arquitectura del ordenador (acotados).
      - *Integer*, conjunto de números enteros sin ningún límite.
      - *Float*, reales de precisión simple.
      - *Double*, reales de precisión doble.
      - *Char*, carácteres ACII-7.
      - *Bool*, booleanos, True o False.
- *Tipos estructurados*
      - *Tupla*,secuencia finita de valores, pueden tener tipos diferentes.
            - `(4,"vacio", False)`
      - *Lista*, una colección no necesariamente finita de valores del mismo tipo
            - Las cadenas de carácteres son listas de [Char].
            - Son estructuras recursivas cabeza:cola:..:[].
            - *Listas definidas por extensión*
                  - [1,2,3]
                  - [1,3..10]
                  - [1,3..]
            - *Listas definidas por comprensión*
                  - [p | p <- [1..], mod p 2 /=0 ]

*** Definición de Funciones
- Dos formas de definirse
      - *Identificador* una palabra que empiezan siempre en *minúscula*.
            - Puede contener ' _ entre otros símbolos.
            - Se usan de forma *prefija*
            - Se puede usar de forma *infija* usando `
                  - 3 `suma` 4
      - *Operadores*, secuencia de uno más de los siguientes carárcters
            - : ! # $ % * + . / < + > ? @ \ ^ | -
            - Las siguientes combinaciones tienen un uso especial.
                  - :: = .. @ \ | <- -> ~ =>
            - Se utilizan de forma *infija* (exactamente 2 parámetros de entrada).
            - Se pueden usar de forma *prefija* con el uso de ().
                  - (+) 3 4
- *precedencia* y *asociatividad*
      - Se asigna un valor de *precedencia* a cada función (más alto mejor).
      - funciones definidas con *identificador* tiene más precedencia que las definidas por *operador*.
            - f x + 1 sería (f x) + 1

Definir reglas de precendencia y asociatividad.

#+begin_src haskell
asociatividad precedencia lista_de_operadores
-- asociatividad: infixr (derecha), infixl (izquierda), infix (no asocian)
-- precedencia: entre 0 y 9
-- lista_de_operadores: símbolos de operador separados por ,

-- ejemplo de suma y resta

infixl 6 +,-      -- e.g 3 - 5 - 2 = (3 - 5) - 2
#+end_src              

**** Definición ecuacional y encaje de patrones
#+begin_example
identificador <patron1> <patron2> ... <patronN> = <expresión>
#+end_example

- *patron*, Como argumentos de entrada de cada función.
      - Más versatil que un simple argumento.
- Una función puede definirse con más de una ecuación.

***** Patrones Constantes
#+begin_src haskell
f 1 = True
f 2 = False
#+end_src

Cualquier otro valor de entrada generaría un error.

***** Patrones Variables
#+begin_src haskell
suma x y = x + y
#+end_src

***** Patrones anónimos
Se representan con _, no pueden ser referenciados.

#+begin_src haskell
siempre2 _ = 2
#+end_src

***** Patrones para listas
- [], lísta vacía (patrón constante).
- [x], lista con un único elemento referenciado como x.
- (x:xs), lista con un elemento de cabeza x y una cola xs.

#+begin_src haskell
suma [] = 0
suma (x:xs) = x + suma xs
#+end_src

***** Patrones para tuplas
Se referencian entre paréntesis, eg. (x,y,z).

***** Patrones con nombre
#+begin_src haskell
duplicaCabeza l@(x:xs) = x:l
#+end_src

***** Patron aritmético
La siguiente definición substrae 3 del valor de entrada. Están deprecados.
#+begin_src haskell
f (n + 3) = n
#+end_src

**** Expresiones case
#+begin_src haskell
case expresion of
  patron1 -> resultado1
  patron2 -> resultado2
  -- ...
  patronN -> resultadoN
#+end_src

**** Funciones definidas a trozos
#+begin_example
identificador <lista_de_patrones>
  | guarda1 = expresion1
  -- ...
  | guardaN = expresionN
#+end_example

- Las guardas son expresiones tipo *Bool*.
- Se devuelve el valor de la primera guarda con valor *True*.

#+begin_src haskell
abs x
  | x >= 0 = x
  | x < 0  = -x
#+end_src

Usando *otherwise*, si no se cumple ninguna guarda.

#+begin_src haskell
abs x
  | x >= 0 = x
  | otherwise = -x
#+end_src

**** Definiciones locales
#+begin_example
definición_de_la_funcion
  where
    subfuncion1
    ...
    subfuncionN
#+end_example

#+begin_src haskell
f x y = (a+1) * (c-1)
  where
    a = div (x+y) 2
    c = mod (x+y) 2
#+end_src

- Permite usar patrones en cualquier punto de una expresión.

#+begin_example
let definición in expresión
#+end_example

Por ejemplo

#+begin_src haskell
let a x = x + 1 in a 100
#+end_src

**** Funciones anónimas
- Expresiones lambda

#+begin_src haskell
esPar x = mod x 2 == 0
#+end_src

En expresión anónima sería.

#+begin_src haskell
(\x -> mod x 2 == 0) 4
#+end_src

**** La función error
- Detiene la ejecución y muestra un mensaje informativo

#+begin_src haskell
divide a 0 = error "No se puede dividir por 0"
divide a b = a / b  
#+end_src

*** El tipo de las funciones
#+begin_example
identificador :: expresionDeTipo
#+end_example

- Muy similar a la notación matemática $f: \mathbb{R} \to \mathbb{R}$

#+begin_src haskell
doble :: Float -> Float

doble x = 2*x
#+end_src  

**** Polimorfismo
- Funciones con una definición para varios tipos de datos.

**** Currificación de funciones y aplicación parcial
#+begin_src haskell
suma :: Float -> Float -> Float
suma x y = x + y  
#+end_src

El operador -> asocia a la derecha, por tanto.

#+begin_example
suma :: Float -> Float -> Float
-- realmente se aplica la currificación
suma :: Float -> (Float -> Float)
#+end_example  

- Función definida por *aplicación parcial*.

#+begin_src haskell
suma3 :: Float -> Float
suma3 = suma 3  
#+end_src

**** Funciones de orden superior
- Funciones que reciben como parámetro de entrada otras funciones.

#+begin_src haskell
aplica f x y = f x y
#+end_src  

*** Tipos de datos avanzados
**** El valor indefenido: Bottom
- /undefined/ representa un valor indefenido de cualquier tipo.

**** Sinónimos de tipos: type
- Definición de un nuevo nombre para un tipo que ya existe.

#+begin_src haskell
type Caracter = Char
type String = [Caracter]
#+end_src

#+begin_src haskell
type Complex = [Double, Double]
a :: Complex
a = (3.4, 2.5)
#+end_src

**** Definición de nuevos tipos de datos: data
***** Tipos enumerados
Deben empezar con mayúscula.

#+begin_src haskell
data Semaforo = Rojo | Amarillo | Verde
  deriving (Eq,Ord,Show,Read)   -- Deriva de estas clases
#+end_src

- Clases más usadas como deriving.
      - Eq, permite comparar elementos.
      - Ord, establece una relación de orden entre los elementos.
      - Show, permite que el intérprete pueda mostrar un valor de este tipo.
      - Read, permite convertir cadenas de texto en elementos del tipo.
            - read "Rojo"::Semaforo , crea el elemento rojo del tipo Semáforo.

***** Unión de tipos
:PROPERTIES:
:ID:       a8e2199b-13a0-421a-9c31-cdd5cac0feff
:END:

Permite agrupar en un único tipo elementos de dos tipos diferentes.

#+begin_src haskell
data BooleanoEntero = Booleano Bool | Entero Integer

listaMixta :: [BooleanoEntero]
listaMixta = [Entero 0, Booleano True, Booleano False, Entero -1]  
#+end_src

***** Producto Cartesiano

#+begin_src haskell
data Asignatura = Asig String Integer String
#+end_src

Más similar a un tipo registro.

#+begin_src haskell
data Asignatura = Asig { nombre :: String, curso :: Integer, web :: String }
#+end_src

Definición de una función constante.

#+begin_src haskell
tlp = Asig { nombre = "Nombre", curso=2, web="una web" }
#+end_src

Y para acceder a uno de los atributos podemos hacer.

#+begin_src haskell
esDePrimero x = curso x == 1
#+end_src

***** Tipo de datos recursivos

#+begin_src haskell
data Natural = Cero | Sucesor Natural
#+end_src

Parece similar a una [[id:a8e2199b-13a0-421a-9c31-cdd5cac0feff][Unión de tipos]].

Luego puede escribirse.

#+begin_src haskell
uno = Sucesor Cero
dos = Sucesor uno
tres = Sucesor dos
#+end_src

Función mayor que.

#+begin_src haskell
mayor (Sucesor _) Cero = True              -- Aquí (Sucesor _) acepta un elemento
                                           --  con una capa de (Sucesor )
mayor Cero _ = False
mayor (Sucesor x) (Sucesor y) = mayor x y  -- Los patrones de entrada eliminan
                                           --  una capa de (sucesor )
#+end_src

***** Tipos polimórficos
- Puede contener valores de cualquier tipo.
      - Como una lista genérica por ejemplo.

#+begin_src haskell
data TipoMixto a b = Tipo a | Tipo b
type BooleanoEntero = TipoMixto Bool Integer
#+end_src        

*** Ejemplos de funciones: trabajando con listas
**** Contar elementos de una lista
#+begin_src haskell
length [] = 0
length (x:xs) = 1 + length xs
#+end_src

**** Concatenar listas
- Listas del mismo tipo

#+begin_src haskell
[] ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)
#+end_src  

- Aplanar una lista de listas

#+begin_src haskell
concat [] = []
concat (xs:yss) = xs ++ (concat yss)
#+end_src

**** Combinar listas
- Operación zip.

#+begin_src haskell
zip (x:xs) (y:ys) = (x,y):(zip xs ys)  -- El orden afecta a la evaluación
                                       --  la definición que aparece antes
                                       --  será seleccionada antes si se puede.
zip _ _ = []  
#+end_src

- Operación unzip.

#+begin_src haskell
unzip xs = unzipAux xs ([],[])
  where
    unzipAux [] acumulador = acumulador
    unzipAux ((a,b):xs) (as,bs) = unzipAux xs (as ++ [a], bs ++ [b])
#+end_src

**** Aplicar una función a los elementos de una lista
- función *map*.

#+begin_src haskell
map _ [] = []
map f (x:xs) = (f x) : (map f xs)
#+end_src

- Ejemplo de uso para calcular x*x de cada elemento de una lista.

#+begin_src haskell
map (\x -> x*x) [1..10]
#+end_src

- *zipWith*, como map pero con dos listas

#+begin_src haskell
-- El orden de declaración es importante
zipWith f (a:as) (b:bs) = (f a b) : (zipWith f as bs)
zipWith _ _ _ = []  
#+end_src  

- *iterate*, para crear listas infinitas

#+begin_src haskell
iterate f x = x : (iterate f (f x))  -- En este caso la memoización de haskell
                                     --  permite que sea eficiente

potencias2 = iterate (2*) 1
#+end_src  

**** Filtros sobre listas
- *take* y *drop*

#+begin_src haskell
take _ [] = []
take n (x:xs)
  | n <= 0 = []
  | otherwise = x : take (n-1) xs
#+end_src

#+begin_src haskell
drop _ [] = []
drop n (x:xs)
  | n <= 0 = (x:xs)
  | otherwise = drop (n-1) xs
#+end_src

- *filter*

#+begin_src haskell
filter _ [] = []
filter p (x:sx)
  | p x = x : (filter p xs)
  | otherwise = filter p xs
#+end_src  

- *takeWhile* y *dropWhile*

#+begin_src haskell
takeWhile _ [] = []
takeWhile p (x:xs)
  | p x = x : takeWhile p xs
  | otherwise = []
#+end_src

#+begin_src haskell
dropWhile _ [] = []
dropWhile p ys@(x:xs)  -- @ patrones con nombre
  | p x = dropWhile p xs
  | otherwise = ys
#+end_src

**** Listas por comprensión
#+begin_example
[ expresión | cualificador1, ... , cualificadorn ]
#+end_example

- Donde
      - *expresión*, define la forma de los elementos de la lista resultado.
      - *cualificadores*, definen propiedades de los elementos.
            - *generadores*, expresiones que permiten generar una lista.
            - *filtros*, expresiones booleanas para filtrar elementos.
            - *definiciones locales*, define elementos locales dentro de la definición de la lista.
                  - Se usa la palabra reservada *let*.

#+caption: Lista números impares                    
#+begin_src haskell
[p | p <- [2..], mod p 2 /= 0 ]  -- números impares, /= not equal
#+end_src                    

- Ejemplo de lista con números primos.
  
#+begin_src haskell
divisores n = [ d | d <- [1..n] , mod n d == 0 ]
primos  = [ p | p <- [2..] , divisores p == [1,p]]
#+end_src

**** Plegado de listas
- *foldr*  (right) y *foldl* (left)

#+begin_src haskell
-- z es el caso base
foldr f z [] = z
foldr f z (x:xs) = f x (foldr f z xs)
-- z es el caso base
foldl f z [] = z
foldl f z (x:xs) = foldl f (f z x) xs
#+end_src

#+begin_src haskell
suma = foldr (+) 0
concat = foldr (++) []
#+end_src

* Programación lógica


* Glosario
- *Evaluación impaciente*, /factorial(4*5)/ primero evalua el resultado de 4*5.

* Tools
** Haskell compiler and interpreter
#+begin_src sh
ghci       # Open the haskell interpreter
#+end_src
