#+title: Ingeniería Computadores III
#+startup: latexpreview

* Fundamentos del diseño del hardware digital
- *HDL (hardware description languaje)*, lenguaje para la descripción del Hardware.
- *VHDL*, VHSIC Hardware Description Language
      - Very High Speed Description Langage

** Pasos del diseño de un circuito integrado
# TODO gráfico

** HDL más usados
- *Verilog* HDL, 
- *VHDL*
- SystemC, basado en C++

** Tecnologías de circuitos integrados
- ASIC, particularizadas en fábrica
- non-ASIC particularizadas en el campo (PLD)

*** Clasificación  

**** Full-custom ASIC
- Todos los elementos del circuito diseñados para una determinada aplicación.
- Se usa en pequeños dircuitos básicos (un sumador por ejemplo).

**** Standard-cell ASIC
- Trabajo a nivel de puertas lógicas combinando celdas estándar predefinidas.

**** Gate array ASIC
- Circuito construido a partir de un array de celdas base.
- Macroceldas, librerías de componentes prediseñados para realizar funciones básicas.
      - Puede realizarse el diseño conectando macrozeldas.

**** Dispositivos complejos programables en campo
- Un array de celdas lógicas e interconexión genérica entre ellas.
      - Fusibles que permiten programar.
- Tipos según la estructura circuital de sus celdas.
      - *CPLD*, Complex programable logic device
      - *FPGA*, Field programable Gate Array

**** Dispositivos sencillos programables en campo
- Conocidos como PLDs.
- Estructura interna más sencilla que los CPLD y FPGAs.
- Dos arrays, una array de puertas AND y otra de puertas OR
- tipos
      - *PROM*, programable read only, se programa la matriz OR.
      - *PAL*, Programable array logic, se programa la matriz AND.
      - *PLA*, Programable logic array, pueden programarse ambas matrices.
- Son usados raramente.

**** Circuitos estándar de pequeña y mediana integración
- Circuitos integrados prefabricados (SSI/MSI, Small/Medium-Scaled Integrated circuits).
- Se seleccionaban los circuitos y se aplicaban sobre una placa impresa para la aplicación.
- Ya no se usa.

*** Comparación entre tecnologías
- Se compara FPGS, Gate array y standar cell.

**** Área
- Circuitos más pequeños requieren menos recursos, tienen mejor rendimiento en fabricación y los tests son más sencillos.
- Circuitos con mayor área son más complejos y rápidos.
- En *standar cell*, el chip está optimizado con desperdicio mínimo,
- En *Gate Array*, La posición de las celda base está predeterminada.
      - El aprovechamiento no es óptimo.
      - Requiere de mayor área, entre 20% y 100% más que standar cell.
- *FPGA* son unas 2 y 5 veces mayor que con tecnología ASIC.

**** Velocidad
- Tiempo para realizar una función.
- Hace falta usar arquitecturas más complejas que ocupan mayor área.
- En idénticas arquitecturas normalmente el circuito de mayor área es más lento.
- *Standar cell* permite mayor velocidad (menores retardos de propagación).
- *FPGA*, la de menor velocidad.

**** Potencia consumida
- Menor consumo mejor.
- *Standar cell* es la que menos consume.
- *FPGA* consume la mayor cantidad de potencia.

**** Coste
- *Coste de producción*
      - $C_{prod} = C_{fab} + \frac{C_{ing}}{Unidades\ producidas}$
      - $C_{ing}$, coste de ingeniería, prototipos, máscaras de fotolitografía, dearrollo de tests.
      - $C_{fab}$, Coste de fabricar encapsular y testear un dispositivo.
            - FPGA > gate array > standar cell
            - Standar cell aprovecha mejor el área en la oblea de silicio.
- *Coste de desarrollo* de standar cell > gate array
      - Coste de diseñar el circuito
- *Coste del tiempo de llegada al mercado*
      - Influenciado por el ciclo de vida de los dispositivos.
      - Standar Cell necesita más tiempo de validaciones lo que retrasa su llegada al mercado (1,2 años).
      - Gate array unos meses.
      - FPGA la particularización del circuito a la aplicación puede hacerse en minutos.
        
** Propiedades de los circuitos digitales
*** Retardo de los dispositivos
- *glitch*, cambio temporal, pico de subida o bajada, en el voltaje.
- *Retardo inercial*, Si el tiempo de propagación es mayor que el glitch, este no afecta al funcionamiento.
      - hay que mantener el estado en un dispositivo para que el cambio se propague.
- *Retardo de transporte o retardo puro*. Los glitches de entrada se manifiestan en los pines de salida.
      - adecuado para modelar dispositivos de poca inercia.
- La síntesis determina el retardo de un circuito.

#+begin_src vhlc
y1 <= x after 100 ns;
y2 <= transport x after 100 ns;
#+end_src

*** Ejecución Concurrente
- Los módulos lógicos se ejecutan concurrentemente.

*** Diseños marginales
- Existen diferencias de retardos entre chips dependiendo de las condiciones de fabricación.
      - Incluso dentro de una misma oblea.
- Por eso no es buena idea tomas un diseño que dependa de la propagación mínima.

*** Fortaleza de las señales
- La salida de un módulo puede ser conectada como máximo a un determinado número de entradas de otros módulos.
      - La señal eléctrica se debilita.
- *árbol de buffers*, permite conectar a más entradas una salida sin que se debilite la señal.
      - Además iguala los retardos de propagación a todas las entradas.
      - útil para tener sincronizados circuitos flip-flop.

# gráfico pag 51

** Test de los circuitos
- Ayuda al diseño en el proceso de diseño de un chip.
- Tamiza los chips defectuosos.
- Procedimiento básico
      - Se establecen valores en las entradas de un circuito.
      - Se comprueban las salidas con el valor esperado.
- *Vector de test*, todos los valores que se asignan a las entradas de un circuito.

*** Test en manufactura
- Detectar problemas en el proceso de fabricación
- Causas comunes
      - *Abiertos*, conexiones que han quedado abiertas.
      - *Cortos*, conexiones establecidas que no deberían estar.
      - *Acoplos*, Valores lógicos que inadvertidamente cambian el calor lógico de otra parte del circuito.
- La forma de modelar un error es suponer que un aparte del circuito siempre da el valor 1 o 0 independientemente del valor de entrada.
      - Se diseñan tests para detectar este comportamiento (tests que predicen cual sería la salida si una parte del circuito siempre da 1 o 0).]
      - Si los tests predicen un error se dice que el error esta cubierto por el vector de test.
- El test de circuitos secuenciales es más dificil porque se tiene en cuenta el estado del circuito.
      - Se puede diseñar una secuencia inicial para poner el circuito en el estado deseado antes de ejecutar los tests.
      - Usar *Scan flip-flops* en el diseño, flip-flops que se pueden configurar desde las entradas al circuito.
- Mayor número de tests mejor cobertura de erroes.
- Menor número de tests se pueden comprobar más circuitos.

*** Test funcional
- Se emplea en todas las fases de diseño de un circuito.
- Tanto a las partes individuales de bajo nivel como a las combinaciones de estas de más alto nivel.
- Los primero prototipos suelen tener errores de diseño.

*** Programa de test funcional
- Se tiende a probar todas las posibles entradas posibles para un circuito.
- Métodos heurísticos para seleccionar vectores de test.
      - Conocimiento sobre el circuito puede descartar las combinaciones imposibles.
      - Test exhaustivo de los subcircuitos, menod exhaustivo del circuito completo.
      - Escoger conjuntos representativos de vectores de entrada. Relacionadas con la aplicación imagino.
- Comprobar tests        
      - Es importante comparar los resultados obtenidos con un conjunto de soluciones correctas comprovadas.
      - Calcular la salida esperada con otro procedimiento y compararlo con el resultado del test.

*** Banco de pruebas
- *Banco de pruebas* Codificar en HDL los tests en un módulo (subcircuito generador).
- Partes de un banco de pruebas
      - Subcircuito generador.
      - *UUT*, el circuito siendo probado
      - Subcircuito de comprobación de los resultados.
- Importante recalcar que deben testearse también los subcircuitos de un diseño jerárquico.

** Representaciones y niveles de abstracción
*** Representación del sistema
**** Representación del comportamiento
- Describe la funcionalidad del sistema.
- Se ignora su implementación interna.
- Se definan las entradas y las salidas que deben obtenerse.

**** Representación de la estructura
- Describe la implementación interna del sistema.
- Qué componentes y como están conectados entre si.
- net, conjunto de cables conectados a un mismo nodo.
- netlist, Descripción esquemática del sistema.

**** Representación física
- Características físicas del sistema.
- Tamaño de los componentes, disposición física, cableado físico.
- Es la especificación final para la fabricación del sistema.

*** Niveles de abstracción
- No se enfoca la atención en el transistor en concreto, los niveles de abstracción permiten dividir el enfoque a la hora de tratar el diseño.

**** Nivel de transistor
- Nivel bás bajo
- resistencias, transistores, capacitores.
- Sistema descrito por ecuaciones diferenciales y algebraicas que pueden simularse en entornos como Spice.
- Sistema analógico

**** Nivel de puertas lógicas
- Bloques constitutivos básicos son AND, OR, XOR, MUX 2:1, memorias o flip-flops entre otros.
- Se considera si las señales están por encima de un umbral (0 o 1 digital).
- Sistema descrito por operaciones discretas.
- Retardo de la propagación, tiempo que precisa un sistema para proporcionar una señal estable.
- La representación física consiste en la situación espacial de los componentes y del routing.
- Se usa el área de la puerta NAND como medida básica de medida.

**** Nivel de transferencia entre registros (RTL)
- Módulos funcionales
- Las señales pueden intrepetarse como dato.
- Se usan máquinas de estados finitos para describir el sistema.
- Si está bien diseñado podemos hablar en términos de ciclos de reloj.

**** Nivel de procesador
- Mayor nivel de abstracción.
- procesadores, módulos de memoria, etc

** Desarrollo en VHDL  
*** Banco de pruebas
- Ejemplo de código VHDL en un banco de pruebas.

#+begin_src vhdl
-- Banco de pruebas del detector de paridad.
-- fichero bp_detectorPar.vhd

library IEEE;
use IEEE.std_logic_1164.all;

entity bp_detectorPar is
end entity bp_detectorPar;

architecture bp_arch of bp_detectorPar is
  component detectorPar is
    port (par : out std_logic;
          a   : in std_logic_vector(2 downto 0));
  end component detectorPar;
  signal test_in : std_logic_vector(2 downto 0);
  signal test_out : std_logic;
begin
  UUT: detectorPar port map ( par => test_out, a => test_in);
  
  vect_test: process
  begin
    test_in <= "000";  wait for 200 ns;
    test_in <= "001";  wait for 200 ns;
    test_in <= "010";  wait for 200 ns;
    test_in <= "011";  wait for 200 ns;
    test_in <= "100";  wait for 200 ns;
    test_in <= "101";  wait for 200 ns;
    test_in <= "110";  wait for 200 ns;
    test_in <= "111";  wait for 200 ns;
  end process vect_test;

  verif: process
    variable error_status : boolean;
    begin
      if ((test_in = "000" and test_out = '1') or
          (test_in = "001" and test_out = '0') or
          (test_in = "010" and test_out = '0') or
          (test_in = "011" and test_out = '1') or
          (test_in = "100" and test_out = '0') or
          (test_in = "101" and test_out = '1') or
          (test_in = "110" and test_out = '1') or
          (test_in = "111" and test_out = '0') or
          )
      then
        error_status := false;
      else
        error_status := true;
      end if
      assert not error_status report "Test Fallado." severity note;
  end process verif;
end architecture bp_arch;
#+end_src

*** Buffer triestado
#+begin_src vhdl
-- Modelo del buffer triestado
-- bufferTriestado.vhd
library IEEE;
use IEEE.std_logic_1164.all;

entity Buffer_TriEstado is port
                             (
                               y: out std_logic;
                               E: in  std_logic;
                               d: in  std_logic
                               );
end entity Buffer_TriEstado;

architecture Behavioral of Buffer_TriEstado is
begin
  process (E,d)
  begin
    if (E = '1') then
      y <= d;
    else
      y <='Z';  -- Z debe ser alta impedancia
    end if;
  end process;
end architecture Behavioral;
#+end_src

#+begin_src vhdl
-- Banco de pruebas
-- bp_bufferTriestado.vhdl
library IEEE;
use IEEE.std_logic_1164.all;

entity bp_Buffer_TriEstado is
end entity bp_Buffer_TriEstado;

architecture bp_Buffer_TriEstado of bp_Buffer_TriEstado is
  signal y : std_logic;
  signal d,E : std_logic;

  component Buffer_TriEstado is port
                                  (
                                    y : out std_logic;
                                    E,d : in std_logic;
                                    );
  end component Buffer_TriEstado
begin
  -- Instanciar y conectar UUT
  uut : component Buffer_TriEstado port map
    (y => y, E => E, d => d);

  gen_vec_test : process
  begin
    E <= '0'; d<= '0';
    wait for 10 ns;
    d <= '1';
    wait for 10 ns;
    E <= '1';
    wait for 10 ns;
    d <= '0';
    wait for 10 ns;
    report "Final de la simulación";
    wait;
  end process gen_vec_test;
end architecture bp_Buffer_TriEstado;
#+end_src


* Conceptos Básicos de VHDL
** Unidades de diseño
- *Entity*, Definición de la interfaz entre el diseño y el entorno que la usa.
      - Define *puertos de conexión* (señales entrada salida).
      - Lo que es visible desde el mundo exterior.
- *Architecture*, Define el comportamiento y la estructura de la entidad de diseño.
      - Permite varias *architecture* para una *entity*.
- *Package*, agrupa una colección de tipos de datos, subprogramas y componentes.
      - Lo veo como una librería.
- *Configuration*, Permite relacioner en tiempo de compilación la entity con la architecture.
      - Está fuera del temario (ver en la documentación del ghdl).

** Entity
*** Cláusula port
- Señales de la interfaz

#+begin_src vhdl
entity nombre is
  port(
    nombrePtSalida1 : (out|inout) tipo_dato;
    ...
    nombrePtEntreda1 : (in) tipo_dato;
    ...
);
end entity nombre;
#+end_src  

- Señales de salida no pueden usarse nunca para alimentar otro puerto.
      - Conviene definir señales intermedias. Por ejemplo.

#+begin_src vhdl
library IEEE;
use IEEE.std_logic_1164.all;

entity modoPuertos is
  port(
    x,y : out std_logic;
    a,b : in std_logic
    );
end entity modoPuertos;

architecture arch_correcta of modoPuertos is
  signal ab : std_logic;             -- Señal intermedia del valor a and b
begin
  ab <= a and b;
  x <= ab;
  y <= not ab;                       -- y <= x está mal
                                     --  x es modo out
end architecture arch_correcta  
#+end_src

*** Cláusula generic
- Se declara en la *entity*
- Declara constantes que necesitan ser modificadas para adaptar el diseño a diferentes aplicaciones.
- Valores típicos son los bits de un bus o el valor de los retardos

#+begin_src vhdl
entity and2 is
  generic (Tpd : time);    -- Cláusula generic, puede ser usado
                           --  en el cuerpo de cualquier
                           --  architecture asociado
  port    (y0 : out std_logic;
           x0, x1 : in std_logic);
end entity and2;
#+end_src

*** Declaraciones
- subprogramas, atributos tipos de datos, etc que son visibles desde la propia *entity* y las *architectures* asociadas.

#+begin_src vhdl
entity bp is
  constant WORD_SZ : integer := 16;
  constant DELAY   : timer   := 10 ns;
end entity bp;
#+end_src

*** Sentencias
- sentencias assert.
- llamadas concurrentes a procedimientos.
- bloques process.
- No deben producirse asignaciones a señales.
- Se incluyen después de la asignación de puertos.

** Architecture
- Define el comportamiento y la estructura de la entidad de diseno.
      - *Descripción estructural*, conexión de componentes de más bajo nivel.
      - *Descripción de su comportamiento*.
      - *Descripción mixta*, estructural y de comportamiento.

#+begin_src vhdl
architecture nombre_architecture of nombre_entity is
  -- Declaración de señales y constantes locales
  -- Declaración de componentes
  -- Declaración de subprogramas
begin
  -- Instanciación de los componentes
  -- Asignaciones concurrentes a señales y bloques process
end architecture nombre_architecture;  
#+end_src        

** Asignaciones concurrentes
- *Asignaciones concurrentes*, asignaciones contenidas entre el *begin* y el *end* de un *architecture*.
- Se evaluan de forma concurrente.

*** Asignación concurrentes simples
Sintaxis:
#+begin_src vhdl
señal <= forma_de_onda;
#+end_src

La ejecución de una señal de asignación concurrente simple se produce en el instante en que cambia el valor de alguna de las señales que aparecen en la expresión a la derecha de <=.

Se puede especificar el valor de retardo.

#+begin_src vhdl
y0 <= x1 + x2 after 10 ns;               -- 10 ns de retardo inercial
y1 <= transport x3 + x4 after 10 ns;     -- 10 ns de retardo de transporte
#+end_src

Si no se indica el retardo es infinitesimal $\delta$.

*** Asignación concurrentes condicionales
Sintaxis:
#+begin_src vhdl
señal <= expr_nuevo_valor_señal_1 when expr_booleana_1 else
         expr_nuevo_valor_señal_2 when expr_booleana_2 else
         expr_nuevo_valor_señal_3 when expr_booleana_3 else
         ...
         expr_nuevo_valor_señal_n;
#+end_src

- Se evalua por orden, el nuevo valor calculado se asigna trascurrido un retardo, por defecto $\delta$.

Ejemplo MUX 8:1
#+begin_src vhdl
library IEEE;
use IEEE.std_logic_1164.all;

entity mux4 is
  port (
    x : out std_logic_vector(7 downto 0);       -- de 7 a 0, 8 bits
    a,b,c,d : in std_logic_vector(7 downto 0);
    s       : in std_logic_vector(1 downto 0));
end entity mux4;

architecture arch_cond of mux4 is
begin
  x <= a when (s="00") else
       b when (s="01") else
       c when (s="10") else
       d;
end architecture arch_cond;  
#+end_src

- La sintesis en hardware de las sentencias condicionales involucran.
      - Circuitos para expresiones booleanas.
      - Circuito que implementa la red de prioridad (red MUX 2:1).

*** Asignaciones concurrentes de selección
Sintaxis:

#+begin_src vhdl
with expresion_seleccion select
  señal <= expr_nuevo_valor_señal_1 when valor_seleccion_1,
           expr_nuevo_valor_señal_2 when valor_seleccion_2,
           ...
           expr_nuevo_valor_señal_n when valor_seleccion_n;
#+end_src

- *expresion_seleccion* puede ser un entero o un vector unidimensional.
- Puede definirse explicitamente los retardos o usar el valor ínfimo $\delta$.
- valor_selección_# deben cumplir algunas restricciones.
      - Deben ser mutuamente excluyentes.
      - Deben incluir todos los posibles valores de *expresión_selección*.

Ejemplo MUX 4:1

#+begin_src vhdl
library IEEE;
use IEEE.std_logic_1164.all;

entity mux4 is
  port( x : out std_logic_vector(7 downto 0);
        a,b,c,d : in std_logic_vector(7 downto 0);
        s : in std_logic_vector(1 downto 0));
end entity mux4;

architecture arch_selec of mux4 is
begin
  with s select
    x <= a when "00",
         b when "01",
         c when "10",
         d when others;       -- others para el resto
end architecture arch_selec;
#+end_src

Ejemplo Prioridad 4 a 2

#+begin_src vhdl
library IEEE;
use IEEE.std_logic_1164.all;

entity codificadorPrioridad4a2 is
  port ( codigo : out std_logic_vector(1 downto 0);
         activo : out std_logic;
         x      : in  std_logic_vector(3 downto 0));
end entity codificadorPrioridad4a2;

architecture codPrior4a2_selec of codificadorPrioridad4a2 is
begin
  with x select
    codigo <= "11" when "1000" | "1001" | "1010" | "1011" |
                        "1100" | "1101" | "1110" | "1111",
              "10" when "0100" | "0101" | "0110" | "0111",
              "01" when "0010" | "0011",
              "00" when others;
    activo <= x(3) or x(2) or x(1) or x(0);
end architecture codPrior4a2_selec;
#+end_src

*** Sensibilidad de las sentencias concurrentes
- Una asignación concurrente es /sensible/ a todas las señales que intervienen en el cálculo del valor.
- Una sentencia condicional es /sensible/ a todas las señales que intervienen en el cálculo del nuevo valor y de las condiciones booleanas.
- Una sentencia de selección concurrente es /sensible/ a todas las señales que intervienen en el nuevo valor y las condiciones booleanas.

** Sentencia Generate
Facilita la ejecución iterativa o condicional de una porción de código concurrente.

*** Sentencia generate iterativa
Sintaxis
#+begin_src vhdl
etiqueta: for indice in rango_bucle generate
  -- Declaración de señales locales y constantes locales
begin  -- Puede omitirse si no se declaran señales o constantes locales
  -- sentencias_concurrentes
end generate etiqueta;
#+end_src

- Sólo es sintetizable si los límites del rango son estáticos.

Ejemplo
#+begin_src vhdl
signal z : std_logic_vector(7 downto 0);
signal x : std_logic_vector(7 downto 0);
signal y : std_logic_vector(15 downto 0);
E1 : for i in x'range generate   -- x'range para iterar por los índices de x
  z(i) <= x(i) AND y(i+8);
end generate E1;
#+end_src

*** Sentencia generate condicional
Syntaxis
#+begin_src vhdl
etiqueta : if expresion_booleana generate
  -- Declaración de señales y constantes locales
begin
  -- Sentencias Condicionales
  etiqueta2 : if expresion_booleana2 generate
    -- ...
  end generate etiqueta2;
end generate etiqueta;
#+end_src

*** Bloque process
Sintaxis

#+begin_src vhdl
-- la etiqueta es opcional pero recomendable
etiqueta : process(lista_de_sensibilidad)          -- Se ejecuta cada vez que cambia el valor
                                                   --  de algún elemento de la lista de sensibilidad
  -- Declaración de variables locales
  variable nombre_variable tipo rango := valor_inicial;  -- valor_inicial no es sintetizable
  -- Declaración de subprogramas (funciones y procedimientos)
begin
  -- Código secuencial
end process etiqueta;
#+end_src

- Se ejecutan en orden secuencial.
- No puede declararse señales.
- Los bloques process son concurrente entre ellos.
- El bloque se ejecuta indefenidamente, para controlar la ejecución de un bloque process usamos.
      - *lista de sensibilidad*
      - sentencias *wait*

*** Sentencias wait
**** Wait on
Sintaxis
#+begin_src vhdl
wait on señal1, señal2, ..., señalN;
#+end_src

- Suspende la ejecución de código secuencial hasta que cambia el valor de alguna señal.

**** Waint until
Sintaxis
#+begin_src vhdl
wait until expresion_booleana;

wait on señal1, ..., señalN  -- Puede especificarse la lista de sensibilidad
  until expresión_booleana;
#+end_src

- Se suspende la ejecución hasta que se evalue la expresión booleana y esta sea *true*.
      - Solo se tienen en cuenta el cambio de valor de las señales para evaluar la expresión.

**** Wait for
Sintaxis
#+begin_src vhdl
wait for expresion_temporal;
#+end_src

- Suspende la ejecución hasta que transcurra determinado intérvalo de tiempo.

Se puede combinar con otros wait
#+begin_src vhdl
wait until clk='1' and enable and v<30 for 50 ns;
#+end_src

- Suspende la ejecución secuencial hasta una de las dos condiciones.
      - Cambia el valor de alguna señal y además se satisface `clk='1' and enable and v<30`.
      - han pasado 50 ns.

*** Lista de sensibilidad
El bloque process se es ejecutado en el instante que una o varias señales de la lista cambian de valor.
Tan solo pueden incluirse puertos de entrada (pueden ser leídos).

#+begin_src vhdl
-- Biestable D con reset asíncrono activado en LOW
library IEEE;
use IEEE.std_logic_1164.all;

entity flipflop_D is port (
  q, q_n : out std_logic;
  d, clk, reset_n : in std_logic);
end entity flipflop_D;

architecture flipflop_D of flipflop_D is
begin
  process (reset_n, clk) is       -- Lista de sendibilidad con reset_n y clk
  begin
    if reset_n = '0' then
      q <= '0';
      q_n <= '1';
    elsif rising_edge(clk) then   -- flanco de subida?
      q <= d;
      q_n <= not d;
    end if
  end process
end architecture flipflop_D
#+end_src

* Glosario
- *flip-flop*, circuito biestable.
  # creo que era un Biestable-T (toggle)
- *VHDL*, lenguage para diseñar circuitos

* Recursos
- https://www.dia.uned.es/71012018/ página web de la asignatura.
- https://ghdl-rad.readthedocs.io/en/stable/using/QuickStartGuide.html, ghdl documentation.

* Notas
- *ModelSim*, software para editar y simular circuitos
- Emacs + ghdl, alternativa para simular

* GHDL
** Compile and run
#+begin_src sh
ghdl -a hello.vhd       # analysis, genera hello.o
ghdl -e hello_world     # elaborate
ghdl -r hello_world     # run
#+end_src


