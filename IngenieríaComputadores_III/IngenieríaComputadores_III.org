#+title: Ingeniería Computadores III

* Fundamentos del diseño del hardware digital
- *HDL (hardware description languaje)*, lenguaje para la descripción del Hardware.
- *VHDL*, VHSIC Hardware Description Language
      - Very High Speed Description Langage

** Pasos del diseño de un circuito integrado
# TODO gráfico

** HDL más usados
- *Verilog* HDL, 
- *VHDL*
- SystemC, basado en C++

** Tecnologías de circuitos integrados
- ASIC, particularizadas en fábrica
- non-ASIC particularizadas en el campo (PLD)

*** Clasificación  

**** Full-custom ASIC
- Todos los elementos del circuito diseñados para una determinada aplicación.
- Se usa en pequeños dircuitos básicos (un sumador por ejemplo).

**** Standard-cell ASIC
- Trabajo a nivel de puertas lógicas combinando celdas estándar predefinidas.

**** Gate array ASIC
- Circuito construido a partir de un array de celdas base.
- Macroceldas, librerías de componentes prediseñados para realizar funciones básicas.
      - Puede realizarse el diseño conectando macrozeldas.

**** Dispositivos complejos programables en campo
- Un array de celdas lógicas e interconexión genérica entre ellas.
      - Fusibles que permiten programar.
- Tipos según la estructura circuital de sus celdas.
      - *CPLD*, Complex programable logic device
      - *FPGA*, Field programable Gate Array

**** Dispositivos sencillos programables en campo
- Conocidos como PLDs.
- Estructura interna más sencilla que los CPLD y FPGAs.
- Dos arrays, una array de puertas AND y otra de puertas OR
- tipos
      - *PROM*, programable read only, se programa la matriz OR.
      - *PAL*, Programable array logic, se programa la matriz AND.
      - *PLA*, Programable logic array, pueden programarse ambas matrices.
- Son usados raramente.

**** Circuitos estándar de pequeña y mediana integración
- Circuitos integrados prefabricados (SSI/MSI, Small/Medium-Scaled Integrated circuits).
- Se seleccionaban los circuitos y se aplicaban sobre una placa impresa para la aplicación.
- Ya no se usa.

*** Comparación entre tecnologías
- Se compara FPGS, Gate array y standar cell.

**** Área
- Circuitos más pequeños requieren menos recursos, tienen mejor rendimiento en fabricación y los tests son más sencillos.
- Circuitos con mayor área son más complejos y rápidos.
- En *standar cell*, el chip está optimizado con desperdicio mínimo,
- En *Gate Array*, La posición de las celda base está predeterminada.
      - El aprovechamiento no es óptimo.
      - Requiere de mayor área, entre 20% y 100% más que standar cell.
- *FPGA* son unas 2 y 5 veces mayor que con tecnología ASIC.

**** Velocidad
- Tiempo para realizar una función.
- Hace falta usar arquitecturas más complejas que ocupan mayor área.
- En idénticas arquitecturas normalmente el circuito de mayor área es más lento.
- *Standar cell* permite mayor velocidad (menores retardos de propagación).
- *FPGA*, la de menor velocidad.

**** Potencia consumida
- Menor consumo mejor.
- *Standar cell* es la que menos consume.
- *FPGA* consume la mayor cantidad de potencia.

**** Coste
- *Coste de producción*
      - $C_{prod} = C_{fab} + \frac{C_{ing}}{Unidades\ producidas}$
      - $C_{ing}$, coste de ingeniería, prototipos, máscaras de fotolitografía, dearrollo de tests.
      - $C_{fab}$, Coste de fabricar encapsular y testear un dispositivo.
            - FPGA > gate array > standar cell
            - Standar cell aprovecha mejor el área en la oblea de silicio.
- *Coste de desarrollo* de standar cell > gate array
      - Coste de diseñar el circuito
- *Coste del tiempo de llegada al mercado*
      - Influenciado por el ciclo de vida de los dispositivos.
      - Standar Cell necesita más tiempo de validaciones lo que retrasa su llegada al mercado (1,2 años).
      - Gate array unos meses.
      - FPGA la particularización del circuito a la aplicación puede hacerse en minutos.
        
** Propiedades de los circuitos digitales
*** Retardo de los dispositivos
- *glitch*, cambio temporal, pico de subida o bajada, en el voltaje.
- *Retardo inercial*, Si el tiempo de propagación es mayor que el glitch, este no afecta al funcionamiento.
      - hay que mantener el estado en un dispositivo para que el cambio se propague.
- *Retardo de transporte o retardo puro*. Los glitches de entrada se manifiestan en los pines de salida.
      - adecuado para modelar dispositivos de poca inercia.
- La síntesis determina el retardo de un circuito.

#+begin_src vhlc
y1 <= x after 100 ns;
y2 <= transport x after 100 ns;
#+end_src

*** Ejecución Concurrente
- Los módulos lógicos se ejecutan concurrentemente.

*** Diseños marginales
- Existen diferencias de retardos entre chips dependiendo de las condiciones de fabricación.
      - Incluso dentro de una misma oblea.
- Por eso no es buena idea tomas un diseño que dependa de la propagación mínima.

*** Fortaleza de las señales
- La salida de un módulo puede ser conectada como máximo a un determinado número de entradas de otros módulos.
      - La señal eléctrica se debilita.
- *árbol de buffers*, permite conectar a más entradas una salida sin que se debilite la señal.
      - Además iguala los retardos de propagación a todas las entradas.
      - útil para tener sincronizados circuitos flip-flop.

# gráfico pag 51

** Test de los circuitos
- Ayuda al diseño en el proceso de diseño de un chip.
- Tamiza los chips defectuosos.
- Procedimiento básico
      - Se establecen valores en las entradas de un circuito.
      - Se comprueban las salidas con el valor esperado.
- *Vector de test*, todos los valores que se asignan a las entradas de un circuito.

*** Test en manufactura
- Detectar problemas en el proceso de fabricación
- Causas comunes
      - *Abiertos*, conexiones que han quedado abiertas.
      - *Cortos*, conexiones establecidas que no deberían estar.
      - *Acoplos*, Valores lógicos que inadvertidamente cambian el calor lógico de otra parte del circuito.
- La forma de modelar un error es suponer que un aparte del circuito siempre da el valor 1 o 0 independientemente del valor de entrada.
      - Se diseñan tests para detectar este comportamiento (tests que predicen cual sería la salida si una parte del circuito siempre da 1 o 0).]
      - Si los tests predicen un error se dice que el error esta cubierto por el vector de test.
- El test de circuitos secuenciales es más dificil porque se tiene en cuenta el estado del circuito.
      - Se puede diseñar una secuencia inicial para poner el circuito en el estado deseado antes de ejecutar los tests.
      - Usar *Scan flip-flops* en el diseño, flip-flops que se pueden configurar desde las entradas al circuito.
- Mayor número de tests mejor cobertura de erroes.
- Menor número de tests se pueden comprobar más circuitos.

*** Test funcional
- Se emplea en todas las fases de diseño de un circuito.
- Tanto a las partes individuales de bajo nivel como a las combinaciones de estas de más alto nivel.
- Los primero prototipos suelen tener errores de diseño.

*** Programa de test funcional
- Se tiende a probar todas las posibles entradas posibles para un circuito.
- Métodos heurísticos para seleccionar vectores de test.
      - Conocimiento sobre el circuito puede descartar las combinaciones imposibles.
      - Test exhaustivo de los subcircuitos, menod exhaustivo del circuito completo.
      - Escoger conjuntos representativos de vectores de entrada. Relacionadas con la aplicación imagino.
- Comprobar tests        
      - Es importante comparar los resultados obtenidos con un conjunto de soluciones correctas comprovadas.
      - Calcular la salida esperada con otro procedimiento y compararlo con el resultado del test.

*** Banco de pruebas
- *Banco de pruebas* Codificar en HDL los tests en un módulo (subcircuito generador).
- Partes de un banco de pruebas
      - Subcircuito generador.
      - *UUT*, el circuito siendo probado
      - Subcircuito de comprobación de los resultados.
- Importante recalcar que deben testearse también los subcircuitos de un diseño jerárquico.

** Representaciones y niveles de abstracción
*** Representación del sistema
**** Representación del comportamiento
- Describe la funcionalidad del sistema.
- Se ignora su implementación interna.
- Se definan las entradas y las salidas que deben obtenerse.

**** Representación de la estructura
- Describe la implementación interna del sistema.
- Qué componentes y como están conectados entre si.
- net, conjunto de cables conectados a un mismo nodo.
- netlist, Descripción esquemática del sistema.

**** Representación física
- Características físicas del sistema.
- Tamaño de los componentes, disposición física, cableado físico.
- Es la especificación final para la fabricación del sistema.

*** Niveles de abstracción
- No se enfoca la atención en el transistor en concreto, los niveles de abstracción permiten dividir el enfoque a la hora de tratar el diseño.

**** Nivel de transistor
- Nivel bás bajo
- resistencias, transistores, capacitores.
- Sistema descrito por ecuaciones diferenciales y algebraicas que pueden simularse en entornos como Spice.
- Sistema analógico

**** Nivel de puertas lógicas
- Bloques constitutivos básicos son AND, OR, XOR, MUX 2:1, memorias o flip-flops entre otros.
- Se considera si las señales están por encima de un umbral (0 o 1 digital).
- Sistema descrito por operaciones discretas.
- Retardo de la propagación, tiempo que precisa un sistema para proporcionar una señal estable.
- La representación física consiste en la situación espacial de los componentes y del routing.
- Se usa el área de la puerta NAND como medida básica de medida.

**** Nivel de transferencia entre registros (RTL)
- Módulos funcionales
- Las señales pueden intrepetarse como dato.
- Se usan máquinas de estados finitos para describir el sistema.
- Si está bien diseñado podemos hablar en términos de ciclos de reloj.

**** Nivel de procesador
- Mayor nivel de abstracción.
- procesadores, módulos de memoria, etc

** Desarrollo en VHDL  
*** Banco de pruebas
- Ejemplo de código VHDL en un banco de pruebas.

#+begin_src vhdl
-- Banco de pruebas del detector de paridad.
-- fichero bp_detectorPar.vhd

library IEEE;
use IEEE.std_logic_1164.all;

entity bp_detectorPar is
end entity bp_detectorPar;

architecture bp_arch of bp_detectorPar is
  component detectorPar is
    port (par : out std_logic;
          a   : in std_logic_vector(2 downto 0));
  end component detectorPar;
  signal test_in : std_logic_vector(2 downto 0);
  signal test_out : std_logic;
begin
  UUT: detectorPar port map ( par => test_out, a => test_in);
  
  vect_test: process
  begin
    test_in <= "000";  wait for 200 ns;
    test_in <= "001";  wait for 200 ns;
    test_in <= "010";  wait for 200 ns;
    test_in <= "011";  wait for 200 ns;
    test_in <= "100";  wait for 200 ns;
    test_in <= "101";  wait for 200 ns;
    test_in <= "110";  wait for 200 ns;
    test_in <= "111";  wait for 200 ns;
  end process vect_test;

  verif: process
    variable error_status : boolean;
    begin
      if ((test_in = "000" and test_out = '1') or
          (test_in = "001" and test_out = '0') or
          (test_in = "010" and test_out = '0') or
          (test_in = "011" and test_out = '1') or
          (test_in = "100" and test_out = '0') or
          (test_in = "101" and test_out = '1') or
          (test_in = "110" and test_out = '1') or
          (test_in = "111" and test_out = '0') or
          )
      then
        error_status := false;
      else
        error_status := true;
      end if
      assert not error_status report "Test Fallado." severity note;
  end process verif;
end architecture bp_arch;
#+end_src

*** Buffer triestado
#+begin_src vhdl
-- Modelo del buffer triestado
-- bufferTriestado.vhd
library IEEE;
use IEEE.std_logic_1164.all;

entity Buffer_TriEstado is port
                             (
                               y: out std_logic;
                               E: in  std_logic;
                               d: in  std_logic
                               );
end entity Buffer_TriEstado;

architecture Behavioral of Buffer_TriEstado is
begin
  process (E,d)
  begin
    if (E = '1') then
      y <= d;
    else
      y <='Z';  -- Z debe ser alta impedancia
    end if;
  end process;
end architecture Behavioral;
#+end_src

#+begin_src vhdl
-- Banco de pruebas
-- bp_bufferTriestado.vhdl
library IEEE;
use IEEE.std_logic_1164.all;

entity bp_Buffer_TriEstado is
end entity bp_Buffer_TriEstado;

architecture bp_Buffer_TriEstado of bp_Buffer_TriEstado is
  signal y : std_logic;
  signal d,E : std_logic;

  component Buffer_TriEstado is port
                                  (
                                    y : out std_logic;
                                    E,d : in std_logic;
                                    );
  end component Buffer_TriEstado
begin
  -- Instanciar y conectar UUT
  uut : component Buffer_TriEstado port map
    (y => y, E => E, d => d);

  gen_vec_test : process
  begin
    E <= '0'; d<= '0';
    wait for 10 ns;
    d <= '1';
    wait for 10 ns;
    E <= '1';
    wait for 10 ns;
    d <= '0';
    wait for 10 ns;
    report "Final de la simulación";
    wait;
  end process gen_vec_test;
end architecture bp_Buffer_TriEstado;
#+end_src


* Conceptos Básicos de VHDL
** Unidades de diseño
- *Entity*, Definición de la interfaz entre el diseño y el entorno que la usa.
      - Define *puertos de conexión* (señales entrada salida).
      - Lo que es visible desde el mundo exterior.
- *Architecture*, Define el comportamiento y la estructura de la entidad de diseño.
      - Permite varias *architecture* para una *entity*.
- *Package*, agrupa una colección de tipos de datos, subprogramas y componentes.
      - Lo veo como una librería.
- *Configuration*, Permite relacioner en tiempo de compilación la entity con la architecture.
      - Está fuera del temario (ver en la documentación del ghdl).

** Entity
*** Cláusula port
- Señales de la interfaz

#+begin_src vhdl
entity nombre is
  port(
    nombrePtSalida1 : (out|inout) tipo_dato;
    ...
    nombrePtEntreda1 : (in) tipo_dato;
    ...
);
end entity nombre;
#+end_src  

- Señales de salida no pueden usarse nunca para alimentar otro puerto.
      - Conviene definir señales intermedias. Por ejemplo.

#+begin_src vhdl
library IEEE;
use IEEE.std_logic_1164.all;

entity modoPuertos is
  port(
    x,y : out std_logic;
    a,b : in std_logic
    );
end entity modoPuertos;

architecture arch_correcta of modoPuertos is
  signal ab : std_logic;             -- Señal intermedia del valor a and b
begin
  ab <= a and b;
  x <= ab;
  y <= not ab;                       -- y <= x está mal
                                     --  x es modo out
end architecture arch_correcta  
#+end_src

*** Cláusula generic
- Se declara en la *entity*
- Declara constantes que necesitan ser modificadas para adaptar el diseño a diferentes aplicaciones.
- Valores típicos son los bits de un bus o el valor de los retardos

#+begin_src vhdl
entity and2 is
  generic (Tpd : time);    -- Cláusula generic, puede ser usado
                           --  en el cuerpo de cualquier
                           --  architecture asociado
  port    (y0 : out std_logic;
           x0, x1 : in std_logic);
end entity and2;
#+end_src

*** Declaraciones
- subprogramas, atributos tipos de datos, etc que son visibles desde la propia *entity* y las *architectures* asociadas.

#+begin_src vhdl
entity bp is
  constant WORD_SZ : integer := 16;
  constant DELAY   : timer   := 10 ns;
end entity bp;
#+end_src

*** Sentencias
- sentencias assert.
- llamadas concurrentes a procedimientos.
- bloques process.
- No deben producirse asignaciones a señales.
- Se incluyen después de la asignación de puertos.

** Architecture
- Define el comportamiento y la estructura de la entidad de diseno.
      - *Descripción estructural*, conexión de componentes de más bajo nivel.
      - *Descripción de su comportamiento*.
      - *Descripción mixta*, estructural y de comportamiento.

#+begin_src vhdl
architecture nombre_architecture of nombre_entity is
  -- Declaración de señales y constantes locales
  -- Declaración de componentes
  -- Declaración de subprogramas
begin
  -- Instanciación de los componentes
  -- Asignaciones concurrentes a señales y bloques process
end architecture nombre_architecture;  
#+end_src        

** Asignaciones concurrentes
- *Asignaciones concurrentes*, asignaciones contenidas entre el *begin* y el *end* de un *architecture*.
- Se evaluan de forma concurrente.

*** Asignación concurrentes simples
Sintaxis:
#+begin_src vhdl
señal <= forma_de_onda;
#+end_src

La ejecución de una señal de asignación concurrente simple se produce en el instante en que cambia el valor de alguna de las señales que aparecen en la expresión a la derecha de <=.

Se puede especificar el valor de retardo.

#+begin_src vhdl
y0 <= x1 + x2 after 10 ns;               -- 10 ns de retardo inercial
y1 <= transport x3 + x4 after 10 ns;     -- 10 ns de retardo de transporte
#+end_src

Si no se indica el retardo es infinitesimal $\delta$.

*** Asignación concurrentes conficionales

* Glosario
- *flip-flop*, creo que era un Biestable-T (toggle)
- *VHDL*, lenguage para diseñar circuitos

* Recursos
- https://www.dia.uned.es/71012018/ página web de la asignatura.
- https://ghdl-rad.readthedocs.io/en/stable/using/QuickStartGuide.html, ghdl documentation.

* Notas
- *ModelSim*, software para editar y simular circuitos
- Emacs + ghdl, alternativa para simular

* GHDL
** Compile and run
#+begin_src sh
ghdl -a hello.vhd       # analysis
ghdl -e hello_world     # elaborate
ghdl -r hello_world     # run
#+end_src
