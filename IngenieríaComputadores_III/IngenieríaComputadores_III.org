#+title: Ingeniería Computadores III

* Fundamentos del diseño del hardware digital
- *HDL (hardware description languaje)*, lenguaje para la descripción del Hardware.
- *VHDL*, VHSIC Hardware Description Language
      - Very High Speed Description Langage

** Pasos del diseño de un circuito integrado
# TODO gráfico

** HDL más usados
- *Verilog* HDL, 
- *VHDL*
- SystemC, basado en C++

** Tecnologías de circuitos integrados
- ASIC, particularizadas en fábrica
- non-ASIC particularizadas en el campo (PLD)

*** Clasificación  

**** Full-custom ASIC
- Todos los elementos del circuito diseñados para una determinada aplicación.
- Se usa en pequeños dircuitos básicos (un sumador por ejemplo).

**** Standard-cell ASIC
- Trabajo a nivel de puertas lógicas combinando celdas estándar predefinidas.

**** Gate array ASIC
- Circuito construido a partir de un array de celdas base.
- Macroceldas, librerías de componentes prediseñados para realizar funciones básicas.
      - Puede realizarse el diseño conectando macrozeldas.

**** Dispositivos complejos programables en campo
- Un array de celdas lógicas e interconexión genérica entre ellas.
      - Fusibles que permiten programar.
- Tipos según la estructura circuital de sus celdas.
      - *CPLD*, Complex programable logic device
      - *FPGA*, Field programable Gate Array

**** Dispositivos sencillos programables en campo
- Conocidos como PLDs.
- Estructura interna más sencilla que los CPLD y FPGAs.
- Dos arrays, una array de puertas AND y otra de puertas OR
- tipos
      - *PROM*, programable read only, se programa la matriz OR.
      - *PAL*, Programable array logic, se programa la matriz AND.
      - *PLA*, Programable logic array, pueden programarse ambas matrices.
- Son usados raramente.

**** Circuitos estándar de pequeña y mediana integración
- Circuitos integrados prefabricados (SSI/MSI, Small/Medium-Scaled Integrated circuits).
- Se seleccionaban los circuitos y se aplicaban sobre una placa impresa para la aplicación.
- Ya no se usa.

*** Comparación entre tecnologías
- Se compara FPGS, Gate array y standar cell.

**** Área
- Circuitos más pequeños requieren menos recursos, tienen mejor rendimiento en fabricación y los tests son más sencillos.
- Circuitos con mayor área son más complejos y rápidos.
- En *standar cell*, el chip está optimizado con desperdicio mínimo,
- En *Gate Array*, La posición de las celda base está predeterminada.
      - El aprovechamiento no es óptimo.
      - Requiere de mayor área, entre 20% y 100% más que standar cell.
- *FPGA* son unas 2 y 5 veces mayor que con tecnología ASIC.

**** Velocidad
- Tiempo para realizar una función.
- Hace falta usar arquitecturas más complejas que ocupan mayor área.
- En idénticas arquitecturas normalmente el circuito de mayor área es más lento.
- *Standar cell* permite mayor velocidad (menores retardos de propagación).
- *FPGA*, la de menor velocidad.

**** Potencia consumida
- Menor consumo mejor.
- *Standar cell* es la que menos consume.
- *FPGA* consume la mayor cantidad de potencia.

**** Coste
- *Coste de producción*
      - $C_{prod} = C_{fab} + \frac{C_{ing}}{Unidades\ producidas}$
      - $C_{ing}$, coste de ingeniería, prototipos, máscaras de fotolitografía, dearrollo de tests.
      - $C_{fab}$, Coste de fabricar encapsular y testear un dispositivo.
            - FPGA > gate array > standar cell
            - Standar cell aprovecha mejor el área en la oblea de silicio.
- *Coste de desarrollo* de standar cell > gate array
      - Coste de diseñar el circuito
- *Coste del tiempo de llegada al mercado*
      - Influenciado por el ciclo de vida de los dispositivos.
      - Standar Cell necesita más tiempo de validaciones lo que retrasa su llegada al mercado (1,2 años).
      - Gate array unos meses.
      - FPGA la particularización del circuito a la aplicación puede hacerse en minutos.
        
** Propiedades de los circuitos digitales
*** Retardo de los dispositivos
- *glitch*, cambio temporal, pico de subida o bajada, en el voltaje.
- *Retardo inercial*, Si el tiempo de propagación es mayor que el glitch, este no afecta al funcionamiento.
      - hay que mantener el estado en un dispositivo para que el cambio se propague.
- *Retardo de transporte o retardo puro*. Glitches de entrada se manifiestan en los pines de salida.
      - adecuado para modelar dispositivos de poca inercia.
- La síntesis determina el retardo de un circuito.

#+begin_src vhlc
y1 <= x after 100 ns;
y2 <= transport x after 100 ns;
#+end_src

*** Ejecución Concurrente
- Los módulos lógicos se ejecutan concurrentemente.

*** Diseños marginales
- Existen diferencias de retardos entre chips dependiendo de las condiciones de fabricación.
      - Incluso dentro de una misma oblea.
- Por eso no es buena idea tomas un diseño que dependa de la propagación mínima.

*** Fortaleza de las señales
- La salida de un módulo puede ser conectada como máximo a un determinado número de entradas de otros módulos.
      - La señal eléctrica se debilita.
- *árbol de buffers*, permite conectar a más entradas una salida sin que se debilite la señal.
      - Además iguala los retardos de propagación a todas las entradas.
      - útil para tener sincronizados circuitos flip-flop.

# gráfico pag 51

** Test de los circuitos
- Ayuda al diseño en el proceso de diseño de un chip.
- Tamiza los chips defectuosos.
- Procedimiento básico
      - Se establecen valores en las entradas de un circuito.
      - Se comprueban las salidas con el valor esperado.
- *Vector de test*, todos los valores que se asignan a las entradas de un circuito.

*** Test en manufactura
- Detectar problemas en el proceso de fabricación
- Causas comunes
      - *Abiertos*, conexiones que han quedado abiertas.
      - *Cortos*, conexiones establecidas que no deberían estar.
      - *Acoplos*, Valores lógicos que inadvertidamente cambian el calor lógico de otra parte del circuito.
- La forma de modelar un error es suponer que un aparte del circuito siempre da el valor 1 o 0 independientemente del valor de entrada.
      - Se diseñan tests para detectar este comportamiento (tests que predicen cual sería la salida si una parte del circuito siempre da 1 o 0).]
      - Si los tests predicen un error se dice que el error esta cubierto por el vector de test.
- El test de circuitos secuenciales es más dificil porque se tiene en cuenta el estado del circuito.
      - Se puede diseñar una secuencia inicial para poner el circuito en el estado deseado antes de ejecutar los tests.
      - Usar *Scan flip-flops* en el diseño, flip-flops que se pueden configurar desde las entradas al circuito.
- Mayor número de tests mejor cobertura de erroes.
- Menor número de tests se pueden comprobar más circuitos.

*** Test funcional
- Se emplea en todas las fases de diseño de un circuito.
- Tanto a las partes individuales de bajo nivel como a las combinaciones de estas de más alto nivel.
- Los primero prototipos suelen tener errores de diseño.

*** Programa de test funcional
- Se tiende a probar todas las posibles entradas posibles para un circuito.
- Métodos heurísticos para seleccionar vectores de test.
      - Conocimiento sobre el circuito puede descartar las combinaciones imposibles.
      - Test exhaustivo de los subcircuitos, menod exhaustivo del circuito completo.
      - Escoger conjuntos representativos de vectores de entrada. Relacionadas con la aplicación imagino.
- Comprobar tests        
      - Es importante comparar los resultados obtenidos con un conjunto de soluciones correctas comprovadas.
      - Calcular la salida esperada con otro procedimiento y compararlo con el resultado del test.

*** Banco de pruebas
- *Banco de pruebas* Codificar en HDL los tests en un módulo (subcircuito generador).
- Partes de un banco de pruebas
      - Subcircuito generador.
      - *UUT*, el circuito siendo probado
      - Subcircuito de comprobación de los resultados.
- Importante recalcar que deben testearse también los subcircuitos de un diseño jerárquico.


** Representaciones y niveles de abstracción
*** Representación del sistema
**** Representación del comportamiento
- Describe la funcionalidad del sistema.
- Se ignora su implementación interna.
- Se definan las entradas y las salidas que deben obtenerse.

**** Representación de la estructura
- Describe la implementación interna del sistema.
- Qué componentes y como están conectados entre si.
- net, conjunto de cables conectados a un mismo nodo.
- netlist, Descripción esquemática del sistema.

**** Representación física
- Características físicas del sistema.
- Tamaño de los componentes, disposición física, cableado físico.
- Es la especificación final para la fabricación del sistema.

*** Niveles de abstracción
- No se enfoca la atención en el transistor en concreto, los niveles de abstracción permiten dividir el enfoque a la hora de tratar el diseño.

**** Nivel de transistor
- Nivel bás bajo
- resistencias, transistores, capacitores.
- Sistema descrito por ecuaciones diferenciales y algebraicas que pueden simularse en entornos como Spice.
- Sistema analógico

**** Nivel de puertas lógicas
- Bloques constitutivos básicos son AND, OR, XOR, MUX 2:1, memorias o flip-flops entre otros.
- Se considera si las señales están por encima de un umbral (0 o 1 digital).
- Sistema descrito por operaciones discretas.
- Retardo de la propagación, tiempo que precisa un sistema para proporcionar una señal estable.
- La representación física consiste en la situación espacial de los componentes y del routing.
- Se usa el área de la puerta NAND como medida básica de medida.

**** Nivel de transferencia entre registros (RTL)
- Módulos funcionales
- Las señales pueden intrepetarse como dato.
- Se usan máquinas de estados finitos para describir el sistema.
- Si está bien diseñado podemos hablar en términos de ciclos de reloj.

**** Nivel de procesador
- Mayor nivel de abstracción.
- procesadores, módulos de memoria, etc

** Desarrollo en VHDL  

*** Banco de pruebas
- Ejemplo de código VHDL en un banco de pruebas.

#+begin_src vhdl
-- Banco de pruebas del detector de paridad.
-- fichero bp_detectorPar.vhd

library IEEE;
use IEEE.std_logic_1164.all;

entity bp_detectorPar is
end entity bp_detectorPar;

architecture bp_arch of bp_detectorPar is
  component detectorPar is
    port (par : out std_logic;
          a   : in std_logic_vector(2 downto 0));
  end component detectorPar;
  signal test_in : std_logic_vector(2 downto 0);
  signal test_out : std_logic;
begin
  UUT: detectorPar port map ( par => test_out, a => test_in);
  
  vect_test: process
  begin
    test_in <= "000";  wait for 200 ns;
    test_in <= "001";  wait for 200 ns;
    test_in <= "010";  wait for 200 ns;
    test_in <= "011";  wait for 200 ns;
    test_in <= "100";  wait for 200 ns;
    test_in <= "101";  wait for 200 ns;
    test_in <= "110";  wait for 200 ns;
    test_in <= "111";  wait for 200 ns;
  end process vect_test;

  verif: process
    variable error_status : boolean;
    begin
      if ((test_in = "000" and test_out = '1') or
          (test_in = "001" and test_out = '0') or
          (test_in = "010" and test_out = '0') or
          (test_in = "011" and test_out = '1') or
          (test_in = "100" and test_out = '0') or
          (test_in = "101" and test_out = '1') or
          (test_in = "110" and test_out = '1') or
          (test_in = "111" and test_out = '0') or
          )
      then
        error_status := false;
      else
        error_status := true;
      end if
      assert not error_status report "Test Fallado." severity note;
  end process verif;
end architecture bp_arch;
#+end_src


* Glosario
- *flip-flop*, creo que era un Biestable-T (toggle)
- 

* Recursos
- https://www.dia.uned.es/71012018/ página web de la asignatura.
        
* Notas
- VHDL, lenguage para diseñar circuitos
- ModelSim, software para editar y simular circuitos
- Emacs + ghdl, alternativa para simular

  
