#+title: Sistemas Operativos
#+author: Jordi Amposta Pérez
#+startup: latexpreview overview

* General
** Definición de Sistema Operativo
- Arquitectura general de un sistema informático.
  ( ( ( ( hardware ) *Núcleo del SO* ) *Utilidades del SO* ) Programas de aplicación )
- Objetivos de un SO.
      - Gestionar o administrar eficientemente los dispositivos hardware de un computador.
            - Uso de la cpu, gestión de memoria, gestión de los componentes E/S,
              memoria secundária y área de intercambio, etc
      - Ofrecer a los usuarios una interfaz cómoda que les facilite el uso del computador.
            - Interfaces, terminales, sistemas de archivos, etc

** Servicios de un sistema operativo
- *Ejecución de programas*
- *Acceso a los dispositivos de E/S*
- *Manipulación del sistema de archivos*
- *Comunicación y sincronización* entre programas.
- *Detección y respuesta a errores*, de hardware como de software (e.g interbloqueos)
- *Protección y seguridad*, acceso a usuarios. Evitar interferencias no deseadas entre programas.
- *Contabilidad*, registros y estadísticas del uso de la computadora y el rendimiento.

** Tipos de sistema operativo
- Según el número de usuarios
      - *Multiusiario*, soporta multiples usuarios.
      - *Monousuario*, soporta un solo usuario.
- Según el número de programas en memoria
      - *Monoprogramado*, en memoria principal se almacena el OS y un único programa.
      - *Multiprogramados*, en memoria principal se almacena el OS y varios programas.
      - *Multiacceso*, permite el acceso a traces de dos o más terminales.
      - *Con multiprocesamiento*, puede coordinar la actividad de varios procesadores.
- Según los requisitos temporales de los programas a ejecutar
      - *Sistemas operativos por lotes*, procesa agrupaciones en lotes de trabajos similares.
            - cada trabajo consta de un programa, datos e instrucciones para el OS.
      - *Sistemas operativos de tiempo compartido*
      - *Sistemas operativos de tiempo real*
            - Tiempo real suave
            - Tiempo real estricto
      - *Sistemas operativos híbridos*, soportan trabajos por lotes, aplicaciones interactivas y tiempo real suave.
- Según la finalidad del computador
      - *Sistemas operativos para macrocomputadores*
      - *Sistemas operativos para servidores de red*
      - *Sistemas operativos para computadores personales*
      - *Sistemas operativos para computadores de mano*, un móbil
      - *Sistemas operaticos integrados*, un reproductor mp3
- Otros
      - *Sistemas operativos paralelos*
      - *Sistemas operativos distribuidos*
      - *Sistemas operativos de red*  

** Llamadas al sistema
- Procesadores tienen dos modos, modo núcleo y modo usuario.
      - Modo núcleo puede ejecutar cualquier instrucción (SO)
      - Modo usuario solo algunas (programas de usuario)
- *Llamadas al sistema*, interfaz que pone el SO a disposición de los programas, para usar funcionalidades del núcleo.
      - Se pueden invocar mediante librerías que se enlazan en la compilación.
      - Se pueden invocar directamente en ensamblador.
      - Se produce una *trampa* que cambia el hardware a modo núcleo, se efectua la rutina y se vuelve al modo usuario.
            - Todo guiado por el SO.
      - El paso de parámetros puede hacerse con registros, memoria localizada o almacenarlos en una pila dedicada.
- *Tipos de llamadas al sistema*
      - *Control de programas en ejecución (procesos)*.
      - *Administración de archivos o directorios*.
      - *Comunicaciones*, enviar recibir mensajes.
      - *Gestión de dispositivos* (E/S).
      - *Gestión de información del sistema*, obtener y configurar datos del sistema.

**  Estructura del núcleo
*** Componentes principales
- *Subsistema de control de procesos*
- *Subsistema de administración de la memoria principal*
- *Subsistema de gestión de archivos*, permisos, estructura de carpetas, localización en memoria secundadia, etc
- *Subsistema de E/S*, interfaz común para los dispositivos de E/S.

*** Tipos de estructura del núcleo
- *Estructura monolítica*, un único módulo lógico.
      - Muy eficiente pero puede ser dificil de mantener.
- *Estructura en módulos*, módulos con uno o varios subsistemas.
      - más fácil de mantener, permite el uso de objetos abstractos. Menos eficiente.
- *Estructura en capas o niveles*
      - los servicios está distribuidos en capas, y cada capa solo puede llamar a servicios de capas inferiores.
      - No es muy eficiente, pero es fácil de depurar.
      - Dificil de diseñar que servicios van en cada capa.
- *Estructura extensible*
      - micro núcleo (cotrol del hardware) + extensiones del núcleo (estructuras de control).
      - Extensions y el núcleo usan un esquema cliente/servidor
      - Las aplicaciones de usuario y la extensiones del núcleo usan un esquema cliente/servidor
      - Manejabilidad, Extensibilidad, Fiabilidad, Soporte de múltiples SO, Portabilidad.
      - Menor rendimieno por el paso de mensajes
  
* Descripción y control de procesos
** Tipos de procesos
- *Procesos de usuario*
- *Procesos demoio*, no asociados a ningún usuario.
- *Procesos del sistema operativo*, por ejemplo el intercambio a memoria secundaria de procesos.

** Estados de un proceso
- *Nuevo*
- *Preparado*
- *Ejecutándose*
- *Bloqueado*
- *Terminado*
  
** Creación de procesos
*** Acciones para crear un proceso más comunes.
1. *Comprobar si el proceso puede ser creado*, comprueba espacio en memoria o
    número máximo de procesos permitido entre otras.
2. *Asignar una entrada de la tabla de procesos para el nuevo proceso* (PCB), un identficador numérico (PID).
3. *Reservar espacio en memoria para el proceso*, espacio para el espacio de direcciones lógicas
    y para la información del bloque de control del proceso.
4. *Inicializar el bloque de control del proceso*, ponerle los datos.
5. *Establecer los enlaces apropiados*, punteros adecuados a las estructuras de control.

*** Causas más comunes.
- *Arranque del sistema operativo*, demonios, interpretes de commandos, etc.
- *Interacción con el usuario*.
      - Desde interprete de commandos.
      - Desde un entorno de ventanas.
- *Inicio de un trabajo por lotes*, Cada vez que se inicia un trabajo por lotes se crea un proceso.
   asociado a la ejecución de dicho trabajo.
- *Un proceso invoca a una llamada al sistema para crear un nuevo proceso*.
      - Proceso padre y proceso hijos.
      - Proceso padre puede terminar, ejecutarse concurrentemente o esperar a que acabe algún proceso hijo.

** Estructuras de control del SO
- *Tabla de procesos*, información relevante sobre cada proceso.
      - *PCB*, process control block, cada entrada de la tabla de procesos.
- *Tablas de memoria*, Espacio asignado y espacio libre de la memoria principa y del área de intercambio.
- *Tablas de E/S*, información sobre si un dispositivo está disponible y que proceso lo está utilizando.
- *Tablas de archivos*, Archivos abiertos por los procesos, ubicación en memoria secundaria, estado y otros atributos
- *Pilas de control de sistema* o pilas del sistema operativo,
  almacena parámetros y datos asociados a funciones del sistema operativo.
- *Pila de interrupciones*, utilizada por todos los manejadores de interrupciones.
- Colas de procesos o eventos. cola de procesos preparados, colas de procesos bloqueados, etc.

** Cambio de proceso
- Causas
      - *Proceso en ejecución pasa al estado bloqueado*
      - *Terminación voluntaria o forzada*
      - *SO termina de atender una interrupción y existe otro proceso de mayor prioridad*
      - *El proceso ha excedido el máximo tiempo de ejecución ininterrumpida*
- *Tiempo de conmutación* tiempo requerido par el cambio de proceso.

** Procesos Multihilo
- *Hilo o traza de ejecución (thread)*, flujo de desarrollo de un proceso, el program counter y todo eso.
- *multihilo*, un proceso puede contener más de 1 hilo.
      - Los hilos comparten el mismo espacio de direcciones virtuales.
- Aumenta el tamaño de las estructuras de control
- *Aumenta el rendimiento del sistema*, La creación de un hilo es más eficinte que la creación de un proceso.
- *Ahorro de recursos*, La creación de un hilo nuevo dentro de uno ya existente requiere menos recursos.
- *Aprovechamiento de las arquitecturas multiprocesador*
- *Simplificación de la estructura de aplicaciones*, simplifica el diseño de aplicaciones con muchas tareas diferentes.

- El proceso limita los estados de los hilos.
      - Pero los hilos pueden estar en diferentes estados.
- Un proceso no puede entrar en estado terminado hasta que no terminan todos sus hilos.

- *tipos de hilo*
      - hilo a nivel usuario, librería que emula un planificador de tareas (pthreads).
        Creo que suele estar escrita a bajo nivel. Realmente es un solo hilo.
            - Portable
            - No requiere el uso del núcleo
            - Planificación independiente.
      - hilo a nivel núcleo (real), implementados en el OS.

- *Principales configuraciones*
      - *Múltiples hilos de usuario sin soporte de hilos de núcleo*, 
      - *Un hilo de núcleo por cada hilo de usuario*
      - *Menor número de hilos de núcleo que hilos de usuario*
            - El programador gestiona que hilos de núcleo gestionan los hilos de usuario de la aplicación.

* Planificación de procesos
** Niveles de Planificación
** Algoritmos de planificación
- $T_{LL}$, tiempo global en el que un proceso llega a la cola de planificación.
- $T_F$, Tiempo de finalización, tiempo global en el que el proceso finaliza.
- $T_S$, Tiempo de servicio, tiempo de ejecución de un proceso.
- $T_R$, Tiempo de retorno.
      - $T_R = T_F - T_{LL}$
- $T_E$, Tiempo de espera.
      - $T_E = T_R - T_S$

*** Algoritmo de planificación del primero en llegar - primero en ser servido (FCFS)
:PROPERTIES:
:ID:       b7ad7f03-7276-428e-9f9d-2bd78b74bb25
:END:
- *FCFS*, First-Come First-Served
- Tipo *no expropiativo*.
- Requiere de una cola tipo FIFO.
- Desventajas.
      - Tiempos de espera variables y largos.
      - Funciona mejor en procesos largos.
      - Favorece a los procesos limitados por el procesador.
- Preferible su uso en un sistema por lotes o en combinación con otros algoritmos.

*** Planificación de primero el proceso más corto (SJF)
:PROPERTIES:
:ID:       29503444-e8b2-461d-90b1-b187c128f484
:END:
- *SJF* (shortest Job First) o *SPN* (shortest process next).
- Tipo *no expropiativo*.
- Primero el proceso con tiempor de procesamiento más corto.
      - Si varios tienen el mismo tiempo de procesamiento se aplica [[id:b7ad7f03-7276-428e-9f9d-2bd78b74bb25][FCFS]].
- Se suele usar en sistemas por lotes.
- En un sistema por lotes el tiempo de procesamiento es la ejecución total del proceso.
- En un sistema de tiempo compartido el tiempo es la duración de la próxima ráfaga de un poceso.
- Favorece a procesos cortos pero pueden quedarse procesos en espera indefinida.
- Es dificil estimar la duración de un proceso.
      - Mejores estimaciones producen mayor sobrecarga en el sistema.
      - *Predictor promedio exponencial*.
            - $M_{n+1} = \alpha \cdot t_n + (1 - \alpha) \cdot M_n$
                  - $n \in \mathbb{N}$
                  - $M_n$ es el tiempo estimado.
                  - $t_n$ es la duración real.
                  - $\alpha$ es el peso.
            - $M_{n+1} = (\sum_{i=1}^n \alpha \cdot t_i(1-\alpha)^{n-i}) + (1 - \alpha)M_0$

*** Planificación del proceso con menor tiempo restante (SRT)
- *SRT* (Shortest remaining time first).
- Versión *expropiativa* de [[id:29503444-e8b2-461d-90b1-b187c128f484][SJF]].
- Si llega a la cola de preparados un proceso con menor tiempo de ejecución, se expropia al proceso actual.
- Se suele usar en sistemas por lotes.

*** Planificación de turno rotatorio (Round Robin)
- *Round Robin* o cícliclo.
- Tipo *expropiativo*, basado en [[id:b7ad7f03-7276-428e-9f9d-2bd78b74bb25][FCFS]].
- Asigna uso ininterrumpido del procesador durante una cantidad fija de tiempo
   denominada *cuanto (quantum)* o *rodaja de tiempo (time slice)*.
      - Pasado el cuanto, se genera una interrupción de reloj que interrumpe el proceso actual.
      - Se pasa a ejecutar el primer proceso de la cola FCFS.
      - El proceso interrumpido pasa al final de la cola de planificación.
- El tamaño del cuanto es clave para su eficacia.
      - El cambio de proceso introduce sobrecargas.
      - Porcentaje de sobrecarga $p_s = \frac{s}{s+q} \cdot 100$.
            - $s$ tiempo promedio de cambio de proceso.
            - $q$ tiempo de 1 cuanto.
      - Se recomienda un tiempo $q$ ligeramente superior al promedio de una ráfaga de procesador.
- Diseñado para sistemas de uso compartido. Es justo pero $t_R$, $t_E$ pueden ser largos.

*** Planificación basada en prioridades
- Asigna a cada proceso en el momento de su creación una *prioridad de ejecución* (entero positivo).
- Prioridades iguales se resuelven con *FCFS* o *SJF*.
- *Prioridad estática*, no cambia el valor de prioridad.
- *Prioridad dinámica*, cambia el valor de prioridad durante la vida del proceso.
- puede ser *expropiativo* o *no expropiativo*
      - *expropiativo*, se le llama guiado por eventos (event driven).
      - Expropia cuando llega un proceso con una prioridad mayor.
- Procesos con prioridad baja pueden sufrir inanición.
      - *Envejecimiento* (aging) consiste en aumentar la prioridad de procesos conforme más tiempo
        están en espera.
      - Otra forma es reducir la prioridad del proceso que se está ejecutando in poco.
      - Otra forma es introducir cuantos y un proceso no puede estar más de dos cuantos seguidos en ejecución.
- *Inversión de prioridades*, Un recurso A de mayor prioridad tiene que esperar a un proceso B de menor prioridad
  que está usando un recurso C que necesita A.
  Para resolver el conflicto A puede ceder su prioridad a B hasta que B acabe de usar el recurso C.
 
*** Planificación basada en múltiples colas de prioridad
- Varias colas donde cada cola solo puede contener procesos de una determinada prioridad.
- Se ejecutan los procesos de las prioridades más altas.
- Un proceso solo puede pertenecer a una cola a lo largo de su vida.
- Cada cola puede usar algoritmos diferentes para organizarse.
- Para evitar inanición se puede establecer porcentajes de uso de los recursos a cada cola.

*** Planificación basada en múltiples colas de prioridad y realimentación
- En esta versión los procesos pueden cambiar de cola de prioridad a lo largo de su vida (realimentación).
- Implementación
      - Un nuevo proceso llega a $CP_0$ (cola prioridad 0, la mayor).
      - Después de un cuanto de uso de procesador, cada proceso desciende a una cola de prioridad inferior.
            - Un proceso en la cola de menor prioridad vuelve a ella después de un cuanto (parecido a RoundRobin).
            - También pueden aplicarse algoritmos diseñados para calcular una nueva prioridad a cada proceso,
              así un proceso puede tanto subir como bajar de prioridad.
      - Se favorecen a los procesos nuevos y cortos.
      - El tamaño de el cuanto puede variar entre las colas para intentar evitar la inanición de los procesos de prioridad baja.
      - Algoritmo muy flexible pero más complejo de implementar.

*** Planificación por tiempo límite
- Propio de sistemas de tiempo real estricto (deadline)
- Importante completar los procesos en un tiempo preestablecido.
- Solo se añaden a la cola los procesos que garanticen que su ejecución queda dentro de su tiempo límite (cada proceso tiene un deadline).
  Teniendo en cuenta los procesos ya existentes en la cola y los plazos de servicio.
- el *algoritmo de planificación de primero el proceso de tiempo límite más cercano* minimiza el número de procesos que no se ejecutan.

* Sincronización y cominicación de procesos
** Semáforos
- Es una variable $S$ sobre la que se pueden aplicar 3 operaciones
      - $S=N$, *init_sem*, Asignación valor Inicial N.
      - $P(S)$, *wait_sem*, disminuye en 1 el valor del semáforo. Si el número es negativo el proceso invocador
        es añadido a la cola de bloqueados.
      - $V(S)$, *signal_sem*, incrementa en 1 el valor del semáforo, si $S \leq 0$ (hay procesos en cola) se despierta un proceso de la cola de bloqueados y lo elimina de la cola.
- *Semáforo binario o mutex*
      - Versión simplificado, tan solo puede tomar los valores 0 o 1 (inicializado en 1 o 0).
            - *wait_sem*, si $S=0$ entonces el proceso es colocado a la cola de bloqueados.
              Si $S=1$ pone el semaforo a 0 y continua.
            - *signal_sem*, Comprueba si la cola está vacía.
                  - Vacía, pone el semaforo a 1 y continua.
                  - No vacía, despierta un proceso y lo elimina de la cola.

- Lo implementa el Sistema Operativo.
      - El proceso hace llamadas al sistema

- Se usan tantos semáforos como recursos distintos compartan los procesos en una sección crítica.
- Pueden usarse para la sincronización de procesos.
- La colocación inadecuada puede provocar race conditions, inanición o interbloqueo.

** Mensajes
- sockets y buzones

** Monitores
*** Definición
- Como una clase que solo permite ejecutar a un único proceso alguno de sus procedimientos.
      - Dos procesos no pueden ejecutar dos procedimientos diferentes.
      - Solo un proceso puede estar ejecutando algun procedimiento del monitor en un instante dado.
- Las variables son solo accesibles por el propio monitor.
- *Variables de condición*, útil para la sincronización de procesos. Pueden realizarse dos operaciones (dentro del monitor).
      - *wait_mon*, El proceso queda bloqueado hasta el complimiento de la variable de condición
            - En consecuencia otro proceso puede acceder al método.
      - *signal_mon*, Comprueba si la cola de procesos bloqueados está vacía.
            - No está vacía, despierta un proceso (y lo quita de la cola).
            - Está vacía, no tienen ningún efecto.
            - El proceso invocador.
                  - Hansen, el proceso invocador sale del procedimiento inmediatamente (como un return).

* Interbloqueos
** Introducción
- Recursos hardwre y recursos software (archivos, semaforos)

- *Recurso Reutilizable*, no se destruye después de su uso.
- *Recurso Consumible*, puede producirse y consumirse.
- *Interbloqueo*, conjunto de procesos está bloqueado esperando la liberación de uno a varios recursos a su vez asignados
  a otros procesos del mismo conjunto.
      - Como todos están bloqueados ninguno liberará los recursos.
- condiciones para que se produzca interbloqueo.
      - *Exclusión mutua*
      - *Retención y espera*, los procesos retienen los recursos asignados mientras esperan
        la adquisición de los otros recursos.
      - *No existencia de expropiación*
      - *Espera circular*, en un mismo conjunto procesos retienen recursos A y requieren recursos B
        mientras otros procesos retienen recursos B y requieren recursos A.
- Principales estratégias para tratar interbloqueos
      - *Prevención de interbloqueos*, impedir que se produzca alguna de las 4 condiciones necesarias.
      - *Evitación de interbloqueos*, no asignar lo recursos en situaciones potencialmente peligrosas.
      - *Detección y recuperación de interbloqueos*, cada cierto tiempo se comprueba si existe un interbloqueo en el sistema.
        Si existe se toman las medidas oportunas.

** Grafos de asignación de recursos
- Se presupone exclusión mutua y no existencia de expropiación
- Si no hay ciclo no hay interbloqueo
- Si hay ciclo y un solo recurso del tipo hay interbloqueo
- Si hay ciclo y más de un recurso del tipo, hay interbloqueo si todos los recursos forman parte de un ciclo.

[[file:images/GrafoInterbloqueo.png]]  

** Prevención de interbloqueos
- *Eliminación de la exclusión mutua*, No se puede eliminar si se quiere garantizar
  la integridad y la no corrupción de los mismos.
- *Eliminación de la retención y espera*.
      - Puede exigirse que un proceso solicita de una sola vez todos los recursos.
      - Conocer de antemano qué recursos va a necesitar un programa es dificil.
      - Puede provocar inanición a algunos procesos.
- *Elminación de lo no existencia de la expropiación*.
      - Es posible en recursos donde el sistema pueda salvar el estado en el que se encontraba.
        así restaurarlo de vuelta al proceso expropiado. Puede suponer una sobrecarga importante.
- *Eliminación de la condición de espera circular*
      - Forzando que un proceso solo pueda solicitar recursos en orden ascendente.
      - Cada recurso tiene asignado un número único.

** Algoritmos de detección de interbloqueos (alg. Coffman)
- $R_E$, vector recursos existentes
- $R_D$, vector de recursos disponibles
- $A$, Matriz de recursos asignados
      - Cada fila asociada a un proceso
      - Cada columna asociada a un recurso
- $M$, Matriz de recursos necesitados (sin contar los asignados)
      - Cada fila asociada a un proceso
      - Cada columna asociada a un recurso
- Se van marcando los procesos que pueden ser completados.
- Si todos los procesos se marcan no existe interbloqueo. Pasos.
      1. Se marcan los procesos con todo 0s en su fila en la matriz $A$.
             - Sin recursos no puede producir interbloqueo.
      2. $X=R_D$, X es un vector auxiliar.
      3. Se comprueba $M_i \leq X$, siempre que la fila $i$ no esté marcada.
      4. Dos opciones
             - si $\lnot \exists i | M_i \leq X$ entonces finaliza el algoritmo.
             - si $\exists i | M_i \leq X$ entonces se marca el proceso $i$ y $X = A_i + X$ y se vuelve al paso 2.

* Administración de Memoria
** Particionamiento dinámico
** Particionamiento estático
** Paginación Simple
*** Descripción
- Memoria principal se divide en bloques del mismo tamaño $S_p$ denominados *marcos de página*.
- El espacio de direcciones de un proceso se divide en bloques del mismo tamaño $S_p$ denominados *páginas*.
- $N_{MP} = floor \left( \frac{C_{MP}}{S_P} \right)$
      - $N_{MP}$ número de marcos en memoria principal.
      - $C_{MP}$ capacidad de la memoria principal.
      - $S_P$ tamaño de una página o marco.
- A cada marco se le asigna un id único $j,\ j \in \mathbb{N}$ (empezando en 0).
      - $j \in [0, N_{MP}-1]$
      - Se habla de /marco de página j/.
- Diagrama de marcos de memoria principal.
  [[file:images/MarcosMemPrincpl.png]]
- $N_P = ceil \left( \frac{C_X}{S_P} \right)$
      - $N_P$ número de páginas de un proceso.
      - $C_X$ tamaño de espacio de direcciones lógicas de un proceso.
      - $S_P$ tamaño de una página.
- A cada página del proceso se le asigna un id único $i,\ i \in \mathbbn{N}$ (empezando en 0).
      - $i \in [0, N_P -1]$
      - Se habla de /número de página i del proceso X/.
- Diagrama páginas de un proceso
  [[file:images/PaginsProcss.png]]
- En un instante un marco $j$ puede estar ocupado por una página $i$.
      - Si no está ocupado se dice que está /libre/.
- hay $N_{MP} - V$ márcos disponibles para procesos de usuario.
      - $V$ máscos usados por el núcleo del sistema operativo.
- Dir física $Dir_F$ de $n$ bits consta de dos campos.
      - | j (f bits) | desplazamiento (d bits) | -> $n$ bits
      - $f = ceil( log_2 (N_{MP}))$
      - $d = ceil( log_2 (S_P))$
      - $n = f + d$  ,   $n=ceil(log_2(C_{MP}))$
- Dir lógica $Dir_L$ de $m$ bits consta de dos campos.
      - | i (p bits) | desplazamiento (d bits) | -> $m$ bits
      - $p = ceil(log_2(N_P))$
      - $d = ceil(log_2(S_P))$
      - $m = p + d$   ,   $m = ceil(log_2(C_X))$
- $m \leq n$
- Diagrama direcciones físicas direcciones lógicas
  [[file:images/DirFiDirLo.png]]

- Estructuras generales para implementar paginación.
      - *Tabla de páginas*, A cada proceso se le asigna una tabla de páginas.
            - Cada entrada contiene.
                  - Marco $j$ que almacena la página $i$.
                  - Permisos de acceso a la página $i$.
                  - Puede contener la ubicación en memoria secundaria de la copia de la página $i$.
            - El *bloque de control  de un proceso* almacena un puntero al inicio
              de la dirección física de la *tabla de páginas*.
      - *Tabla de marcos de página*, contiene tantas entradas como marcos de página.
            - Cada entrada $j$ contiene.
                  - Estado del marco, libre o ocupado.
                  - Punteros para crear lista de marcos libres.
                  - Ubicación en memoria secundaria de la página $i$ almacenada en el marco $j$
      - *Lista de marcos libres*, consultada cuando hay que asignar marcos a procesos.
            - Se coge el primer marco de la lista.
            - Cuando un marco se libera se pone al final de la lista.

- En paginación simple todas las páginas de un proceso deben estar cargadas en memoria.
      - Pueden ser marcos No contiguos.
      - Si un proceso es intercambiado a memoria secundaria, sus marcos pueden ser diferentes cuando
        vuelva a ser cargado en memoria principal.

*** Traducción De Direcciones
- Información que se carga en diferentes partes del hardware.
      - *Registro Base*, Almacena la dirección física del comienzo de la /tabla de págnas/.
      - *Banco de registros*, Almacena una copia completa de la /tabla de páginas/.
      - *Buffer de traducción de vista lateral (TLB)*, Almacena algunas entradas de la tabla de páginas (caché).

- *Traducción de direcciones con un registro base*
      - Se carga en el *registro base* el inicio de la dirección física de la *tabla de páginas* $Dir_{F\ t.pag(0)}$.
      - Cuando una instrucción referencia a una dirección lógica $Dir_L$ se suma $Dir_{F\ t.pag (i)} = Dir_{F\ t.pag (0)} + i$.
      - Se lee de memoria principal $Dir_{F\ t.pag(i)}$ para obtener $Dir_{F\ marco(j)}$.
      - $Dir_F = [\ Dir_{F marco(i)}\ |\ desp\ ]$
            - $desp$ son los bits de desplazamiento de $Dir_L$.
      - Es un método poco eficiente por los accesos a memoria principal.

- *Traducción de direcciones con un banco de registros*
      - Se copia la tabla de páginas en el banco de registros.
      - La traducción de $Dir_L$ a $Dir_F$ es igual que la traducción con un registro base.
      - Se evitan accesos a memoria principal pero la tabla de páginas está limitada por el tamaño del banco de registros.
      - Cuando se produce un cambio de proceso hay que copiar la tabla de páginas,
        lo que incluye una sobrecarga.

- *Traducción de direcciones con un TLB*
      - Memoria cache de alta velocidad.
      - Cada entrada contiene una entrada de la tabla de páginas del proceso actual (colo los campos relacionados con la traducción de direcciones).
      - Se consulta en paralelo el campo $i$ de una $Dir_L$.
            - Si la entrada $i$ está presente en la TLB se produce un acierto y se construye $Dir_F$..
            - Si se produce un fallo se consulta la tabla de páginas en memoria principal.
                  - Se actualiza la TLB. Hace falta un algoritmo de reemplazamiento.
                  - Se construye $Dir_F$.
      - Si se implementa por hardware o hardware en colaboración con el OS es necesario usar el registro base.
            - El valor del registro base es $Dir_{F\ t.pag(0)}$.
      - Cuando se intercambia un proceso, se borran las entradas de la TLB y se actualiza el registro base.

- *Tablas de páginas paginadas*
      - Un proceso con un espacio lógico muy grande tendrá una tabla de páginas muy grande.
            - El espacio de memoria de la tabla de páginas debe ser contiguo.
      - *La tabla de páginas paginadas* permite la fragmentación de la tabla de páginas en memoria no continua.
      - Se distinguen dos tipos de páginas.
            - *Páginas ordinarias*, contiene instrucciones y datos del espacio lógico de un proceso.
            - *Páginas de tablas de páginas*, contienen entradas de una tabla de páginas.
      - *tabla de páginas de primer nivel*, Se usa para localizar una de las tablas de páginas en memoria principal.
            - Solo hay 1 por proceso
            - las entradas son el índice de las *páginas de tablas de página*.
            - Accedemos al marco que contiene una *tabla de páginas de segundo nivel* o *página de tablas de página*.
      - *tabla de páginas de segundo nivel*, tabla con las direcciones físicas de los marcos de las páginas que incluye.
            - Pueden haber varias tablas.
            - Pagina *páginas ordinarias* del proceso.
      - Dirección lógica usando tablas de páginas paginadas.
            - | índice tabla primaria (*ITP*) (*r bits*) | índice tabla secundaria (*ITS*) (*s bits*) | desplazamiento (*d bits*) |
            - *Índice tabla primaria (ITP)*, entrada de la tabla de páginas de primer nivel (empieza en 0).
                  - $N_{TP1}$, número de entradas de la tabla de primer nivel.
                  - $r=ceil(log_2(N_{TP1}))$, bits del ITP.
            - *Índice tabla secundaria (ITS)*, entrada de la tabla de segundo nivel (empieza en 0).
                  - $N_{TP2}$, número de entradas de las tablas de segundo nivel.
                  - $s = ceil(log_2(N_{TP2}))$, bits del ITS.
      - Pueden implementarse los niveles de paginación que se deseen pero supone más accesos a memoria.
      - Puede mejorarse la eficiencia con una TLB.

- *Tablas de páginas invertidas*
      - Se compone de una entrada por cada marco $j$ (tamaño fijo).
            - En cada entrada se almacena el /pid/ del proceso y el número de página $i$.
      - El marco $j$ correspondiente a la página $i$ del proceso $x$ se identifica buscando las coincidencias en la tabla.
            - La entrada $j$ cuyo valor es $i$ y $x$.
            - Puede ser un proceso largo y de tiempo no constante.
            - Pueden implementarse funciones hash y/o una TLB para mejorar el rendimiento.

*** Protección
- Cada entrada $i$ de las tablas de páginas contienen un campo *protección*.
      - Se indica con uno o varios bits el tipo de acceso a la página (lectura, ejecución, escritura).
      - Cada vez que el procesador intenta acceder a una dirección lógica se comprueba que el tipo de operación no viola la protección.
            - Si el acceso no está permitido el hardware genera la excepción *fallo de protección*.
      - Otro mecanismo es almacenar un *registro límite* con el número de páginas del proceso $x$.
            - Si el campo $i$ de una $Dir_L$ sobrepasa el *registro límite* se provoca una excepción.

*** Compartición de páginas
- Un programa puede ejecutarse varias veces al mismo tiempo, produciendo varios procesos del mismo programa.
- *código reentrante*, código que no se puede modificar.
- Puede ahorrarse espacio si varias instancias de un programa comparten páginas *reentrantes*.
      - El sistema operatico detecta si alguna página es de código reentrante.
- En cada entrada $j$ de la *tabla de marcos* hay un campo *contador de referencias*.
      - Indica el número de *tabla de páginas* que esta referenciando al marco $j$.
      - La página $i$ en el marco $j$ podrá eliminarse cuando el *contador de referencias* sea 0.

*** Ventajas e inconvenientes
- No produce fragmentación externa.
- Produce una sobrecarga pequeña.
- No necesita intervención humana.
- Permite compartir entre varios procesos código común.
- Produce fragmentación interna.
- Paginación invisible (transparente) al programador (buemalo).

** Segmentación Simple
*** Descripción
- Un programa se divide en segmentos.
      - Código principal
      - Subrutinas
      - Pila
      - Datos
- Cada segmento es una entidad lógica conocida por el programador.
- Cada segmento empieza por la $Dir_{L}=0$ y tiene un tamaño diferente.
- El sistema operativo asigna a cada segmento un identificador $h$ único.
      - segmento $h$ del proceso $x$.
- | N Segmento (s bits) | Desplazamiento (d bits) |
- $s = ceil(log_2(N_S))$
      - $N_S$, número de segmentos del proceso $x$.
      - $s$, número de bits del campo N Segmento.
- $d = ceil(log_2(S_S))$
      - $S_S$, tamaño del segmento expresado en número de palabras direccionables.
            - Entre segmentos puede variar.
      - $d$, número de bits del campo Desplazamiento.
- Todos los segmentos deben estar en memoria principal.
- Al cargar un programa el SO debe buscar un hueco para cada segmento.
      - A cada segmento se le asigna el espacio justo.
- A cada proceso se le asigna una *tabla de segmentos*.
      - Una entrada por cada segmento $h$ del proceso,
        con almenos un campo con la dirección física del segmento $h$.
            - También contiene información de permisos.
            - Puede contener información sobre la copia del segmento en memoria secundaria.
      - El funcionamiento es similar a la *tabla de paginación*.

*** Compartición de segmentos
- Permite la compartición de segmentos de código entre varios procesos.
- El SO mantiene una tabla con los segmentos cargados en memoria principal.
      - Funcionamiento similar a la paginación simple.

*** Ventajas e inconvenientes
- Fragmentación interna despreciable.
- Visión modular del programador.
- Permite manejar estructuras de datos que crecen (se busca un hueco más grande o se anexiona un hueco).
- Facilita compartición y protección de diferentes partes del programa.
- Produce fragmentación externa.
- Aumenta la sobrecarga del sistema.

*** Segmentación con paginación simple
- Dividir segmentos en páginas.
  
** Segmentación con paginación simple
- Segmentos se dividen en páginas
- A Cada proceso se le asigna una tabla de segmentos
      - entrada h | base | longitud |
      - El campo base almacena $Dir_{F\ t.pag\ h (0)}$.
      - *Longitud*  almacena el tamaño total del segmento
- Por cada segmento se le asigna una tabla de páginas
- Dirección lógica
      - | N de segmento h | N página i | Desplazamiento |
      - | N página | Desplazamiento | < *longitud* segmento
- *Registro base* contiene el inicio de la $Dir_F$ de la tabla de segmentos.
- Traducción de direcciones.
      1. $Dir_{F1} = h + reg.\ base$
         Encuentra la dirección del segmento $h$ en la *tabla de segmentos*.
      2. $Dir_{F2} = Dir_{F1}[base] + i$
         Encuentra la dirección física de la *tabla de páginas* del segmento $h$ y encuentra la entrada de la página $i$.
      3. $Dir_F = |\ Dir_{F2}[marco\ j]\ |\ despl\ |$
         Encuentra la dirección física del dato.
  
* Memoria virtual
** Descripción
- Consiste en tener cargadas en memoria solo aquellas partes del programa (páginas o segmentos) del espacio de direcciones lógicas (ahora también se denominan direcciones virtuales) que se están usando.
      - El OS atiende las excepiones provocadas por la demanda de una página que no está cargada en memoria principal.
- Permite aumentar el grado de multiprogramación.
- Permite direcciones lógicas mayores que la capacidad física de la memoria principal.
- Reduce las operaciones de E/S para intercambiar procesos bloqueados en memoria principal.
      - No se cargan todas las páginas.
- Requiere que el hardware soporte el reinicio de instrucciones después de una excepción.
      - *MMU*, componente de hardware dedicado a la traducción de direcciones virtuales.
      - Se pueden usar TLB's para mejorar la eficiencia.

** Paginación por demanda
*** Descripción
- Divide memoria principal en marcos de página.
- Divide el espaio del proceso en páginas.
- *fallo de página*: excepción producida por el hardware cuando se referencia una página no referenciada.
      - El OS debe tratar la excepción y luego reanudar el programa.
- Otras tareas del Sistema Operativo.
      - *Reemplazamiento de página*: Si no existen marcos libres hay que aplicar un algoritmo para seleccionar un marco usado y realizar el reemplazo.
            - Se debe guardar si fue modificada la página reemplazada en memoria.
      - *Asignación de marcos de memoria principal*: Cuantos marcos asigna inicialmente a cada proceso.
      - *Control de carga*, Debe controlar el grado de multiprogramación.
      - *Copia en memoria secundaria las páginas modificadas*, En qué momento y de que forma las copiará.
- Estructuras de datos para implementar la paginación por demanda.
      - Almacenan más información que n la paginación simple.
      - *Tabla de marcos de página*
      - *Lista de marcos libre*
      - *Tablas de páginas*, algunos campos son.
            - *Número de marco de página*
            - *Validez o presencia*, un bit, indica si la página $i$ está cargada en el marco $j$. Si la entrada es válida.
      - *Protección*, un bit, indica si la página es de solo lectura o de lectura y escritura.
            - pueden ser 3 bits, lectura escritura y ejecución.
      - *Referenciada*, 1 bit, se activa cuando $i$ es referenciada por una dirección virtual.
      - *Modificada*, 1 bit, si se indica modificada el OS debe copiarla a memoria secundaria.

*** Localización de páginas en memoria secundaria
- El OS puede buscar las páginas en memoria secundaria en dos zonas.
      - *Bloque de disco de un archivo ejecutable*, código y datos propios del programa.
        Posee el código y datos para la creación de la páginas.
      - *Bloque de disco del área de intercambio*, se almazenan las páginas de procesos ya presentes en memoria principal.

** Reemplazo de páginas  
- Tarea de seleccionar una página $k$ cargada en un marco $j$ para ser reemplazada por la página $i$ a la que hacía referencia la dirección virtual que produjo el fallo.
- *Página víctima*, página seleccionada para ser reemplazada.
- *Conjunto de marcos candidatos*, marcos donde se encuantran las páginas candidatas.
- *Estrategia de reemplazo de páginas local*, El conjunto de páginas candidatas a ser reemplazadas pertenecen al proceso que provocó el fallo de página.
      - Sólo páginas no bloqueadas.
      - Produce mayor sobrecarga.
- *Estrategia de reemplazo de página global*, El conjunto de páginas candidatas a ser reemplazadas se forma con todas la páginas cargadas en memoria.
      - Sólo páginas no bloqueadas.

*** Algoritmo de reemplazamiento óptimo
- Selecciona aquella página que tardará más en ser referenciada por una dirección virtual.
- Es un algoritmo teórico, sirve como modelo para comparar a otros algoritmos.

*** Algoritmo de reemplazamiento LRU
- Last recently used (LRU).
- Selecciona aquella página que lleva más tiempo sin ser usada.
- Bastante bueno, pero es complejo de implementar y produce bastante sobrecarga.
      - Una lista enlazada, cada vez que una página es referenciada se coloca al inicio de la lista.
            - Al final de la lista está la página candidata a ser reemplazada.
      - El hardware puede incluir una implementación basada en contadores.
            - la tabla de páginas incluye un contador para cada página.
            - La página con menor valor es la candidata a ser reemplazada.
            - Introduce bastante sobrecarga.

*** Algoritmo de reemplazamiento mediante envejecimiento
- también conocido como *aging*.
- A cada página se le asigna un registro de desplazamiento software te tamaño $n$ y un bit de referencia.
      - El registro de desplazamiento se inicializa a 0.
      - Si la página ha sido referenciada se pone el bit de referencia a 1.
      - Cada cierto tiempo $T$ se desplaza el registro de desplazamiento hacia la derecha.
            - Se introduce el valor del bit de referencia y se vuelve este a 0.
      - La página candidata es aquella con el número en binario menor.
            - Si hay varias se selecciona una de ellas de forma aleatoria.

*** Algoritmo de reemplazamiento FIFO
- Sufre de *anomalía de Belady*, aumentan los fallos si aumentan los marcos en memoria principal.
- Selecciona aquella página del conjunto de candidatas que lleva más tiempo cargada.
- Se puede implementar con una lista enlazada.
- Solo es necesario actualizar la estructura de datos cuando se carga una página en un marco de página.
- No tiene muy buenos resultados pero es sencillo de implementar, produce poca sobrecarga.

*** Algoritmo de reemplazamiento de la segunda oportunidad (algoritmo del reloj)
- Busca la página más tiempo cargada en memoria que no ha sido cargada recientementem
      - variante de *FIFO*.
- Lás páginas referenciadas tienen un bit de referencia que empieza en 0 ($r=0$).
- El algoritmo consulta el bit de referencia de la página que está al principio de la cola FIFO.
      - Si es $r=0$, la página es seleccionada y el algoritmo finaliza.
      - Si $r=1$, pone $r=0$ y coloca la página al final de la cola.
            - A continuación consulta el bit de referencia de la nueva página en el inicio de la cola.
- Mejores resultados que *FIFO*, pero mayor sobrecarga.
- *Algoritmo del reloj*, Para reducir la sobrecarga puede usarse una lista circular.
      - Un puntero va seleccionando el inicio de la cola.
            - Si el puntero se desplaza rota los elementos de la cola
            - El inicio de la cola es donde apunta el puntero,
              el final de la cola es la posición anterior donde apunta el puntero.
- *Algoritmo del reloj mejorado*, se añade el bit $m$ (modificada).
      - Tipos de página.
            - Páginas con $r=0$ y $m=0$, ni referenciada ni modificada. Ideal para ser reemplazada.
            - Páginas con $r=0$ y $m=1$, fueron modificadas, no han sido referenciadas recientemente.
                  - Requieren una operación de escritura al ser reemplazada (por estar modificada).
            - Páginas con $r=1$ y $m=0$, Referenciada recientemente pero no modificada.
            - Páginas con $r=1$ y $m=1$, Referenciada recientemente y modificada. La peor candidata posible.
      - En primer lugar busca una página con $r=0$ y $m=0$ (una ronda completa).
            - No actualiza los valores de $r$.
      - Si no encuentra ninguna busca una página con $r=0$ y $m=1$ (segunda ronda).
            - En esta segunda ronda actualiza los valores de r $r=0$.
      - Si no encuentra ninguna busca una página con $r=0$ y $m=0$ (tercera ronda).
            - La segunda ronda actualizó los valores de $r$, por eso es posible encontrar alguna esta vez.
      - Si no encuentra ninguna busca una página con $r=0$ y $m=1$.

*** Algoritmo de reemplazamiento del reloj considerando el conjunto de trabajo (WSClock)
- *Algoritmo WSClock*,  Mejora del algoritmo del reloj.
- Busca páginas con $r=0$ y $m=0$ que no pertenezcan al conjunto de tabajo del proceso.
- Requiere del campo en la tabla de páginas  *tiempo de último uso* $T_{ult.uso}$.
      - $E_{i} = T_{virt.proc} - T_{ult.uso\ i}$, edad de la página $i$.
      - Si $E_i < \Delta$ la página pertenece al conjunto de trabajo del proceso.
- Si $r=1$ entonces se pone $r=0$ y pasa a la siguiente página.
      - Además $T_{ult.uso\ i}=T_{virt.proc}$
- Si $r=0$
      - Si $m=0$ se calcula la edad y se compara con $\Delta$.
            - Si $E_{i} > \Delta$ entonces se selecciona la página (no pertenece al conjunto de trabajo).
            - Si $E_{i} < \Delta$ entonces pertenece al grupo de trabajo y pasa a la siguiente.
      - Si $m=1$, se planifica para ser escrita en el área de intercambio, y pasa a la siguiente página.
            - No tiene porque ocurrir inmediatamente (depende del disco y los controladores).
            - Cuando se escrita se pasa $m=0$.
- Si durante una vuelta todas las páginas pertenecen al conjunto de trabajo.
      - se selecciona la primera página con $r=0$ y $m=0$ que pertenezca al conjunto de trabajo.

** Asignación de memoria principal

* Gestión de la Entrada/Salida

** Discos Duros
*** Estructura Física
- Principal soporte de la memoria secundaria.
- Alta capacidad de almacenamiento.
- Formado de varios platos circulares de aleación o plástico, giran a velocidad constante (5400, 7200 o 10800 rpm)
- Las dos superficies del disco están recubiertas de material magnetizable.
- *Pistas*: Anillos concéntricos en los que se divide una superficie del disco.
      - Hay una pequeña separación entre pistas.
- *Sectores*: Las pistas se dividen en cientos de sectores.
      - Hay un pequeño hueco entre sectores.
      - Es la unidad de transferencia de un disco duro.
- *Cabeza de lectura/escritura*: sobre cada superficie se monta un brazo en cuyo extremo está la Cabeza.
      - El brazo puede buscar la pista donde se encuentra el sector destino.
      - Lee y/o escribe sectores del disco.
- *Cilindro*: Conjunto de todas las pistas de todos los discos situados a la misma distancia del eje.
      - Todas las cabezas se mueven al unísono de cilindo en cilindro.
- Las pistas de las *Zonas* externas de un disco contienen mayor densidad de sectores.
      - Circuitería compleja.

*** Formateo a bajo Nivel
- Consiste en dividir cada superficie en pistas y cada pista en sectores.
      - Necesario para ser utilizado.
      - Realizado por el fabricante.
- Elementos de un sector
      - *Cabecera o preámbulo*, Contiene un patrón que permite al controlador de disco reconocer el comienzo del sector, número del sector y número de cilindro.
      - *Área de datos*, Información accesible para el sistema operativo y el usuario.
            - unos 512 bytes de tamaño.
      - *Código de corrección de errores* (ECC), Contiene información que permite al controlador
        de disco detectar y corregir errores de lectura.
            - Suele ocupar 16 bytes.
      - Cabecera y ECC consumen espacio del espacio total del disco.
      - La separacón de pistas y sectores ocupa espacio del disco.
- Un disco tiene sectores de reserva por si falla algún otro sector.
- Tras el formatio a bajo nivel el disco se reduce entorno a un 20%.
- La numeración de sectores se realiza con *intercalado* o *entrelazado*.
- La numeración de sectores está desplazada entre pistas adyacentes (Cylinder skew).
      - Mejora el rendimiento.
- Dirección física de un sector: [ n. cilindro | n.cabeza | n. sector ]
      - sistema cilindro-cabeza-sector (Cylender-Head-Sector, CHS)
- Discos más modernos soportan LBA (Logical block addressing, direccionamiento de bloques lógicos).
      - Correspondencia sector con bloque lógico.
      - El controlador de disco hace la traducción a CHS.

*** Particionamiento y formateo a alto nivel del disco
- Particionamiento y formateo de alto nivel (o formateo lógico).
- *Partición*: conjunto de cilindros contiguos.
      - Desde el punto de vista lógico cada partición se considera un disco.
- *Tabla de particiones*, estructura que contiene el propio disco acerca de las particiones y tamaño de estas.
      - También se indica donde se encuentra el OS.
      - Se localiza dentro del *registro de arranque*, dentro del sector 0.
- Una vez particionado, cada partición tiene un formateo lógico de alto nivel.
      - bloque o sector de arranque si es una partición activa.
      - estructura de datos de los sistemas de archivos.
- Algunas particiones no tienen porque tener ningún sistema de estructuras de archivos
      - E/S por bloques, es más rápido
      - por ejemplo el Swap de linux.

*** Planificación del disco

*** Tratamiento de los errores del disco

* Gestión de archivos
** Estructura de directorios de gráfica acíclica
- *link*, conectar un archivo o directorio con otro ya existente.
      - Se dice que está compartido.
      - Enlace duro (Hard). Entrada especial en un directorio.
            - Apunta a archivos almacenados en otros directorios.
            - Problemas de sincronización (atributos de archivo), estructuras de control.
            - Requiere del recuento de las referencias a un archivo.
            - Puede estar consumiendo espacio de otro usuario.
      - Enlace simbólico (soft), es un archivo especial que contiene la ruta absoluta o relativa del destino.
            - Consume espacio y aumenta el número de operaciones E/S.
            - Su control es mucho más sencillo.
                  - Pueden quedarse simplemente rotos.
      - Hay que tener en cuenta que pueden dar ciclos si se están recorriendo la estructura de directorios.
      - En copias de seguridad puede llegar a copiarse el mismo archivo varias veces (sobretodo el Hard).

** Asignación Indexada
- *Nodo-I*, almacena los atributos de un archivo.
      - las direcciones físicas de los primeros bloques de un archivo (sin indirección).
      - Los nodos-i son ligeros
      - Contine punteros a *bloques de indirección*.
- *Bloque de indirección simple*, almacena direcciones físicas de bloques de archivos.
- *Bloque de indirección doble*, Almacena direcciones de bloques de indirección simple.
- *Bloque de indirección triple*, almacena direcciones de bloques de indirección doble.
- Cada archivo tiene asociado un número único asociado a un nodo-i.
- En la partición de archivos hay una tabla con todos los nodo-i.
- El nodo-i asociado a un archivo se almacena en la entrada de directorio.
- Añade un poco de sobrecarga para acceder a los datos de los archivos.

** Gestión del espacio libre
- *Lista de bloques libres*
      - Se almacena al comienzo del sistema de archivos.
      - se suele copiar una parte en memoria principal.
      - implementaciones
            - *Mapa de bits*
                  - Un bit por bloque de disco, 0 ocupado 1 libre
                  - Sencillo pero hay que mantener el mapa entero en memoria principal.
            - *Lista enlazada*
                  - Un bloque de disco puede almacenar $N_D$ direcciones de bloque.
                  - Un bloque almacena $N_D - 1$ direcciones y la dirección al siguiente bloque de direcciones.
                  - Solo es necesario mantener un bloque en memoria principal.

** Implementación de directorios
- Un *directorio* es un archivo que almacena una lista de los archivos y subdirectorios que contiene.
  
- *Directorios con entradas de igual tamaño*
      - Cada entrada de un directorio se almacena la información asociada al archivo.
      - Puede malgastar espacio de memoria para dar soporte a nombres largos.
- *Directorios con entradas de tamaño variable*
      - cada entrada tiene un tamaño diferente
      - El primer byte de una entrada es el tamaño que ocupa.
            - A continuación datos del archivo y finalmente el nombre (acabado con caracter de terminación)
            - Si hace falta se pone relleno para que el tamaño total sea un numero entero de palabras.
      - Cuando se eliminan archivos se puede crear huecos de de tamaño variable.
            - Se arregla con conpactación
- *Directorios con entradas de igual tamaño y uso de un montículo para los nombres de archivos*
      - las entradas almacenan un puntero al inicio del nombre del archivo dentro del montículo.
      - Al final del directorio se almacena la estructura tipo montículo.
            - Dentro del montículo los nombres se almacenan de forma contigua.
            - Las operaciones sobre el montículo son complicadas

- Para accelerar búsquedas en directorios
      - Puede implementarse una cache a nivel software con las entradas de los últimos archivos accedidos.
      - Puede implementarse en cada directorio una tabla hash para encontrar los archivos.

** Copias de seguridad
- *Copia de seguridad lógica*, solamente directorios y archivos que el administrador desea guardar.
      - *Copia completa*, Todos los archivos seleccionados por el administrador.
      - *Copia Diferencial*, Solamente archivos creados o modificados desde la última copia.
      - *Copia incremental*, Solamente archivos creados o modificados desde la última copia.
            - Para reconstruir los archivos hace falta todo el historial de copias de seguridad.
- *Copia de seguridad física* o imagen de disco. Copia completa de todos lo bloques físicos de la partición de disco.
      - Requiere ser montada para recuperar achivos.

** Instantáneas
- modelo *Copiar al escribir*,
      - Cuando el SO necesita modificar el contenido de un bloque localiza un bloque libre.
      - Copia en el bloque libre los datos modificados.
      - Actualiza los punteros del hacia el viejo bloque hacia el nuevo bloque.
            - Toma un tiempo, el SO revisa cada 30 seg si hay que actualizar punteros.
- Cada vez que la versión actual se modifica, se crea una *nueva versión del sistema de archivos* denominada *instantánea*.
- Pueden montarse para recuperar archivos.
- Las instantáneas se toman de forma prácticamente inmediata. no ocupan espacio en el momento de su creación.
      - No se copian bloques de disco hasta que hay modificaciones.
- Las instantáneas pueden ser restauradas con gran rapidez.
- Residen en el mismo disco físico que respaldan.

** Eficiencia
- La memoria secundaria es lenta.
- Se puede cachear los bloques de disco en memoria principal.
      - *lectura por adelantado*, se cachea el bloque requerido y algunos cercanos.
- En discod magnéticos es mejor situar los nodos-i en la zona central.

* Glosario
- *LBA*, logical block addressing, direccionamiento de bloques lógicos. Numeración consicutiva de los sectores de un disco (disco duro).
- *Trampa*, interrupción insertada por el programador, para solicitar los servicios del núcleo. 
- *Contexto de un proceso* toda información necesaria para iniciar o continuar un proceso, se guarda en el PCB.
- *Overhead o sobrecarga*, tiempo de uso del computador para tareas de administración del SO.
